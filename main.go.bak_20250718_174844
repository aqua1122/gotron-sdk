package main

import (
	crand "crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/google/uuid"
	"github.com/skip2/go-qrcode"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	telegramAdminID            int64
	db                         *gorm.DB
	mu                         sync.Mutex
	adminIDs                   = []int64{6647879650} // 실제 관리자 ID로만 구성 (필요시 추가)
	processedOrders            = map[uint]bool{}
	processedOrdersMu          sync.Mutex
	mySuperAdminID             int64 = 6647879650
	verifiedUsers                    = make(map[int64]bool)
	lastAlertedCategories            = make(map[string]time.Time)
	verificationAnswers              = make(map[int64]int)
	userMessageIDs                   = map[int64][]int{}
	pendingSupportQueue              = make(map[int64]time.Time)
	activeSupportSessions            = make(map[int64]int64)
	userSelectedProduct              = make(map[int64]string)
	pendingStockImageID              = make(map[int64]string)
	pendingWalletInput               = make(map[int64]bool)
	userLanguages                    = make(map[int64]string)
	pendingStockInput                = make(map[int64]string)
	startTime                        = time.Now()
	selectedCategory                 = make(map[int64]string)
	tronGridAPIKey                   = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract                = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
	walletReceiveAddress             = os.Getenv("WALLET_RECEIVE_ADDRESS")
	unmatchedAdminChatID       int64 = 6647879650
	pendingAddProductCategory        = make(map[int64]string)
	processedTxsMu             sync.RWMutex
	adminChatID                int64 = 6647879650
	lastShownMenuMessageID           = make(map[int64]int)
	userReplyKeyboardMsgID           = make(map[int64]int)
	processedTxs                     = make(map[string]bool)
	pendingEditProduct               = map[int64]int{}
	pendingAdminInput                = make(map[int64]bool)
	pendingStockInputNotified        = make(map[int64]bool)
	pendingBroadcastInput            = make(map[int64]bool)
	pendingDepositInput              = make(map[int64]bool)
	pendingDepositAmount             = make(map[int64]float64)
	pendingStockInputMessageID       = make(map[int64]int)
	productDB                        = make(map[string]Product)
	cachedProducts                   = make(map[string][]Product)
	cachedProductOrder               = make(map[string][]string)
	cachedCategories           []string
)

var vpsProductMap = map[string]VPSProduct{
	"vps1": {Name: "KVM - E1", Price: 70.0},
	"vps2": {Name: "KVM - E2", Price: 90.0},
	"vps3": {Name: "KVM - T1", Price: 120.0},
	"vps4": {Name: "KVM - T2", Price: 150.0},
	"vps5": {Name: "맞춤 제작", Price: 1.0}, // 별도 견적용 처리 가능
}

var productCategories = []string{
	"VPS", "ACCOUNT", "MEMBERSHIP", "ESIM", "CARD",
}

var validGrades = map[string]bool{
	"bronze":  true,
	"silver":  true, // 수정: silvedb.Where("categoryr" → "silver"
	"gold":    true,
	"diamond": true,
	"admin":   true,
}

var bot *tgbotapi.BotAPI
var adminStates = make(map[int64]AdminState)

// categoryMap에 VPS 포함 및 ID 맞춤
var categoryMap = map[string]uint{
	"VPS":        1,
	"ESIM":       2,
	"ACCOUNT":    3, // 이 부분이 3이어야 합니다
	"MEMBERSHIP": 4,
	"CARD":       5,
}

var categoryOrder = []string{
	"VPS",
	"ACCOUNT",
	"MEMBERSHIP",
	"ESIM",
	"CARD",
}

// 3. 상품(이름) 노출 순서 정의 (메뉴 UI 등에서 사용)
var productOrder = map[string][]string{
	"VPS":        {"KVM - E1", "KVM - E2", "KVM - T1", "KVM - T2", "맞춤 제작"},
	"ACCOUNT":    {"TG 1년", "TG 2년", "짧은 번호"},
	"MEMBERSHIP": {"TG 프리미엄 3개월", "TG 프리미엄 1년", "YT 프리미엄 1년"}, // 변경됨
	"ESIM":       {"DATA 30 DAY", "KOREA|HK", "NO KYC"},
	"CARD":       {"국내결제", "국외결제", "항공권"},
}

// 4. 실제 상품 DB/메모리 초기화시 사용 (상품명→상품 정보)
var cardCategories = map[string]map[string]Product{
	"VPS": {
		"KVM - E1": {Code: "vps1", Name: "KVM - E1", Price: 70, Description: "CPU: 4코어, RAM: 4GB, 저장공간: 100GB NVMe, 가격: 70 USDT", Active: true},
		"KVM - E2": {Code: "vps2", Name: "KVM - E2", Price: 90, Description: "CPU: 4코어, RAM: 6GB, 저장공간: 140GB NVMe, 가격: 90 USDT", Active: true},
		"KVM - T1": {Code: "vps3", Name: "KVM - T1", Price: 120, Description: "CPU: 8코어, RAM: 16GB, 저장공간: 160GB NVMe, 가격: 120 USDT", Active: true},
		"KVM - T2": {Code: "vps4", Name: "KVM - T2", Price: 150, Description: "CPU: 12코어, RAM: 24GB, 저장공간: 256GB NVMe, 가격: 150 USDT", Active: true},
		"맞춤 제작":    {Code: "vps5", Name: "맞춤 제작", Price: 1, Description: "맞춤형은 최소 3개월 부터, 문의 후 견적 안내, 원하는 옵션에 맞춰 제작", Active: true},
	},
	"ACCOUNT": {
		"TG 1년": {Code: "tgid1", Name: "TG 1년", Price: 8, Active: true},
		"TG 2년": {Code: "tgid2", Name: "TG 2년", Price: 20, Active: true},
		"짧은 번호": {Code: "tgid3", Name: "짧은 번호", Price: 60, Active: true},
	},
	"MEMBERSHIP": { // 대문자 MEMEBERSHIP
		"TG 프리미엄 3개월": {Code: "tp3", Name: "TG 프리미엄 3개월", Price: 17, Active: true},
		"TG 프리미엄 1년":  {Code: "tp12", Name: "TG 프리미엄 1년", Price: 45, Active: true},
		"YT 프리미엄 1년":  {Code: "yp12", Name: "YT 프리미엄 1년", Price: 60, Active: true},
	},
	"ESIM": {
		"DATA 30Day": {Code: "es1", Name: "DATA 30 DAY", Price: 70, Active: true},
		"KOREA|HK":   {Code: "es2", Name: "KOREA|HK", Price: 999, Active: true},
		"NO KYC":     {Code: "es3", Name: "NO KYC", Price: 999, Active: true},
	},
	"CARD": {
		"국내결제": {Code: "card1", Name: "국내결제", Price: 10, Active: true},
		"국외결제": {Code: "card2", Name: "국외결제", Price: 10, Active: true},
		"항공권":  {Code: "card3", Name: "항공권", Price: 10, Active: true},
	},
}

type StockCard struct {
	ID          uint64 `gorm:"primaryKey"`
	Category    string `gorm:"type:varchar(100);index:idx_category"`
	Name        string `gorm:"type:text"`
	Content     string `gorm:"type:text"`
	Used        bool
	UsedBy      int64
	OrderID     int64
	PhotoFileID string `gorm:"type:text"`
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type Stock struct {
	ID        uint   `gorm:"primaryKey"`
	ProductID int    // 연관된 상품 ID
	Code      string // 재고 코드
	Used      bool   // 사용 여부
	CreatedAt time.Time
	UpdatedAt time.Time
}

type CardProduct struct {
	ID         uint `gorm:"primaryKey"`
	CategoryID uint
	Name       string
	Code       string `gorm:"type:varchar(255);uniqueIndex"`
	Price      float64
	IsActive   bool `gorm:"default:true"`
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

type AdminState struct {
	Mode     string
	Category string
	Name     string
}

type BotSetting struct {
	ID    uint   `gorm:"primaryKey"`
	Key   string `gorm:"unique;not null"`
	Value string `gorm:"type:text"`
}

type WeeklyStats struct {
	StartDate   string
	EndDate     string
	TotalSales  float64
	TotalOrders int64
}

type MonitoringWallet struct {
	ID        uint `gorm:"primaryKey"`
	UserID    int64
	Address   string `gorm:"unique"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Category struct {
	ID          uint   `gorm:"primaryKey"`
	Name        string `gorm:"type:varchar(191);uniqueIndex;not null"`
	DisplayName string `gorm:"type:varchar(191)"`
	IsActive    bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type CardCategory struct {
	ID          uint
	Name        string
	DisplayName string
	IsActive    bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type ProcessedDeposit struct {
	ID        uint      `gorm:"primaryKey"`
	TxID      string    `gorm:"uniqueIndex;not null;size:100"`
	CreatedAt time.Time `gorm:"autoCreateTime:milli"`
}

type TronDeposit struct {
	Amount float64
	TxID   string
	// ... 필요시 추가
}

type Result struct {
	Error        error
	RowsAffected int64
}

type UserWallet struct {
	ID        uint      `gorm:"primaryKey"`
	UserID    int64     `gorm:"column:user_id"`
	Address   string    `gorm:"column:address"`
	CreatedAt time.Time `gorm:"autoCreateTime"`
}

type VPSProduct struct {
	Name  string
	Price float64
}

type User struct {
	ID            uint      `gorm:"primaryKey;autoIncrement"`
	UserID        int64     `gorm:"column:user_id;uniqueIndex"` // 중복 키 문제 없다면 uniqueIndex
	UserName      string    `gorm:"column:username"`
	Nickname      string    `gorm:"column:nickname"`
	ChatID        int64     `gorm:"column:chat_id"`
	LastSeen      time.Time `gorm:"column:last_seen"`
	JoinedAt      time.Time `gorm:"column:joined_at"`
	Grade         string    `gorm:"column:grade;type:varchar(20)"`
	DepositWallet string    `gorm:"column:wallet_address"`
	Verified      bool      `gorm:"column:verified"`
	Lang          string    `gorm:"column:lang"`
}

type Transaction struct {
	TransactionID  string `json:"transaction_id"`
	From           string `json:"from"`
	To             string `json:"to"`
	Value          string `json:"value"`
	BlockTimestamp int64  `json:"block_timestamp"`
	Confirmations  int    `json:"confirmations"`
}

type TronGridResponse struct {
	Data  []Transaction `json:"data"`
	Total int           `json:"total"`
}

type TronTransaction struct {
	TxID      string
	From      string
	To        string
	AmountStr string
	Timestamp int64
}

type Deposit struct {
	TxID   string
	Amount float64
	Time   time.Time
}

type ChatInfoConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Order struct {
	ID          uint `gorm:"primaryKey"`
	UserID      int64
	Product     string
	Amount      float64
	Status      string `gorm:"type:varchar(255);index"`
	ExpectedAmt float64
	CardInfo    string  `gorm:"type:text"`
	TxID        *string `gorm:"type:varchar(255);index"`
	Timestamp   time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserBalance struct {
	UserID  int64 `gorm:"primaryKey"`
	Balance float64
}

type Visitor struct {
	UserID   int64
	UserName sql.NullString
	Nickname string
	LastSeen time.Time
}

type WalletMap struct {
	ID        uint64 `gorm:"primaryKey"`
	UserID    int64  `gorm:"uniqueIndex"`
	Wallet    string
	Username  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Wallet struct {
	ID        uint   `gorm:"primaryKey"`
	UserID    int64  `gorm:"index"`
	Address   string `gorm:"size:100;uniqueIndex"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserActivityLog struct {
	UserID     int64
	Username   string
	Nickname   string
	LastActive time.Time
}

type Inventory struct {
	ID          uint `gorm:"primaryKey"`
	Category    string
	ProductName string
	Stock       int64
	UpdatedAt   time.Time
}

type SalesStats struct {
	Date        string // 예: 일별 통계용 날짜
	StartDate   string // 예: 주간/월간 시작일
	EndDate     string // 예: 주간/월간 종료일
	TotalSales  float64
	TotalCount  int64
	SalesCount  int64
	TotalOrders int64 // 필요하다면 추가
	Count       int64
}

type Admin struct {
	ID     uint  `gorm:"primaryKey"`
	UserID int64 `gorm:"uniqueIndex"`
}

type Product struct {
	ID          uint   `gorm:"primaryKey"`
	Code        string `gorm:"unique;not null" json:"code"`
	Name        string `gorm:"not null" json:"name"`
	Description string
	Price       float64 `gorm:"not null"`
	CategoryID  uint    `gorm:"index;not null"`
	Category    string  `gorm:"-"` // DB 컬럼 아님, 단지 편의용 필드
	Active      bool    `gorm:"default:true"`
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type SimpleProduct struct {
	Code  string
	Price float64
}

type NgrokTunnel struct {
	PublicURL string `json:"public_url"`
}

type NgrokAPIResponse struct {
	Tunnels []struct {
		Name      string `json:"name"`
		PublicURL string `json:"public_url"`
		Proto     string `json:"proto"`
	} `json:"tunnels"`
}

const timeFormat = "2006-01-02 15:04:05"

func init() {
	verificationAnswers = make(map[int64]int)

	tronGridAPIKey = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract = os.Getenv("USDT_TRC20_CONTRACT")
	walletReceiveAddress = os.Getenv("WALLET_RECEIVE_ADDRESS")
	adminIDStr := os.Getenv("TELEGRAM_ADMIN_ID")

	if tronGridAPIKey == "" {
		log.Fatal("❌ TRONGRID_API_KEY 환경변수가 설정되지 않았습니다.")
	}
	if usdtTRC20Contract == "" {
		log.Fatal("❌ USDT_TRC20_CONTRACT 환경변수가 설정되지 않았습니다.")
	}
	if walletReceiveAddress == "" {
		log.Fatal("❌ WALLET_RECEIVE_ADDRESS 환경변수가 설정되지 않았습니다.")
	}
	if adminIDStr == "" {
		log.Fatal("❌ TELEGRAM_ADMIN_ID 환경변수가 설정되지 않았습니다.")
	}

	var err error
	telegramAdminID, err = strconv.ParseInt(adminIDStr, 10, 64)
	if err != nil {
		log.Fatalf("❌ TELEGRAM_ADMIN_ID 파싱 오류: %v", err)
	}
}

func getNgrokPublicURL(apiEndpoint string) (string, error) {
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(apiEndpoint)
	if err != nil {
		return "", fmt.Errorf("ngrok API 요청 실패: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("ngrok API 응답 코드 %d", resp.StatusCode)
	}

	var data NgrokAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", fmt.Errorf("ngrok API JSON 디코딩 실패: %w", err)
	}

	for _, tunnel := range data.Tunnels {
		if strings.HasPrefix(tunnel.PublicURL, "https") {
			return tunnel.PublicURL, nil
		}
	}

	return "", fmt.Errorf("ngrok https 터널을 찾을 수 없음")
}

func addVPSProducts() error {
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		return fmt.Errorf("VPS 카테고리 조회 실패: %w", err)
	}

	products := []Product{
		{
			Code:        "vps1",
			Name:        "KVM - E1",
			Description: "CPU: 4코어, RAM: 4GB, 저장공간: 100GB NVMe, 가격: 70 USDT",
			Price:       70,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps2",
			Name:        "KVM - E2",
			Description: "CPU: 4코어, RAM: 6GB, 저장공간: 140GB NVMe, 가격: 90 USDT",
			Price:       90,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps3",
			Name:        "KVM - T1",
			Description: "CPU: 8코어, RAM: 16GB, 저장공간: 160GB NVMe, 가격: 120 USDT",
			Price:       120,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps4",
			Name:        "KVM - T2",
			Description: "CPU: 12코어, RAM: 24GB, 저장공간: 256GB NVMe, 가격: 150 USDT",
			Price:       150,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps5",
			Name:        "맞춤 제작",
			Description: "맞춤형 사양 제공, 문의 후 견적 안내, 안정성과 성능 우선",
			Price:       0,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
	}

	for _, p := range products {
		var existing Product
		err := db.Where("code = ?", p.Code).First(&existing).Error

		if errors.Is(err, gorm.ErrRecordNotFound) {
			if err := db.Create(&p).Error; err != nil {
				log.Printf("❌ [%s] 상품 등록 실패: %v", p.Code, err)
			} else {
				log.Printf("✅ [%s] 상품 등록 완료", p.Code)
			}
		} else if err != nil {
			log.Printf("❌ [%s] 조회 실패: %v", p.Code, err)
		} else {
			log.Printf("ℹ️ [%s] 이미 존재하는 상품, 등록 생략", p.Code)
		}
	}

	return nil
}

func initBotWithWebhook() (*tgbotapi.BotAPI, error) {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		return nil, fmt.Errorf("텔레그램 봇 토큰이 설정되지 않았습니다")
	}

	var err error

	bot, err := tgbotapi.NewBotAPI(token)
	if err != nil {
		return nil, fmt.Errorf("텔레그램 봇 생성 실패: %w", err)
	}

	ngrokAPI := "http://127.0.0.1:4040/api/tunnels"
	publicURL, err := getNgrokPublicURL(ngrokAPI)
	if err != nil {
		log.Printf("ngrok URL 조회 실패: %v", err)
		publicURL = os.Getenv("WEBHOOK_URL")
		if publicURL == "" {
			return nil, fmt.Errorf("웹훅 URL을 가져오지 못했습니다")
		}
	}

	webhookURL := fmt.Sprintf("%s/webhook", publicURL)
	log.Printf("웹훅 URL 설정: %s", webhookURL)

	webhook, err := tgbotapi.NewWebhook(webhookURL)
	if err != nil {
		return nil, fmt.Errorf("웹훅 생성 실패: %w", err)
	}

	_, err = bot.Request(webhook)
	if err != nil {
		return nil, fmt.Errorf("웹훅 등록 실패: %w", err)
	}

	log.Println("웹훅 등록 완료")

	return bot, nil
}

func generateCaptcha() (int, int, int) {
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b
	return a, b, answer
}

func sendVerificationChallenge(uid int64, chatID int64) {
	// 문제 생성 (예: 간단한 덧셈)
	a := rand.Intn(10) + 1
	b := rand.Intn(10) + 1
	answer := a + b

	// 유저별 정답 저장 (전역맵 또는 DB에 저장해야 함)
	verificationAnswers[uid] = answer

	msgText := "<b>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</b>\n" +
		"🔒 <b>PRIVATE ACCESS ONLY</b>\n\n" +
		"접근 권한이 없습니다.\n" +
		"아래 문제를 풀어 인증을 하세요.\n\n" +
		fmt.Sprintf("문제: <b>%d + %d = ?</b>\n\n", a, b) +
		"<b>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</b>"

	// 답변 버튼 3개 (정답 포함 랜덤 배치)
	options := generateAnswerOptions(answer)
	var buttons []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		data := fmt.Sprintf("verify_%d", opt)
		buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), data))
	}
	kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(buttons...))

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

func generateAnswerOptions(answer int) []int {
	var options []int
	options = append(options, answer)

	// 정답과 겹치지 않게 두 개의 오답 생성
	for len(options) < 3 {
		delta := rand.Intn(5) + 1 // 1~5 범위
		wrong := answer + delta
		if rand.Intn(2) == 0 {
			wrong = answer - delta
		}
		// 중복 방지
		exists := false
		for _, opt := range options {
			if opt == wrong {
				exists = true
				break
			}
		}
		if !exists && wrong >= 0 {
			options = append(options, wrong)
		}
	}

	// 랜덤 순서로 섞기
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	return options
}

func handleProductSelection(uid int64, chatID int64, messageID int, productCode string, category string) {
	product, ok := cardCategories[category][productCode]
	if !ok {
		sendTelegram(chatID, "❌ 해당 상품을 찾을 수 없습니다.")
		return
	}

	text := fmt.Sprintf(
		"<b>%s</b>\n가격: %.2f USDT\n설명: %s\n\n구매하시겠습니까?",
		product.Name, product.Price, product.Description,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("코인으로 구매", "pay_coin_"+product.Code),
			tgbotapi.NewInlineKeyboardButtonData("잔액으로 구매", "pay_balance_"+product.Code),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("취소", "go_main"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func handleVerificationResponse(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	log.Printf("[handleVerificationResponse] uid=%d, data=%s", uid, data)

	if !strings.HasPrefix(data, "verify_") {
		return
	}

	selectedStr := strings.TrimPrefix(data, "verify_")
	selected, err := strconv.Atoi(selectedStr)
	if err != nil {
		sendTelegram(uid, "❌ 잘못된 입력입니다.")
		return
	}

	correctAnswer, ok := verificationAnswers[uid]
	log.Printf("[Captcha] uid=%d, selected=%d, correctAnswer=%d, exists=%v", uid, selected, correctAnswer, ok)
	if !ok {
		sendTelegram(uid, "❌ 인증 세션이 만료되었거나 존재하지 않습니다. 다시 시도해주세요.")
		return
	}

	if selected == correctAnswer {
		// 인증 성공 처리
		markUserVerified(uid)
		delete(verificationAnswers, uid)

		delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
		if _, err := bot.Send(delMsg); err != nil {
			log.Printf("인증 메시지 삭제 실패: %v", err)
		}

		var user User
		if err := db.Where("user_id = ?", uid).First(&user).Error; err != nil {
			log.Printf("유저 정보 조회 실패: %v", err)
		}

		emoji := getGradeEmoji(user.Grade)
		displayName := user.UserName
		if displayName == "" {
			displayName = user.Nickname
		}
		if displayName == "" {
			displayName = "unknown"
		}

		fullMsg := fmt.Sprintf(
			`<b>━━━━━━━━━━━━━━━━</b>
		🔓 ✅ <b>Access Granted</b> ✅
		
		🆔 <b>고유번호</b> : %d
		👤 <b>유저네임</b> : %s
		⏰ : %s
		<b>등급</b> : %s %s
		<b>━━━━━━━━━━━━━━━━</b>`,
			user.UserID,
			displayName,
			user.LastSeen.Format("2006-01-02 15:04:05"),
			emoji,
			user.Grade,
		)

		isAdminUser := isAdmin(uid)
		var menu tgbotapi.InlineKeyboardMarkup
		if isAdminUser {
			menu = tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
					tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
					tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
					tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("👑 관리자메뉴", "admin_menu"),
				),
			)
		} else {
			menu = tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
					tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
					tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
					tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
				),
			)
		}

		msg1 := tgbotapi.NewMessage(chatID, fullMsg)
		msg1.ParseMode = "HTML"
		msg1.ReplyMarkup = menu
		bot.Send(msg1)

		replyKeyboard := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("내 정보"),
				tgbotapi.NewKeyboardButton("에너지"),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("주문내역"),
				tgbotapi.NewKeyboardButton("고객센터"),
			),
		)
		replyKeyboard.ResizeKeyboard = true
		msg2 := tgbotapi.NewMessage(chatID, "PING 🛜")
		msg2.ReplyMarkup = replyKeyboard
		bot.Send(msg2)

		bot.Request(tgbotapi.NewCallback(cb.ID, "인증 완료"))
	} else {
		// 인증 실패 처리
		failMsg := `<b>━━━━━━━━━━━━━━━━</b>
❌ <b>Verification Failed</b> ❌

선택한 답변이 올바르지 않습니다.
아래 문제를 다시 풀어 주세요.

지속될 경우 차단 될 수 있습니다.
<b>━━━━━━━━━━━━━━━━</b>
`
		sendTelegram(uid, failMsg)
		delete(verificationAnswers, uid)
		sendVerificationChallenge(uid, chatID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "인증 실패"))
	}
}

// 인증 상태 기록 함수 (메모리 + DB 동기화)
func markUserVerified(uid int64) {
	verifiedUsers[uid] = true

	// DB에도 저장 (필요한 경우)
	if err := db.Model(&User{}).
		Where("user_id = ?", uid).
		Update("verified", true).Error; err != nil {
		log.Printf("DB 인증 상태 업데이트 실패 (uid=%d): %v", uid, err)
	}
}

func saveStockWithImage(inputText, photoFileID string) error {
	lines := strings.Split(strings.TrimSpace(inputText), "\n")
	tx := db.Begin() // 트랜잭션 시작 (원자성 보장)

	for _, line := range lines {
		parts := strings.SplitN(line, ":", 3)
		if len(parts) != 3 {
			tx.Rollback()
			log.Printf("재고 입력 형식 오류, 롤백: %s", line)
			return fmt.Errorf("잘못된 입력 형식: %s", line)
		}
		category := strings.TrimSpace(parts[0])
		name := strings.TrimSpace(parts[1])
		codes := strings.Split(parts[2], ",")

		for _, code := range codes {
			code = strings.TrimSpace(code)
			if code == "" {
				continue
			}
			stockCard := StockCard{
				Category:    category,
				Name:        name,
				Content:     code,
				Used:        false,
				PhotoFileID: photoFileID,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}
			if err := tx.Create(&stockCard).Error; err != nil {
				tx.Rollback()
				log.Printf("DB 저장 오류, 롤백: %v", err)
				return fmt.Errorf("DB 오류: %w", err)
			}
		}
	}

	if err := tx.Commit().Error; err != nil {
		log.Printf("트랜잭션 커밋 실패: %v", err)
		return err
	}

	return nil
}

func getCardCategoriesFromDB() ([]CardCategory, error) {
	var categories []CardCategory
	err := db.Where("is_active = ?", true).Find(&categories).Error
	if err != nil {
		log.Println("[카테고리 로딩 실패]:", err)
		return nil, err
	}
	return categories, nil
}

func showProductMenu(category string, chatID int64, msgID int, products map[string]Product) {
	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	orderList, orderOk := productOrder[category]
	if !orderOk {
		// orderList가 없으면 products 맵 순회하며 버튼 생성
		for _, p := range products {
			if !p.Active {
				continue
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "prod_"+category+"_"+p.Code)
			currentRow = append(currentRow, btn)
			count++
			if count%2 == 0 {
				rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
				currentRow = []tgbotapi.InlineKeyboardButton{}
			}
		}
	} else {
		// orderList에 맞게 버튼 생성
		for _, name := range orderList {
			p, exists := products[name]
			if !exists || !p.Active {
				continue
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "prod_"+category+"_"+p.Code)
			currentRow = append(currentRow, btn)
			count++
			if count%2 == 0 {
				rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
				currentRow = []tgbotapi.InlineKeyboardButton{}
			}
		}
	}

	// 남은 버튼이 있으면 행 추가
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	// 뒤로가기 버튼 추가
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 뒤로가기", "go_catmenu"),
	))

	// 메시지 편집 요청 생성 및 전송
	edit := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf("📦 <b>%s</b> 상품 목록", category))
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
}

var lastMenuMessageID = make(map[int64]int)

func getAllMonitoringWallets() ([]MonitoringWallet, error) {
	var wallets []MonitoringWallet
	err := db.Table("monitoring_wallets").Find(&wallets).Error
	if err != nil {
		return nil, fmt.Errorf("모니터링 지갑 목록 조회 실패: %w", err)
	}
	return wallets, nil
}

func generateWalletAddress() (string, error) {
	bytes := make([]byte, 20)
	_, err := crand.Read(bytes)
	if err != nil {
		return "", err
	}
	return "T" + hex.EncodeToString(bytes), nil
}

func showAdminMenu(uid, chatID int64, messageID int) {
	// 시스템 상태 정보 가져오기
	status := getStatusReport()

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자 권한이 필요합니다.")
		return
	}

	text := "👑 관리자 님 환영합니다. 👑\n\n" + status

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 상품관리", "admin_inventory"),
			tgbotapi.NewInlineKeyboardButtonData("📆 주간통계", "weekly_stats"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🪪 회원목록", "admin_member_menu"),
			tgbotapi.NewInlineKeyboardButtonData("👥 방문자조회", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📊 통계보기", "admin_stats"),
			tgbotapi.NewInlineKeyboardButtonData("📋 주문내역", "admin_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⚙️ 설정", "showAdminSettings"),
			tgbotapi.NewInlineKeyboardButtonData("🔧 고급관리", "admin_advanced"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 메뉴 수정 실패: %v", err)
	}
}

func getStatusReport() string {
	now := time.Now().Format("2006-01-02 15:04:05")

	// DB 상태는 항상 OK로 가정 (dummy)
	dbOK := true

	// 더미값: 필요시 전역 변수/슬라이스에서 갯수 구하기
	orderCount := int64(1) // 미처리 주문 예시
	cardStock := int64(10) // 남은 재고 예시
	userCount := int64(5)  // 가입자 수 예시

	uptime := time.Since(startTime).Truncate(time.Second).String()

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return fmt.Sprintf(
		"<b>📊 BOT STATUS</b>\n⏰ 서버시간: %s\n🟢 DB상태: %s\n🛒 미처리: %d\n💳 재고: %d\n🙋 가입자: %d\n⏱ 업타임: %s\n💾 메모리: %.2fMB",
		now,
		map[bool]string{true: "OK", false: "오류"}[dbOK],
		orderCount,
		cardStock,
		userCount,
		uptime,
		float64(m.Alloc)/1024/1024,
	)
}

func initDB() (*gorm.DB, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		os.Getenv("MYSQL_USER"),
		os.Getenv("MYSQL_PASSWORD"),
		os.Getenv("MYSQL_HOST"),
		os.Getenv("MYSQL_PORT"),
		os.Getenv("MYSQL_DB"),
	)

	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Error),
	})
	if err != nil {
		return nil, fmt.Errorf("DB 연결 실패: %w", err)
	}
	log.Println("✅ DB 연결 성공")

	// 1. Category 테이블 먼저 마이그레이션
	if err := db.AutoMigrate(&Category{}); err != nil {
		return nil, fmt.Errorf("카테고리 마이그레이션 실패: %w", err)
	}

	// 2. 기본 카테고리 시딩 (예시)
	categories := []Category{
		{Name: "VPS", DisplayName: "VPS"},
		{Name: "ACCOUNT", DisplayName: "ACCOUNT"},
		{Name: "MEMBERSHIP", DisplayName: "MEMBERSHIP"},
		{Name: "ESIM", DisplayName: "ESIM"},
		{Name: "CARD", DisplayName: "CARD"},
	}
	for _, cat := range categories {
		var existing Category
		err := db.Where("name = ?", cat.Name).First(&existing).Error
		if err != nil {
			if err == gorm.ErrRecordNotFound {
				if err := db.Create(&cat).Error; err != nil {
					log.Printf("❌ 카테고리 등록 실패: %v", err)
				} else {
					log.Printf("✅ 카테고리 등록 완료: %s", cat.Name)
				}
			} else {
				log.Printf("❌ 카테고리 조회 실패: %v", err)
			}
		} else {
			log.Printf("ℹ️ 카테고리 이미 존재: %s", cat.Name)
		}
	}

	// 3. Product 테이블 마이그레이션
	if err := db.AutoMigrate(&Product{}); err != nil {
		return nil, fmt.Errorf("상품 마이그레이션 실패: %w", err)
	}
	log.Println("✅ DB 마이그레이션 완료")

	return db, nil
}

func getAdminChatID() int64 {
	return adminChatID
}

func handleWebhook(c *gin.Context) {
	var update tgbotapi.Update

	// 1. JSON 바인딩 시도
	if err := c.ShouldBindJSON(&update); err != nil {
		log.Printf("웹훅 JSON 바인딩 실패: %v", err)
		c.JSON(400, gin.H{"status": "bad request"})
		return
	}

	// 2. 바인딩 성공 시 로그 출력 및 처리
	log.Printf("[handleWebhook] update: %+v", update)
	processUpdate(update)

	// 3. 처리 완료 응답
	c.JSON(200, gin.H{"status": "ok"})
}

func seedCategories(db *gorm.DB) error {
	categories := []Category{
		{Name: "VPS", DisplayName: "VPS"},
		{Name: "ACCOUNT", DisplayName: "ACCOUNT"},
		{Name: "MEMBERSHIP", DisplayName: "MEMBERSHIP"},
		{Name: "ESIM", DisplayName: "ESIM"},
		{Name: "CARD", DisplayName: "CARD"},
	}

	for _, cat := range categories {
		var existing Category
		err := db.Where("name = ?", cat.Name).First(&existing).Error
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				if err := db.Create(&cat).Error; err != nil {
					log.Printf("❌ 카테고리 등록 실패: %v", err)
				} else {
					log.Printf("✅ 카테고리 등록 완료: %s", cat.Name)
				}
			} else {
				log.Printf("❌ 카테고리 조회 실패: %v", err)
			}
		} else {
			log.Printf("ℹ️ 카테고리 이미 존재: %s", cat.Name)
		}
	}

	return nil
}

func setWebhook(bot *tgbotapi.BotAPI, url string) error {
	webhookConfig, err := tgbotapi.NewWebhook(url)
	if err != nil {
		return err
	}
	_, err = bot.Request(webhookConfig)
	return err
}

func initBot() {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	var err error
	bot, err = tgbotapi.NewBotAPI(token)
	if err != nil {
		log.Fatalf("❌ 텔레그램 봇 생성 실패: %v", err)
	}
	log.Printf("🤖 봇 시작됨: @%s", bot.Self.UserName)

	webhookURL := os.Getenv("WEBHOOK_URL")
	if webhookURL != "" {
		if err := setWebhook(bot, webhookURL); err != nil {
			log.Fatalf("❌ 웹훅 설정 실패: %v", err)
		}
		log.Printf("✅ 웹훅 설정 완료: %s", webhookURL)
	} else {
		log.Println("⚠️ WEBHOOK_URL 환경변수가 설정되지 않아 웹훅 설정하지 않음")
	}
}

func migrateDB(db *gorm.DB) error {
	if err := db.AutoMigrate(&Category{}); err != nil {
		return fmt.Errorf("카테고리 마이그레이션 실패: %w", err)
	}

	if err := seedCategories(db); err != nil {
		return fmt.Errorf("카테고리 시딩 실패: %w", err)
	}

	if err := db.AutoMigrate(&Product{}); err != nil {
		return fmt.Errorf("상품 마이그레이션 실패: %w", err)
	}

	// MonitoringWallet 테이블 추가 마이그레이션
	if err := db.AutoMigrate(&MonitoringWallet{}); err != nil {
		return fmt.Errorf("모니터링 지갑 마이그레이션 실패: %w", err)
	}

	return nil
}

func relaySupportMessage(fromUserID int64, text string) {
	// fromUserID가 상담원인지 유저인지 구분
	// 상담원이라면 유저에게 메시지 전달
	// 유저라면 상담원에게 메시지 전달

	var toUserID int64
	var isSupporter bool = false

	// 상담원일 경우
	for userID, adminID := range activeSupportSessions {
		if adminID == fromUserID {
			toUserID = userID
			isSupporter = true
			break
		}
	}
	if !isSupporter {
		// fromUserID가 유저일 경우
		toUserID = activeSupportSessions[fromUserID]
	}

	if toUserID == 0 {
		// 상담 세션이 없으면 무시하거나 안내 메시지 전송
		return
	}

	// 메시지 전송
	msg := tgbotapi.NewMessage(toUserID, text)
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("상담 메시지 중계 실패: %v", err)
	}
}

func processUpdate(update tgbotapi.Update) {
	if update.CallbackQuery != nil {
		handleCallback(update.CallbackQuery) // 기존 handleCallbackQuery 대신 handleCallback 호출
	} else if update.Message != nil {
		handleMessage(update.Message)
	} else {
		log.Printf("처리하지 않는 업데이트 타입: %+v", update)
	}
}

func sendReplyKeyboard(uid, chatID int64) error {
	// 이전 리플라이 키보드 메시지 삭제 (있으면)
	if msgID, ok := userReplyKeyboardMsgID[uid]; ok && msgID != 0 {
		delMsg := tgbotapi.DeleteMessageConfig{
			ChatID:    chatID,
			MessageID: msgID,
		}
		if _, err := bot.Request(delMsg); err != nil {
			log.Printf("리플라이 키보드 이전 메시지 삭제 실패: %v", err)
		}
	}

	// 새 리플라이 키보드 메시지 전송
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("내 정보"),
			tgbotapi.NewKeyboardButton("에너지"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("주문내역"),
			tgbotapi.NewKeyboardButton("고객센터"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	msg := tgbotapi.NewMessage(chatID, "PING 🛜") // 빈 텍스트
	msg.ReplyMarkup = replyKeyboard

	sentMsg, err := bot.Send(msg)
	if err != nil {
		return err
	}

	userReplyKeyboardMsgID[uid] = sentMsg.MessageID
	return nil
}

func showMenu(uid int64, username string, chatID int64) {
	if username == "" {
		username = "unknown"
	}

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	introMsg := fmt.Sprintf(
		`<b>━━━━━━━━━━━━━━━━</b>
🆔 <b>고유번호</b> : %d
👤 <b>유저네임</b> : %s
⏰ : %s
<b>등급</b> : %s
<b>━━━━━━━━━━━━━━━━</b>`,
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	if isAdmin(uid) {
		introMsg += "\n<b>권한: 관리자</b>\n"
	}

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdmin(uid) {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("👑 관리자메뉴", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("showMenu 인트로 메시지 전송 실패: %v", err)
	}

	if err := sendReplyKeyboard(uid, chatID); err != nil {
		log.Printf("showMenu 리플라이 키보드 전송 실패: %v", err)
	}
}

// 잔액 조회 함수
func handleBalanceCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	var userBal UserBalance
	err := db.Where("user_id = ?", uid).First(&userBal).Error
	balance := 0.0
	if err == nil {
		balance = userBal.Balance
	}
	reply := fmt.Sprintf(
		"👤 : <code>%d</code>\n\n💰 잔액 : %.3f USDT\n\n입금은 /입금 안내 메뉴를 참고하세요.",
		uid, balance,
	)
	sendTelegram(uid, reply)
}

func RoundFloat(val float64, precision int) float64 {
	ratio := math.Pow(10, float64(precision))
	return math.Round(val*ratio) / ratio
}

func showVPSMenu(uid, chatID int64, msgID int) {
	var vpsCat CardCategory
	err := db.Where("name = ?", "vps").First(&vpsCat).Error
	if err != nil {
		sendTelegram(chatID, "❌ VPS 카테고리를 찾을 수 없습니다.")
		log.Printf("❌ VPS 카테고리 로딩 실패: %v", err)
		return
	}

	var products []CardProduct
	err = db.Where("category_id = ? AND is_active = ?", vpsCat.ID, true).Find(&products).Error
	if err != nil || len(products) == 0 {
		sendTelegram(chatID, "❌ VPS 상품이 없습니다.")
		log.Printf("❌ VPS 상품 로딩 실패: %v", err)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "order_"+p.Name)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
	))

	msgText := "🖥️ <b>VPS / 가상서버 상품 목록</b>\n\n구매하실 상품을 선택해주세요."
	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showVPSMenu 메시지 전송 실패: %v", err)
	}
}

func showLanguageMenu(uid int64, chatID int64, msgID int) {
	text := "🌐 언어를 선택하세요 / Select Language"
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🇰🇷", "lang_ko"),
			tgbotapi.NewInlineKeyboardButtonData("🇺🇸", "lang_en"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🇨🇳", "lang_zh"),
			tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main"),
		),
	)

	if msgID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("showLanguageMenu 메시지 전송 실패: %v", err)
		}
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showLanguageMenu 메시지 편집 실패: %v", err)
		}
	}
}

func handleLanguageSelection(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID

	var selectedLang string

	switch cb.Data {
	case "lang_ko":
		selectedLang = "ko"
	case "lang_en":
		selectedLang = "en"
	case "lang_zh":
		selectedLang = "zh"
	case "go_main":
		// 기존 메시지 삭제
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(cb.Message.Chat.ID, cb.Message.MessageID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("[go_main] 기존 메시지 삭제 실패: %v", err)
			}
		}
		// 새 메뉴 출력 (showMenu 함수는 사용자 ID, username, chatID를 인자로 받는다고 가정)
		showMenu(uid, cb.From.UserName, chatID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
		return
	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "알 수 없는 명령어입니다."))
		return
	}

	// 언어 저장
	setUserLanguage(uid, selectedLang)

	// 콜백 응답 및 메뉴 다시 표시
	bot.Request(tgbotapi.NewCallback(cb.ID, "🌐 언어가 설정되었습니다."))
	showMenu(uid, cb.From.UserName, chatID)
}

func setUserLanguage(uid int64, lang string) {
	// DB에 언어 저장 로직 (예: gorm 사용)
	if err := db.Model(&User{}).Where("user_id = ?", uid).Update("lang", lang).Error; err != nil {
		log.Printf("[setUserLanguage] 언어 저장 실패 uid=%d, lang=%s, err=%v", uid, lang, err)
	}
}

func setUserLang(uid int64, lang string) error {
	// 예시: 유저 테이블이 있고 lang 필드가 있다면
	err := db.Model(&User{}).Where("user_id = ?", uid).Update("lang", lang).Error
	return err
}

func showSupportMenu(chatID int64) {
	msgText := " 👤 고객센터 메뉴입니다.\n\n 문의 버튼을 누른후 대기 해주세요."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("실시간 문의", "support_request"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main"),
		),
	)

	photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.ch.jpeg"))
	photo.Caption = msgText
	photo.ReplyMarkup = kb

	if _, err := bot.Send(photo); err != nil {
		log.Printf("고객센터 메뉴(이미지) 전송 실패: %v", err)
	}
}

func getUserWallet(uid int64) string {
	var wallet UserWallet
	if err := db.Where("user_id = ?", uid).First(&wallet).Error; err != nil {
		log.Printf("[지갑조회] uid: %d → 조회 실패: %v", uid, err)
		return ""
	}
	log.Printf("[지갑조회] uid: %d → 지갑주소: %s", uid, wallet.Address)
	return wallet.Address
}

func isDepositProcessed(txID string) bool {
	processedTxsMu.RLock()
	processed, exists := processedTxs[txID]
	processedTxsMu.RUnlock()

	if exists && processed {
		return true
	}

	// 메모리에 없으면 DB 확인 (드물게만 발생)
	var count int64
	if err := db.Model(&ProcessedDeposit{}).Where("tx_id = ?", txID).Count(&count).Error; err != nil {
		log.Printf("DB 조회 실패: %v", err)
		return false // DB 오류 시 안전하게 false 리턴
	}
	if count > 0 {
		// DB에 있으면 메모리 캐시에도 추가
		processedTxsMu.Lock()
		processedTxs[txID] = true
		processedTxsMu.Unlock()
		return true
	}
	return false
}

func markDepositProcessed(txID string) {
	processedTxsMu.Lock()
	processedTxs[txID] = true
	processedTxsMu.Unlock()

	// DB에 기록
	rec := ProcessedDeposit{TxID: txID}
	if err := db.Create(&rec).Error; err != nil {
		// 중복 삽입 등 에러 로그만 기록
		log.Printf("DB 저장 실패 (중복 가능): %v", err)
	}
}

// 방문자 기본 정보 리스트 조회 (User 타입)
func getUserListByPage(page, pageSize int) ([]User, error) {
	offset := (page - 1) * pageSize
	var users []User
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

// 2. 방문자 리스트 메시지 HTML 포맷팅
func formatUserListMessage(users []User, page, totalPages int) string {
	const pageSize = 10
	if len(users) == 0 {
		return "<b>조회 결과가 없습니다.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(없음)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}
		lastSeen := "(알 수 없음)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\n최근 접속: %s\n━━━━━━━━━━━━━━\n",
			(i+1)+(page-1)*pageSize, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

// 3. 방문자 리스트 페이지 표시 함수
func showUserListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, err := getUserListByPage(page, pageSize)
	if err != nil {
		sendTelegram(uid, "❌ 방문자 목록을 불러오는 중 오류가 발생했습니다.")
		return
	}

	var total int64
	err = db.Model(&User{}).Count(&total).Error
	if err != nil {
		sendTelegram(uid, "❌ 총 방문자 수 조회 중 오류가 발생했습니다.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

// 5. 콜백 처리 예시 (handleCallback 내부 또는 별도 함수로)
func handleVisitorCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	switch {
	case strings.HasPrefix(data, "visitor_page_"):
		pageStr := strings.TrimPrefix(data, "visitor_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("페이지 %d 로 이동", page)))

	case data == "admin_visitor_menu":
		// 관리자 방문자 메뉴 다시 보여주기 (구현에 따라 다름)
		showAdminVisitorMenu(chatID, msgID, cb.ID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 방문자 메뉴"))

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "알 수 없는 명령어"))
	}
}

func getCategoryIDByName(name string) (uint, error) {
	var cat Category
	// LOWER()를 써서 대소문자 구분 없이 조회
	if err := db.Where("LOWER(name) = LOWER(?)", name).First(&cat).Error; err != nil {
		return 0, err
	}
	return cat.ID, nil
}

func getGradeEmoji(grade string) string {
	switch strings.ToLower(grade) {
	case "bronze":
		return "🥉"
	case "silver":
		return "🥈"
	case "gold":
		return "🥇"
	case "diamond":
		return "💎"
	case "vip":
		return "👑"
	case "":
		return "❔" // 등급이 빈 문자열인 경우
	default:
		return "🥉"
	}
}

// showEnergyMenu 함수 수정본
func showEnergyMenu(uid int64, chatID int64, messageID int) {
	msgText := `<b>🪫 USDT 송금 수수료 80% 절감</b>

2.5 TRX →  65K 에너지  = 1회 송금
5.0 TRX → 130k에너지  = 2회 송금

⬇️ <b>결제 주소</b> ⬇️
<b>━━━━━━━━━━━━━━━━</b>
<code>TDFfED6MK7hj6a9GXJMG3emXdd3b6XtHPn</code>
<b>━━━━━━━━━━━━━━━━</b>
⬆️<b> 주소 클릭 시 자동 복사</b> ⬆️

⏱ 전송후 10초 이내 에너지 충전
이체하실 지갑에 USDT 부족시 130k
송금 전 수수료 금액 확인 후 전송`

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageCaption(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showEnergyMenu 메시지 편집 실패: %v, 새 메시지로 대체 전송 시도", err)
			// 편집 실패 시 새 메시지 전송
			photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.trx.jpeg"))
			photoMsg.Caption = msgText
			photoMsg.ParseMode = "HTML"
			photoMsg.ReplyMarkup = kb
			if _, err := bot.Send(photoMsg); err != nil {
				log.Printf("showEnergyMenu 사진+메시지 전송 실패: %v", err)
			}
		}
	} else {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("/home/minho/epusdt/images/energy_image.jpeg"))
		photoMsg.Caption = msgText
		photoMsg.ParseMode = "HTML"
		photoMsg.ReplyMarkup = kb

		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("showEnergyMenu 사진+메시지 전송 실패: %v", err)
		}
	}
}

func getUserDisplayName(uid int64) string {
	var user User
	if err := db.Where("user_id = ?", uid).First(&user).Error; err != nil {
		return "알 수 없음"
	}
	if user.Nickname != "" {
		return user.Nickname
	}
	if user.UserName != "" {
		return "@" + user.UserName
	}
	return "알 수 없음"
}

func saveUserWallet(userID int64, wallet, username string) error {
	var wm WalletMap
	err := db.Where("user_id = ?", userID).First(&wm).Error

	if err == nil {
		// 기존 사용자 → 업데이트
		wm.Wallet = wallet
		wm.Username = username
		if err = db.Save(&wm).Error; err != nil {
			log.Printf("❌ saveUserWallet: 저장 실패 userID=%d → %v", userID, err)
			return err
		}
		log.Printf("✅ saveUserWallet: 기존 지갑 갱신 userID=%d", userID)
		return nil
	}

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// 신규 사용자 → 생성
		wm = WalletMap{
			UserID:   userID,
			Wallet:   wallet,
			Username: username,
		}
		if err := db.Create(&wm).Error; err != nil {
			log.Printf("❌ saveUserWallet: DB 생성 실패 userID=%d → %v", userID, err)
			return err
		}
		log.Printf("✅ saveUserWallet: 새 지갑 등록 userID=%d", userID)
		return nil
	}

	// 예외 케이스: 조회 실패
	log.Printf("❌ saveUserWallet: DB 조회 실패 userID=%d → %v", userID, err)
	return err
}

func createDepositOrder(userID int64, amount float64) error {
	prodName := "USDT 충전"
	price := amount

	order := Order{
		UserID:      userID,
		Product:     prodName,
		Amount:      price,
		Status:      "입금대기중",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
	}

	if err := db.Create(&order).Error; err != nil {
		return err
	}

	addr := os.Getenv("COIN_PAYMENT_ADDR")
	qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
	_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

	msgText := fmt.Sprintf(
		"💸 <b>충전 주문이 생성되었습니다!</b>\n\n"+
			"아래 주소로 <b>정확히 <code>%.3f USDT</code></b>를 입금해 주세요.\n\n"+
			"• 주문번호: <code>%d</code>\n"+
			"• 입금주소: <code>%s</code>\n"+
			"• 결제금액: <b>%.3f USDT</b>\n\n"+
			"(QR코드로 송금 가능, 소수점까지 정확히!)",
		amount, order.ID, addr, amount,
	)

	msg := tgbotapi.NewMessage(userID, msgText)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	photo := tgbotapi.NewPhoto(userID, tgbotapi.FilePath(qrPath))
	photo.Caption = "QR코드를 사용하면 금액이 자동 지정됩니다."
	photo.ParseMode = "HTML"
	bot.Send(photo)

	return nil
}

func showDepositConfirm(uid, chatID int64, msgID int, amount float64) {
	amountStr := fmt.Sprintf("%.3f", amount)
	encodedAmount := base64.StdEncoding.EncodeToString([]byte(amountStr))
	callbackData := "confirm_deposit_" + encodedAmount

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✅ 확인", callbackData),
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "show_deposit_menu"),
		),
	)
	text := fmt.Sprintf("💸 <b>%.3f USDT</b> 충전하시겠습니까?", amount)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("메시지 전송 실패: %v", err)
	}
}

// 입금 주소 및 QR코드 안내
func showDepositAddress(uid, chatID int64, messageID int, amount float64) {
	addr, err := getWalletAddress(uid)
	if err != nil || addr == "" {
		sendTelegram(chatID, "❗️ 입금 지갑이 등록되어 있지 않습니다.\n\n먼저 <b>/입금지갑등록 [지갑주소]</b> 명령어로 등록해 주세요.")
		return
	}

	var username string
	if err := db.Model(&User{}).Select("username").Where("user_id = ?", uid).Take(&username).Error; err != nil {
		username = "-"
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf(
			"🆔 <b>고유번호</b>: <code>%d</code>\n"+
				"👤 <b>유저네임</b>: %s\n\n"+
				"💲 <b>입금 안내</b>\n"+
				"입금 주소: <code>%s</code>\n"+
				"입금 금액: <b>%.3f USDT</b>\n\n"+
				"입금 완료 후, 자동으로 잔액이 충전됩니다.",
			uid, username, addr, amount,
		),
	)
	editMsg.ParseMode = "HTML"

	if _, err = bot.Send(editMsg); err != nil {
		log.Printf("메시지 편집 실패: %v", err)
	}

	qrFilename := fmt.Sprintf("./qrcodes/wallet_%d_%d.png", uid, time.Now().UnixNano())
	qrData := fmt.Sprintf("%s?amount=%.3f", addr, amount)

	if err := generateWalletQRCode(qrData, qrFilename); err == nil {
		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrFilename))
		photo.Caption = fmt.Sprintf(
			"💳 <b>입금주소 QR</b> (%.3f USDT)\n\n<code>%s</code>",
			amount, addr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("showDepositAddress: QR코드 이미지 전송 실패 chatID=%d err=%v", chatID, err)
		}
	} else {
		log.Printf("showDepositAddress: QR 생성 실패 err=%v", err)
	}
}

// 관리자 재고 상세 목록 표시 함수 예시
func showAdminStockList(chatID int64, messageID int) {
	// TODO: DB에서 재고 목록 조회 후 텔레그램 메시지 또는 메시지 편집으로 출력
	msgText := "📋 재고 상세 목록 (예시)\n- 상품A: 10개\n- 상품B: 5개\n- 상품C: 0개\n"
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("재고 상세 목록 출력 실패: %v", err)
	}
}

// 관리자 재고 삭제 안내 함수 예시
func promptStockDeletion(chatID int64) {
	msgText := "🗑️ 재고 삭제 기능을 사용합니다.\n삭제할 재고 항목 코드를 입력해 주세요."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("재고 삭제 안내 메시지 전송 실패: %v", err)
	}
}

// 관리자 재고 추가 안내 함수 예시
func promptStockAddition(chatID int64) {
	msgText := "➕ 재고 추가 기능을 사용합니다.\n추가할 재고 항목 정보를 입력해 주세요."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("재고 추가 안내 메시지 전송 실패: %v", err)
	}
}

// 관리자 메인 메뉴 함수 예시
func showAdminMainMenu(chatID int64, messageID int) {
	msgText := "👑 관리자 메인 메뉴입니다."
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 메인 메뉴 출력 실패: %v", err)
	}
}

// 콜백 처리 예시
func handleDepositCallbacks(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	if strings.HasPrefix(data, "confirm_deposit_") {
		encodedAmount := strings.TrimPrefix(data, "confirm_deposit_")
		decodedBytes, err := base64.StdEncoding.DecodeString(encodedAmount)
		if err != nil {
			sendTelegram(uid, "❌ 충전 금액 확인에 실패했습니다.")
			return
		}
		amountStr := string(decodedBytes)
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(uid, "❌ 충전 금액 파싱에 실패했습니다.")
			return
		}

		err = createDepositOrder(uid, amount) // DB에 주문 생성 함수
		if err != nil {
			sendTelegram(uid, "❌ 충전 주문 생성에 실패했습니다.")
			return
		}

		sendTelegram(uid, fmt.Sprintf("✅ %.3f USDT 충전 주문이 생성되었습니다.", amount))
		bot.Request(tgbotapi.NewCallback(cb.ID, "충전 주문이 생성되었습니다."))
		return
	}

	if strings.HasPrefix(data, "deposit_") {
		amountStr := strings.TrimPrefix(data, "deposit_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(uid, "❌ 입금 금액이 잘못되었습니다.")
			return
		}

		showDepositAddress(uid, chatID, msgID, amount) // 입금 주소 보여주는 함수
		bot.Request(tgbotapi.NewCallback(cb.ID, "입금 안내를 표시합니다."))
		return
	}
}

// 관리자 재고 메뉴 표시
func showAdminStockMenuSimple(chatID int64, messageID int) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		{tgbotapi.NewInlineKeyboardButtonData("📋 상세 보기", "admin_stock_list")},
		{tgbotapi.NewInlineKeyboardButtonData("🗑️ 재고 삭제", "admin_stock_delete")},
		{tgbotapi.NewInlineKeyboardButtonData("➕ 재고 추가", "admin_stock")},
		{tgbotapi.NewInlineKeyboardButtonData("📦 재고 관리", "admin_stock_menu")}, // <- 배열로 묶음
		{tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu")},
	}

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, "관리자님 환영합니다.")
		edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
		if _, err := bot.Send(edit); err != nil {
			log.Printf("관리자 재고 메뉴 수정 실패: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, "관리자님 환영합니다.")
		msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(rows...)
		if _, err := bot.Send(msg); err != nil {
			log.Printf("메시지 전송 실패: %v", err)
		}
	}
}

func handleAdminStockMenuCallbacks(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	// 관리자 권한 체크
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 이용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	switch {
	case data == "admin_stock_list":
		showAdminStockList(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 목록 표시"))
		return

	case data == "admin_stock_delete":
		promptStockDeletion(chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 삭제 안내"))
		return

	case data == "admin_stock_add":
		promptStockAddition(chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 추가 안내"))
		return

	case data == "admin_main_menu":
		showAdminMainMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 메인 메뉴 표시"))
		return

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "알 수 없는 명령어"))
		return
	}
}

func buildProductButtons(products []Product) [][]tgbotapi.InlineKeyboardButton {
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		rows = append(rows,
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("➕ 재고", fmt.Sprintf("admin_add_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("ℹ️ 상세", fmt.Sprintf("admin_stock_detail_%d", p.ID)),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("✏️ 수정", fmt.Sprintf("admin_edit_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("🗑 삭제", fmt.Sprintf("admin_del_stock_%d", p.ID)),
			),
		)
	}
	return rows
}

func showAdminVisitorMenu(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📅 당일 방문자", "admin_list_visitors_today"),
			tgbotapi.NewInlineKeyboardButtonData("📆 전체 방문자", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "👥 방문자 조회 메뉴")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 메뉴 수정 실패: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "메뉴 수정 실패")); callbackErr != nil {
			log.Printf("Callback 응답 실패: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback 응답 실패: %v", err)
	}
}

// 새로운 방식의 일일 매출 통계 조회
func getDailyStatsNew() (SalesStats, error) {
	today := time.Now().Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func createUserActivityKeyboard(page, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	var navButtons []tgbotapi.InlineKeyboardButton

	// 이전 페이지 버튼 (첫 페이지가 아닐 경우에만 표시)
	if page > 1 {
		navButtons = append(navButtons, tgbotapi.NewInlineKeyboardButtonData("⬅️", fmt.Sprintf("visitors_page_%d", page-1)))
	}
	// 다음 페이지 버튼 (마지막 페이지가 아닐 경우에만 표시)
	if page < totalPages {
		navButtons = append(navButtons, tgbotapi.NewInlineKeyboardButtonData("➡️", fmt.Sprintf("visitors_page_%d", page+1)))
	}

	// 이전/다음 버튼이 있다면 한 줄로 추가
	if len(navButtons) > 0 {
		rows = append(rows, navButtons)
	}

	// 항상 뒤로가기 버튼 추가 (새 행으로)
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
	))

	// 인라인 키보드 마크업 생성
	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

// .env 파일에 ngrok 및 관련 URL 자동 업데이트
func updateEnvNgrokURL(envPath, newURL string) error {
	data, err := os.ReadFile(envPath)
	if err != nil {
		return err
	}

	lines := strings.Split(string(data), "\n")
	updates := map[string]string{
		"NGROK_URL":         "NGROK_URL=" + newURL,
		"WEBHOOK_URL":       "WEBHOOK_URL=" + newURL + "/webhook",
		"EPUSDT_API_URL":    "EPUSDT_API_URL=" + newURL + "/api/notify/set",
		"EPUSDT_NOTIFY_URL": "EPUSDT_NOTIFY_URL=" + newURL + "/epusdt_notify",
	}

	keysUpdated := make(map[string]bool)
	var newLines []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			newLines = append(newLines, line)
			continue
		}
		parts := strings.SplitN(trimmed, "=", 2)
		key := parts[0]
		if val, ok := updates[key]; ok && !keysUpdated[key] {
			newLines = append(newLines, val)
			keysUpdated[key] = true
		} else {
			newLines = append(newLines, line)
		}
	}

	// 새로 추가할 키들 추가
	for key, val := range updates {
		if !keysUpdated[key] {
			newLines = append(newLines, val)
		}
	}

	output := strings.Join(newLines, "\n") + "\n"
	return os.WriteFile(envPath, []byte(output), 0644)
}

func answerCallbackQuery(callbackID, text string) {
	callback := tgbotapi.NewCallback(callbackID, text)
	if _, err := bot.Request(callback); err != nil {
		log.Printf("CallbackQuery 응답 실패: %v", err)
	}
}

func processTronTransaction(tx TronTransaction) {
	// 1. processedTxs 맵에 TXID 중복 여부 체크 (뮤텍스 동기화)
	processedTxsMu.Lock()
	if processedTxs[tx.TxID] {
		processedTxsMu.Unlock()
		return // 이미 처리된 트랜잭션이면 무시
	}
	processedTxs[tx.TxID] = true
	processedTxsMu.Unlock()

	// 2. DB에서 TXID 중복 조회 (중복 처리 방지)
	var existing Order
	if err := db.Where("tx_id = ?", tx.TxID).First(&existing).Error; err == nil {
		return // 이미 등록된 주문이면 무시
	}

	// 3. 입금 금액 파싱
	amount, err := strconv.ParseFloat(tx.AmountStr, 64)
	if err != nil {
		log.Printf("[트론그리드] 입금액 파싱 실패 txid=%s, value=%s", tx.TxID, tx.AmountStr)
		return
	}

	// 4. DB에서 입금대기중 상태이고 정확한 금액 또는 근접 금액 주문 조회
	var order Order
	err = db.Where("expected_amt = ? AND status = ?", amount, "입금대기중").First(&order).Error
	if err != nil {
		err = db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.001, amount+0.001, "입금대기중").First(&order).Error
	}
	if err != nil {
		log.Printf("[트론그리드] 매칭되는 주문 없음: amount=%.3f", amount)
		createUnmatchedOrder(amount, tx) // 미매칭 주문 별도 처리
		return
	}

	// 5. 주문에 TXID 등록 및 DB 저장
	setOrderTxID(&order, tx.TxID)
	if err := db.Save(&order).Error; err != nil {
		log.Printf("[트론그리드] 주문 상태 업데이트 실패: %v", err)
		return
	}

	// 6. 잔액충전 상품인 경우 잔액만 충전하고 종료
	if order.Product == "잔액충전" {
		if err := addUserBalance(order.UserID, order.Amount); err != nil {
			sendTelegram(order.UserID, "❌ 잔액 충전 실패! 관리자에게 문의하세요.")
			log.Printf("[잔액충전] 오류: %v", err)
		} else {
			sendTelegram(order.UserID, fmt.Sprintf("✅ %.3f USDT 잔액이 충전되었습니다!", order.Amount))
		}
		return
	}

	// 7. 사용자에게 입금 확인 메시지 발송
	userMsg := fmt.Sprintf(
		"🟢 *입금 확인 완료!*\n\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"📋 주문번호: #%d\n"+
			"📦 상품명: %s\n"+
			"💰 입금금액: %.3f USDT\n"+
			"🔗 트랜잭션: `%s`\n"+
			"⏰ 확인시간: %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"✅ 주문이 성공적으로 처리되었습니다!\n"+
			"🚀 상품이 곧 자동으로 지급됩니다.",
		order.ID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	msg := tgbotapi.NewMessage(order.UserID, userMsg)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	// 8. 관리자에게 입금 확인 로그 전송
	adminMsg := fmt.Sprintf(
		"🟢 *입금 확인 (매칭됨)*\n\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"📋 주문번호: #%d\n"+
			"👤 유저네임: %d\n"+
			"📦 상품: %s\n"+
			"💰 금액: %.3f USDT\n"+
			"🔗 TxID: `%s`\n"+
			"⏰ 시간: %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"✅ 자동 카드 지급 처리 중...",
		order.ID, order.UserID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	adminMsgObj := tgbotapi.NewMessage(unmatchedAdminChatID, adminMsg)
	adminMsgObj.ParseMode = "HTML"
	bot.Send(adminMsgObj)

	// 9. 자동 카드 지급 처리 비동기 실행
	go func(orderID uint, userID int64, txID string) {
		if err := processOrderWithValidation(orderID, txID); err != nil {
			log.Printf("[자동지급] 실패 orderID=%d, err=%v", orderID, err)
			msg := tgbotapi.NewMessage(userID, "❌ 지급 중 오류가 발생했습니다. 고객센터로 문의하세요.")
			bot.Send(msg)
		}
	}(order.ID, order.UserID, tx.TxID)
}

// TxID 설정 보조 함수 (sql.NullString 타입에 대응)
func setOrderTxID(order *Order, txID string) {
	order.TxID = &txID // ✅ string 값만 할당
}

func toFixed3(f float64) float64 {
	return math.Floor(f*1000) / 1000
}

func notifySend(chatID int64, msg string) {
	sendTelegram(chatID, msg)
	// sendTelegram이 에러를 반환하지 않으므로 에러 체크 불가
}
func showUserStats(chatID int64, msgID int) {
	count, err := getUserCount()
	if err != nil {
		sendTelegram(chatID, "유저 카운트 조회 실패")
		return
	}
	text := fmt.Sprintf("전체 가입 유저 수: %d명", count)
	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	bot.Send(msg)
}

func getUsersByPageFromAllUsers(page, pageSize int) ([]User, error) {
	allUsers, err := getAllUsers()
	if err != nil {
		return nil, err
	}

	start := (page - 1) * pageSize
	if start >= len(allUsers) {
		return []User{}, nil
	}

	end := start + pageSize
	if end > len(allUsers) {
		end = len(allUsers)
	}

	return allUsers[start:end], nil
}

// 한 번에 10명씩, 페이지네이션 지원
func getAllUsers() ([]User, error) {
	var users []User
	if err := db.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

func getUserCount() (int64, error) {
	var count int64
	err := db.Model(&User{}).Count(&count).Error
	return count, err
}

func showAdminAllUsersMenu(chatID int64, messageID int, page int) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}

	users, err := getUsersByPageFromAllUsers(page, pageSize)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 전체 유저 목록 조회 실패")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 더 이상 조회할 유저가 없습니다.")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("👥 전체 유저 (Page %d)\n\n", page)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(닉네임없음)"
		}
		username := user.UserName
		if username == "" {
			username = "없음"
		}
		text += fmt.Sprintf("%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1+(page-1)*pageSize, nickname, user.UserID, username, user.LastSeen.Format("01-02 15:04"))

		btn := tgbotapi.NewInlineKeyboardButtonData(
			nickname,
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// 페이지네이션 버튼
	var navigation []tgbotapi.InlineKeyboardButton
	if page > 1 {
		navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("⬅️ ", fmt.Sprintf("admin_all_users_page_%d", page-1)))
	}
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"))
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("➡️ ", fmt.Sprintf("admin_all_users_page_%d", page+1)))

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(navigation...))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Request(msg)
}

func showAdminCategoryMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	var rows [][]tgbotapi.InlineKeyboardButton

	// 2개씩 버튼을 묶어 한 행(row)에 추가
	for i := 0; i < len(categories); i += 2 {
		end := i + 2
		if end > len(categories) {
			end = len(categories)
		}
		var row []tgbotapi.InlineKeyboardButton
		for _, cat := range categories[i:end] {
			var callbackData string
			if cat == "VPS" {
				callbackData = "menu_vps" // VPS는 별도 메뉴로 연결
			} else {
				callbackData = "admin_cat_" + cat
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(cat, callbackData)
			row = append(row, btn)
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// 뒤로가기 버튼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "📂상품수정 카테고리 선택")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func addProductsByCategory(db *gorm.DB, productsByCategory map[string][]Product) error {
	for categoryName, products := range productsByCategory {
		catID, err := getCategoryIDByName(categoryName)
		if err != nil {
			log.Printf("❌ [%s] 카테고리 ID 조회 실패: %v", categoryName, err)
			continue
		}
		for _, p := range products {
			p.CategoryID = catID
			var existing Product
			err := db.Where("code = ?", p.Code).First(&existing).Error
			if err != nil {
				if err == gorm.ErrRecordNotFound {
					if err := db.Create(&p).Error; err != nil {
						log.Printf("❌ [%s] 상품 등록 실패: %v", p.Code, err)
					} else {
						log.Printf("✅ [%s] 상품 등록 완료 (카테고리ID: %d)", p.Code, catID)
					}
				} else {
					log.Printf("❌ [%s] 조회 실패: %v", p.Code, err)
				}
			} else {
				log.Printf("ℹ️ [%s] 이미 존재하는 상품, 생략", p.Code)
			}
		}
	}
	return nil
}

// 미매칭 입금 주문 생성 및 관리자 알림
func createUnmatchedOrder(amount float64, tx TronTransaction) {
	unmatchedMsg := fmt.Sprintf(
		"🟢 *입금 알림*\n\n"+
			"━━━━━━━━━━━━━━━━\n"+
			"💰 금액: %.3f USDT\n"+
			"🔗 트랜잭션: `%s`\n"+
			"⏰ 시간: %s\n"+
			"📤 보낸주소: `%s`\n"+
			"📥 받은주소: `%s`\n"+
			"━━━━━━━━━━━━━━━━\n\n"+
			"❓ 상태: 매칭되는 주문이 없습니다\n"+
			"💡 조치: 수동 확인 필요\n\n"+
			"🔍 주문번호와 금액 다시 확인 부탁드립니다.",
		amount, tx.TxID, time.Now().Format("2006-01-02 15:04:05"),
		tx.From, tx.To,
	)

	notifySend(unmatchedAdminChatID, unmatchedMsg)

	txID := tx.TxID
	order := Order{
		UserID:      0,
		Product:     "미상",
		Amount:      amount,
		Status:      "입금대기중",
		ExpectedAmt: amount,
		TxID:        &txID, // 포인터 할당
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("미매칭 입금 주문 저장 실패: %v", err)
	}
}

func updateUserGrade(userID int64, newGrade string) error {
	// 1. 등급 업데이트
	if err := db.Model(&User{}).Where("user_id = ?", userID).Update("grade", newGrade).Error; err != nil {
		log.Printf("등급 업데이트 실패 userID=%d, newGrade=%s, err=%v", userID, newGrade, err)
		return err
	}

	// 2. 사용자 정보 조회
	var user User
	if err := db.Where("user_id = ?", userID).First(&user).Error; err != nil {
		log.Printf("사용자 정보 조회 실패 userID=%d, err=%v", userID, err)
		// 등급 변경은 성공했으므로 메시지 전송 실패는 무시
		return nil
	}

	username := user.UserName
	if username == "" {
		username = "unknown"
	}

	if user.ChatID == 0 {
		log.Printf("알림 전송 실패: chatID가 0입니다. userID=%d", userID)
		return nil
	}

	msgText := fmt.Sprintf(
		"🔔 <b>회원 등급 변경 알림</b>\n\n"+
			"유저네임: <b>@%s</b> 님\n"+
			"등급이 성공적으로 <b>%s</b> 로 변경되었습니다.\n\n"+
			"다양한 기능을 경험하시길 바랍니다.\n"+
			"WELCOME",
		username, newGrade,
	)

	msg := tgbotapi.NewMessage(user.ChatID, msgText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("회원 등급 변경 알림 전송 실패 userID=%d: %v", userID, err)
	}

	return nil
}

// ─── value(AmountStr) → float64 변환 유틸 ───
func parseUSDTAmount(raw string) float64 {
	val, _ := strconv.ParseFloat(raw, 64)
	return val / 1_000_000 // TRC20 USDT는 소수점 6자리(1 USDT == 1,000,000)
}

// ─── 타임스탬프(ms) → 사람이 읽을 수 있는 날짜 ───
func formatTronTimestamp(ts int64) string {
	return time.UnixMilli(ts).Format("2006-01-02 15:04:05")
}

func getTronDeposits(address string) ([]Deposit, error) {
	apiKey := getTronGridAPIKey()
	if apiKey == "" {
		return nil, fmt.Errorf("트론그리드 API 키가 설정되지 않음")
	}

	usdtContract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 메인넷 컨트랙트

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=50&contract_address=%s",
		address, usdtContract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	req.Header.Set("Accept", "application/json")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("트론그리드 API 응답 오류: %d %s", resp.StatusCode, string(body))
	}

	var apiResp struct {
		Data []struct {
			TxID      string `json:"transaction_id"`
			Value     string `json:"value"`
			Timestamp int64  `json:"block_timestamp"`
			From      string `json:"from"`
			To        string `json:"to"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, err
	}

	var deposits []Deposit
	for _, tx := range apiResp.Data {
		if !strings.EqualFold(tx.To, address) {
			continue
		}

		amount, err := strconv.ParseFloat(tx.Value, 64)
		if err != nil {
			log.Printf("[트론그리드] 입금액 파싱 실패 txid=%s, value=%s", tx.TxID, tx.Value)
			continue
		}
		amount = amount / 1_000_000

		deposits = append(deposits, Deposit{
			TxID:   tx.TxID,
			Amount: amount,
			Time:   time.UnixMilli(tx.Timestamp),
		})
	}
	return deposits, nil
}

func handleBroadcastInput(uid int64, text string) {
	// 입력 취소
	if text == "/cancel" {
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, "전체 공지 입력이 취소되었습니다.")
		return
	}

	// 전체 유저 채팅ID 조회
	var users []User
	err := db.Select("chat_id").Find(&users).Error
	if err != nil {
		sendTelegram(uid, "❌ 전체 유저 조회 실패")
		pendingBroadcastInput[uid] = false
		return
	}

	count := 0
	for _, user := range users {
		if user.ChatID == 0 {
			continue
		}
		_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "📢 <b>공지사항</b>\n\n"+text))
		if err != nil {
			log.Printf("공지 발송 실패: chat_id=%d, error=%v", user.ChatID, err)
			continue
		}
		count++
		time.Sleep(50 * time.Millisecond) // API 제한 회피용 조절 가능
	}

	pendingBroadcastInput[uid] = false
	sendTelegram(uid, fmt.Sprintf("✅ %d명에게 공지를 발송했습니다.", count))
}

// 입금 확인 및 주문 매칭 처리 (간결 로그 버전)
func processTronDeposits() {
	wallets, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[입금모니터링] 지갑 목록 조회 실패: %v", err)
		return
	}

	log.Printf("[입금모니터링] %d개 지갑 모니터링 시작", len(wallets))

	var (
		totalDeposits  int
		matchedCount   int
		unmatchedCount int
	)

	for _, wallet := range wallets {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[입금모니터링] %s... 입금 조회 실패: %v", wallet.Address[:10], err)
			continue
		}
		totalDeposits += len(deposits)

		for _, deposit := range deposits {
			if isDepositProcessed(deposit.TxID) {
				continue
			}

			// 주문 매칭 확인
			var existingOrder Order
			matchErr := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
				deposit.Amount-0.0001, deposit.Amount+0.0001, "입금대기중").
				First(&existingOrder).Error

			if matchErr == nil {
				matchedCount++
				log.Printf("[입금매칭] 주문 #%d, 금액: %.3f USDT, TxID: %.8s...", existingOrder.ID, deposit.Amount, deposit.TxID)
			} else {
				unmatchedCount++
				log.Printf("[미매칭입금] %.3f USDT (TxID: %.8s...)", deposit.Amount, deposit.TxID)
			}

			processTronTransaction(TronTransaction{
				TxID:      deposit.TxID,
				From:      "", // 필요시 채우기
				To:        wallet.Address,
				AmountStr: fmt.Sprintf("%f", deposit.Amount),
				Timestamp: deposit.Time.UnixMilli(),
			})
			markDepositProcessed(deposit.TxID)
		}
	}

	// 최종 요약
	if totalDeposits > 0 {
		log.Printf("[입금모니터링] 요약: 총 %d건 | 매칭 %d | 미매칭 %d", totalDeposits, matchedCount, unmatchedCount)
	}
}

// 입금 모니터링 루프 시작
func startDepositMonitoring() {
	go func() {
		ticker := time.NewTicker(40 * time.Second)
		defer ticker.Stop()
		log.Println("🔍 입금 모니터링 시작... (40초 간격)")
		for {
			processTronDeposits()
			<-ticker.C
		}
	}()
}

func sendTelegram(chatID int64, message string) error {
	if strings.TrimSpace(message) == "" {
		log.Printf("⚠️ sendTelegram 호출 시 빈 메시지입니다. chatID=%d", chatID)
		return fmt.Errorf("빈 메시지")
	}
	msg := tgbotapi.NewMessage(chatID, message)
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("텔레그램 메시지 전송 실패: %v", err)
	}
	return err
}

// 전체 방문자 조회 (중복 없이 최근 방문자 목록)
func getAllVisitors() ([]Visitor, error) {
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen FROM (
			SELECT user_id, user_name, last_seen,
				ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_seen DESC) as rn
			FROM users
		) t
		WHERE rn = 1
		ORDER BY last_seen DESC
	`).Scan(&visitors).Error
	return visitors, err
}

// 특정 날짜 방문자 조회
func getVisitorsByDate(date time.Time) ([]Visitor, error) {
	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)

	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen
		FROM users
		WHERE last_seen BETWEEN ? AND ?
		ORDER BY last_seen DESC
	`, start, end).Scan(&visitors).Error
	return visitors, err
}

func handleCoinPaymentUnified(cb *tgbotapi.CallbackQuery, uid int64, chatID int64, orderID uint64) {
	// 1. 콜백 데이터 nil 체크 및 로그
	if cb != nil {
		log.Printf("[handleCoinPaymentUnified] 콜백 데이터 있음: %s", cb.Data)
	} else {
		log.Println("[handleCoinPaymentUnified] 콜백 데이터가 nil입니다. 콜백 응답 없이 처리합니다.")
	}

	// 2. 주문 정보 DB에서 조회
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		sendTelegram(uid, "❌ 주문 정보를 찾을 수 없습니다.")
		if cb != nil {
			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "주문 정보 없음")); err != nil {
				log.Printf("콜백 응답 실패: %v", err)
			}
		}
		return
	}

	// 3. 주문 상태 확인 (입금대기중인지)
	if order.Status != "입금대기중" {
		sendTelegram(uid, "❌ 이미 처리된 주문입니다.")
		if cb != nil {
			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "이미 처리된 주문")); err != nil {
				log.Printf("콜백 응답 실패: %v", err)
			}
		}
		return
	}

	// 4. 결제 주소 환경변수 확인
	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		log.Println("⚠️ COIN_PAYMENT_ADDR 환경변수 설정 안됨")
		sendTelegram(uid, "❌ 결제 주소가 설정되어 있지 않습니다. 관리자에게 문의하세요.")
		return
	}

	// 5. QR 코드 생성
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID)
	paymentURI := fmt.Sprintf("%s?amount=%.3f", coinAddr, order.ExpectedAmt)
	if err := generateWalletQRCode(paymentURI, qrPath); err != nil {
		log.Printf("QR 코드 생성 실패: %v", err)
	}

	// 6. 주문 안내 메시지 전송
	msgText := fmt.Sprintf(
		"🛒 <b>주문 접수 완료</b>\n\n"+
			"• 주문번호: <code>%d</code>\n• 상품명: <b>%s</b>\n• 결제금액: <b>%.3f USDT</b>\n\n"+
			"(소수점까지 정확하게, QR 코드 활용 권장)\n20분 내 미입금시 자동취소 됩니다.",
		order.ID, order.Product, order.ExpectedAmt,
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("❌ 주문취소", fmt.Sprintf("cancel_order_%d", order.ID)),
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("주문 안내 메시지 전송 실패: %v", err)
	}

	// 7. userMessageIDs 맵 nil 체크 및 초기화
	if userMessageIDs == nil {
		userMessageIDs = make(map[int64][]int)
	}
	userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)

	// 8. QR 코드 이미지 전송
	if qrPath != "" {
		photo := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(qrPath))
		photo.Caption = fmt.Sprintf(
			"아래 주소로 <b>정확한 금액</b>을 입금해 주세요.\n<b>━━━━━━━━━━━━━━━━</b>\n<code>%s</code>\n<b>━━━━━━━━━━━━━━━━</b>\n주소 클릭시 복사 됩니다.",
			coinAddr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("QR 코드 이미지 전송 실패: %v", err)
		}
	}

	// 9. 20분 미입금 자동취소 고루틴 시작
	go func(orderID uint64, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "입금대기중" {
			ord.Status = "자동취소"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("주문 자동취소 저장 실패: %v", err)
			}
			sendTelegram(userID, fmt.Sprintf("❌ 주문 #%d 20분 내 미입금으로 자동취소되었습니다.", orderID))
		}
	}(uint64(order.ID), uid)

	// 10. 콜백 응답 (cb 존재 시에만)
	if cb != nil {
		if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "주문이 접수되었습니다.")); err != nil {
			log.Printf("콜백 응답 실패: %v", err)
		}
	}
}

func sendTelegramHTML(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("텔레그램 메시지 전송 실패 (chatID=%d): %v", chatID, err)
	}
}

func handleAdminListVisitors(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
		return
	}

	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil {
		log.Printf("[handleAdminListVisitors] DB 조회 실패: %v", err)
		sendTelegram(uid, "❌ DB 조회 중 오류 발생")
		return
	}
	if len(activities) == 0 {
		sendTelegram(uid, "⚠️ 최근 방문자가 없습니다.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>👥 전체 방문자 목록 (최신 50명)</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, act := range activities {
		username := "(없음)"
		if act.Username != "" {
			username = "@" + act.Username
		}

		nickname := "(이름 없음)"
		if act.Nickname != "" {
			nickname = act.Nickname
		}

		lastActive := "(미기록)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code>\n• %s / %s\n• 🕒 최근 활동: <i>%s</i>\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━")

	msg := tgbotapi.NewMessage(uid, sb.String())
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[handleAdminListVisitors] 메시지 전송 실패: %v", err)
	}
}

func handleAdminListVisitorsToday(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
		return
	}

	today := time.Now().Format("2006-01-02")

	var visitors []UserActivityLog
	err := db.Where("DATE(last_active) = ?", today).Order("last_active DESC").Find(&visitors).Error
	if err != nil || len(visitors) == 0 {
		sendTelegram(uid, "❌ 오늘 방문자 조회 실패 또는 방문자 없음")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>📅 오늘 방문자 목록</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, v := range visitors {
		username := v.Username
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}
		lastActive := v.LastActive.Format("15:04")

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n  최근 활동: %s\n\n",
			i+1, v.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")

	sendTelegram(uid, sb.String())
}

func showAdminProductDetail(chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(chatID, "❌ 상품 정보를 불러올 수 없습니다.")
		return
	}

	stockCount, err := getCardStock(product.Name)
	if err != nil {
		stockCount = 0
	}

	text := fmt.Sprintf(
		"📄 <b>상품 상세</b>\n\n"+
			"• 이름: %s\n"+
			"• 가격: %.2f USDT\n"+
			"• 설명: %s\n"+
			"• 재고: %d\n",
		product.Name, product.Price, product.Description, stockCount,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", fmt.Sprintf("admin_add_stock_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("📦 재고 관리", "admin_stock_menu"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✏️ 상품수정", fmt.Sprintf("admin_edit_product_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("🗑 상품삭제", fmt.Sprintf("admin_delete_product_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 상품목록", fmt.Sprintf("admin_cat_back_%d", product.CategoryID)),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func sendTelegramSafe(chatID int64, text string) {
	if strings.TrimSpace(text) == "" {
		log.Printf("sendTelegram 호출 시 빈 메시지 차단 chatID=%d", chatID)
		return
	}
	sendTelegram(chatID, text)
}

func showTodayVisitorsMenu(chatID int64, messageID int) {
	// 오늘 날짜 00:00 ~ 23:59 기준
	today := time.Now().Format("2006-01-02")
	var users []User
	// last_seen 또는 last_login 칼럼 기준 (칼럼 이름에 맞게 수정)
	err := db.Where("DATE(last_seen) = ?", today).Order("last_seen DESC").Find(&users).Error
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 오늘 방문자 조회 실패")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "오늘 방문자가 없습니다.")
		bot.Request(msg)
		return
	}

	text := "👀 <b>오늘 방문자 (최신순)</b>\n\n"
	for i, u := range users {
		text += fmt.Sprintf("%d. <code>%d</code> @%s (%s)\n",
			i+1, u.UserID, u.UserName, u.LastSeen.Format("15:04"))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 메인으로", "admin_visitor_menu"),
		),
	)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

// QR코드 생성 함수
func generateWalletQRCode(data string, filename string) error {
	if data == "" {
		log.Println("QR코드 생성 스킵: 주소(데이터) 없음")
		return fmt.Errorf("QR코드 생성 실패: 입력 데이터 없음")
	}

	// 파일 저장 디렉토리 생성 (없으면 자동 생성)
	dir := filepath.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		log.Printf("QR코드 저장 폴더 생성 실패: %v", err)
		return fmt.Errorf("QR코드 폴더 생성 실패: %w", err)
	}

	// QR코드 파일 생성
	if err := qrcode.WriteFile(data, qrcode.Medium, 256, filename); err != nil {
		log.Printf("QR코드 이미지 생성 실패: %v", err)
		return fmt.Errorf("QR코드 이미지 생성 실패: %w", err)
	}

	return nil // 성공
}

func findMatchingOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "입금대기중").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("매칭되는 주문 없음: %.6f", amount)
	}
	return &order, nil
}

// 트론그리드 API 키 가져오기
func getTronGridAPIKey() string {
	apiKey := os.Getenv("TRONGRID_API_KEY")
	if apiKey == "" {
		log.Println("⚠️ TRONGRID_API_KEY 환경변수가 설정되지 않았습니다.")
	}
	return apiKey
}

func getUsersByPage(limit int, offset int) ([]User, error) {
	var users []User
	err := db.Limit(limit).Offset(offset).Find(&users).Error
	return users, err
}

func showAllVisitorsMenu(chatID int64, messageID int) {
	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil || len(activities) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 전체 방문자 조회 실패 또는 방문자 없음")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>👥 전체 방문자 (최신 50명)</b>\n━━━━━━━━━━━━━\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}
		lastActive := "(알 수 없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n  최근 활동: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━\n")

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 메인으로", "admin_visitor_menu"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func handleStart(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	username := msg.From.UserName
	sendTelegram(uid, "")
	showMenu(uid, username, chatID) // 괄호와 인자 추가!
}

func formatUserActivitiesMessagePaged(activities []UserActivityLog, page, pageSize int) string {
	total := len(activities)
	if total == 0 {
		return "조회 결과가 없습니다."
	}

	start := (page - 1) * pageSize
	if start >= total {
		return fmt.Sprintf("📄 페이지 %d 는 유효하지 않습니다. 총 %d 페이지까지 존재합니다.", page, (total+pageSize-1)/pageSize)
	}

	end := start + pageSize
	if end > total {
		end = total
	}

	totalPages := (total + pageSize - 1) / pageSize

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 최근 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n\n", page, totalPages))

	for _, act := range activities[start:end] {
		lastActive := "(기록 없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(없음)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}

		sb.WriteString(fmt.Sprintf(
			"• <code>%d</code> | %s / @%s\n  🕒 %s\n━━━━━━━━━━━━━━\n",
			act.UserID, nickname, username, lastActive,
		))
	}

	return sb.String()
}

func showAdminBroadcastMenu(chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "📢 <b>전체 공지 모드</b>\n\n모든 사용자에게 보낼 공지 내용을 입력하세요.\n\n취소: /cancel")
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("❌ 전체공지 메뉴 표시 실패: %v", err)
	}
}

func matchOrderByDepositAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.0001, amount+0.0001, "입금대기중").
		Order("id ASC").First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("❌ 매칭되는 주문 없음 (입금액: %.6f)", amount)
	}
	return &order, nil
}

func getVisitorPaginationKeyboard(currentPage, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var navRow []tgbotapi.InlineKeyboardButton

	if currentPage > 1 {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 이전", fmt.Sprintf("visitor_page_%d", currentPage-1)),
		)
	} else {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("　", "noop"),
		)
	}

	navRow = append(navRow,
		tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("📄 %d / %d", currentPage, totalPages), "noop"),
	)

	if currentPage < totalPages {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("다음 ➡️", fmt.Sprintf("visitor_page_%d", currentPage+1)),
		)
	} else {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("　", "noop"),
		)
	}

	backRow := tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 뒤로가기", "admin_visitor_menu"),
	)

	return tgbotapi.NewInlineKeyboardMarkup(navRow, backRow)
}

func showVisitorListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, total, err := getVisitors(page, pageSize)
	if err != nil {
		sendTelegram(uid, "❌ 방문자 목록을 불러오는 중 오류가 발생했습니다.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	visitors := convertUsersToVisitors(users)
	msgText := formatVisitorListMessage(visitors, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

func convertUsersToVisitors(users []User) []Visitor {
	visitors := make([]Visitor, len(users))
	for i, u := range users {
		visitors[i] = Visitor{
			UserID:   u.UserID,
			UserName: sql.NullString{String: u.UserName, Valid: u.UserName != ""},
			Nickname: u.Nickname, // 닉네임 추가 필드
			LastSeen: u.LastSeen,
		}
	}
	return visitors
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func showVisitorListPageByDate(uid, chatID int64, messageID int, date time.Time, page int) {
	const pageSize = 10

	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)

	var visitors []Visitor
	var total int64

	err := db.Where("last_seen BETWEEN ? AND ?", start, end).
		Order("last_seen DESC").
		Limit(pageSize).
		Offset((page - 1) * pageSize).
		Find(&visitors).Error
	if err != nil {
		sendTelegram(uid, "❌ 방문자 목록을 불러오는 중 오류가 발생했습니다.")
		return
	}

	db.Model(&Visitor{}).Where("last_seen BETWEEN ? AND ?", start, end).Count(&total)

	var sb strings.Builder
	msgText := fmt.Sprintf("<b>👥 방문자 (%s, %d명 중 %d~%d)</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n",
		start.Format("2006-01-02"),
		total,
		(page-1)*pageSize+1,
		min(page*pageSize, int(total)),
	)
	sb.WriteString(msgText)

	for i, v := range visitors {
		// username
		usernameStr := "없음"
		if v.UserName.Valid && v.UserName.String != "" {
			usernameStr = "@" + v.UserName.String
		}

		// last seen
		lastSeen := "(알 수 없음)"
		if !v.LastSeen.IsZero() {
			lastSeen = v.LastSeen.Format("15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <i>%s</i>\n  최근: %s\n\n",
			(page-1)*pageSize+i+1, v.UserID, usernameStr, lastSeen,
		))
	}

	// 하단 이동 버튼 등 필요시 추가
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 메인으로", "admin_visitor_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

func showAdminMemberMenu(chatID int64, msgID int) {
	var members []User
	err := db.Limit(20).Order("created_at desc").Find(&members).Error
	if err != nil {
		sendTelegram(chatID, "❌ 회원 목록을 불러오지 못했습니다.")
		return
	}
	if len(members) == 0 {
		sendTelegram(chatID, "회원이 없습니다.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>회원 목록 (최대 20명)</b>\n\n")
	for _, m := range members {
		userDisplay := html.EscapeString(m.UserName)
		if userDisplay == "" {
			userDisplay = "이름없음"
		}
		sb.WriteString(fmt.Sprintf("• %s (ID: %d)\n", userDisplay, m.UserID))
	}

	// 각 회원별 등급 변경 버튼 생성
	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, m := range members {
		userIDStr := fmt.Sprintf("%d", m.UserID)
		row := tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🥉", "admin_set_grade_bronze_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("🥈", "admin_set_grade_silver_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("🥇", "admin_set_grade_gold_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("💎", "admin_set_grade_diamond_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("👑", "admin_set_grade_vip_"+userIDStr),
		)
		keyboardRows = append(keyboardRows, row)
	}

	// 뒤로가기 버튼
	backRow := tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
	)
	keyboardRows = append(keyboardRows, backRow)

	kb := tgbotapi.NewInlineKeyboardMarkup(keyboardRows...)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminSettingsMenu(chatID int64, messageID int) {
	text := "<b>⚙️ 관리자 설정</b>\n\n기능 설정을 관리합니다."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("설정 메뉴 수정 실패: %v", err)
	}
}

func showAdvancedAdminMenu(uid int64, chatID int64, msgID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("DB 상태 확인", "admin_db_status"),
			tgbotapi.NewInlineKeyboardButtonData("서버 상태", "admin_server_status"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
		),
	)

	msgText := "<b>고급 관리자 메뉴</b>\n\n필요한 기능을 선택하세요."

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, int(msgID), msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminInventoryMenu(chatID int64, msgID int) {
	type StockSummary struct {
		Category string
		Count    int64
	}
	var results []StockSummary

	err := db.Model(&StockCard{}).
		Select("category, COUNT(*) as count").
		Where("used = ?", false).
		Group("category").
		Scan(&results).Error
	if err != nil {
		sendTelegram(chatID, "❌ 재고 현황을 불러오지 못했습니다.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>재고 현황</b>\n\n")
	for _, r := range results {
		sb.WriteString(fmt.Sprintf("• %s: %d개\n", html.EscapeString(r.Category), r.Count))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고 추가", "admin_add_stock"),
			tgbotapi.NewInlineKeyboardButtonData("🧹 재고 정리", "admin_cleanup_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📋 MEMBERSHIP 상세", "admin_cat_MEMBERSHIP"),
			tgbotapi.NewInlineKeyboardButtonData("📋 ESIM 상세", "admin_cat_ESIM"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📋 CARD 상세", "admin_cat_CARD"),
			tgbotapi.NewInlineKeyboardButtonData("📋 ACCOUNT 상세", "admin_cat_ACCOUNT"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showStockListByCategory(chatID int64, msgID int, category string) {
	var stocks []StockCard
	err := db.Where("category = ? AND used = ?", category, false).Find(&stocks).Error
	if err != nil {
		sendTelegram(chatID, "❌ 재고 목록을 불러오지 못했습니다.")
		return
	}

	if len(stocks) == 0 {
		sendTelegram(chatID, "❌ 해당 카테고리에 사용 가능한 재고가 없습니다.")
		return
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>%s 카테고리 재고 목록</b>\n\n", html.EscapeString(category)))
	for i, stock := range stocks {
		content := html.EscapeString(stock.Content)
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, content))
		if i >= 29 { // 최대 30개 표시 제한
			sb.WriteString("...\n")
			break
		}
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 재고 현황으로", "admin_stock"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

// 관리자 최근 주문 내역 메뉴
func showAdminOrdersMenu(chatID int64, msgID int) {
	var orders []Order
	err := db.Order("created_at desc").Limit(10).Find(&orders).Error
	if err != nil {
		sendTelegram(chatID, "❌ 주문 내역을 불러오지 못했습니다.")
		return
	}

	if len(orders) == 0 {
		sendTelegram(chatID, "주문 내역이 없습니다.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>최근 주문 내역 (최대 10건)</b>\n\n")
	for _, o := range orders {
		sb.WriteString(fmt.Sprintf("• 주문번호: %d\n  상품명: %s\n  금액: %.2f USDT\n  상태: %s\n\n",
			o.ID, html.EscapeString(o.Product), o.Amount, o.Status))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func formatVisitorListMessage(visitors []Visitor, page, totalPages int) string {
	if len(visitors) == 0 {
		return "<b>조회 결과가 없습니다.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	for i, v := range visitors {
		username := "(없음)"
		if v.UserName.Valid {
			username = "@" + v.UserName.String
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}
		lastSeen := "(알 수 없음)"
		if !v.LastSeen.IsZero() {
			lastSeen = v.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\n최근 접속: %s\n━━━━━━━━━━━━━━\n",
			(i+1)+(page-1)*10, v.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

func handleAdminCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 이용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	switch {
	// 방문자 페이지별 조회: visitors_page_숫자
	case strings.HasPrefix(data, "visitors_page_"):
		pageStr := strings.TrimPrefix(data, "visitors_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			sendTelegram(uid, "❌ 올바르지 않은 페이지 번호입니다.")
			return
		}

		// DB에서 모든 UserActivityLog 조회
		var activities []UserActivityLog
		if err := db.Order("last_active DESC").Find(&activities).Error; err != nil {
			sendTelegram(uid, "❌ 방문자 데이터를 불러오는 중 오류가 발생했습니다.")
			return
		}

		pageSize := 10
		msgText := formatUserActivitiesMessagePaged(activities, page, pageSize)

		kb := createUserActivityKeyboard(page, (len(activities)+pageSize-1)/pageSize)

		edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("방문자 목록 메시지 전송 실패: %v", err)
		}

		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("페이지 %d 로 이동", page)))
		return

	// 전체 공지 메뉴 호출
	case data == "admin_broadcast_menu":
		showAdminBroadcastMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "전체 공지 메뉴 표시"))
		return

	// 그 외 기본 관리자 메뉴
	case data == "admin_menu":
		showAdminMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 메뉴 표시"))
		return

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "알 수 없는 명령어"))
	}
}

// 재고관리 콜백 처리 함수
func handleAdminStockCallbacks(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	// 재고 추가
	if strings.HasPrefix(data, "admin_add_stock_") {
		idStr := strings.TrimPrefix(data, "admin_add_stock_")
		productID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "❌ 잘못된 상품 ID입니다.")
			return
		}
		pendingStockInput[uid] = strconv.Itoa(productID)

		cancelKb := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("취소"),
				tgbotapi.NewKeyboardButton("나가기"),
			),
		)
		msg := tgbotapi.NewMessage(uid, "추가할 <b>재고 코드</b>를 한 줄에 하나씩 입력하세요.\n입력 완료 시 '완료' 입력!")
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = cancelKb
		bot.Send(msg)

		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 추가 대기중"))
		return
	}

	// 상품 상세보기
	if strings.HasPrefix(data, "admin_stock_detail_") {
		idStr := strings.TrimPrefix(data, "admin_stock_detail_")
		productID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "❌ 잘못된 상품 ID입니다.")
			return
		}
		showAdminStockDetail(chatID, msgID, productID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "상품 상세 표시"))
		return
	}

	// 재고 수정
	if strings.HasPrefix(data, "admin_edit_stock_") {
		idStr := strings.TrimPrefix(data, "admin_edit_stock_")
		stockID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "❌ 잘못된 재고 ID입니다.")
			return
		}
		showAdminEditStock(chatID, msgID, stockID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 수정 화면 표시"))
		return
	}

	// 재고 삭제
	if strings.HasPrefix(data, "admin_del_stock_") {
		idStr := strings.TrimPrefix(data, "admin_del_stock_")
		stockID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "❌ 잘못된 재고 ID입니다.")
			return
		}
		promptConfirmDeleteStock(uid, chatID, msgID, stockID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 확인 대기"))
		return
	}
}

func visitorsToUsers(visitors []Visitor) []User {
	users := visitorsToUsers(visitors)
	for _, v := range visitors {
		username := ""
		if v.UserName.Valid {
			username = v.UserName.String
		}
		users = append(users, User{
			UserID:   v.UserID,
			UserName: username,
			Nickname: v.Nickname,
			LastSeen: v.LastSeen,
		})
	}
	return users
}

// 유저ID로 등록된 트론(USDT) 지갑 주소 조회
func getWalletAddress(uid int64) (string, error) {
	var walletMap WalletMap
	err := db.Where("user_id = ?", uid).First(&walletMap).Error
	if err != nil || walletMap.Wallet == "" {
		return "", fmt.Errorf("등록된 지갑 없음")
	}
	return walletMap.Wallet, nil
}

func handleAdminMonthlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "📊 월간 리포트\n\n" +
		"• 총 매출: 1,000,000 USDT\n" +
		"• 총 주문 수: 1500건\n" +
		"• 인기 상품: VPS 1개월\n" +
		"• 신규 가입자: 200명\n\n" +
		"📅 해당 달 데이터를 표시합니다."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("월간 리포트 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "월간 리포트 표시"))
}

func handleAdminYearlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "📊 연간 리포트\n\n" +
		"• 총 매출: 12,000,000 USDT\n" +
		"• 총 주문 수: 18,000건\n" +
		"• 인기 상품: VPS 1년\n" +
		"• 신규 가입자: 2,500명\n\n" +
		"📅 해당 연도 데이터를 표시합니다."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("연간 리포트 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "연간 리포트 표시"))
}

func promptEditProduct(uid, chatID int64, msgID int, productID int) {
	// DB에서 상품 정보 조회
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		log.Printf("❌ 상품 조회 실패: ID=%d, UID=%d, 오류=%v", productID, uid, err)
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}

	// uid별 수정 대기상태 저장
	pendingEditProduct[uid] = productID

	// 안내 메시지 전송
	msg := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf(
		"🔧 <b>상품 정보 수정</b>\n\n"+
			"• 현재 이름: <code>%s</code>\n• 현재 가격: <b>%.2f USDT</b>\n\n"+
			"✏️ 수정할 <b>이름:가격</b>을 아래 형식으로 입력하세요.\n"+
			"예: <code>%s:%.2f</code>",
		prod.Name, prod.Price, prod.Name, prod.Price,
	))
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("🔧 promptEditProduct 메시지 전송 실패: %v", err)
	}
}

func sendCaptchaChallenge(chatID int64, a, b, correctAnswer int) {
	// 옵션 리스트 생성 및 랜덤 섞기
	options := []int{correctAnswer, correctAnswer + 1, correctAnswer - 1}
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	text := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🔒<b>PRIVATE ACCESS ONLY</b>\n"+
			"접근 권한이 없습니다.\n"+
			"아래 문제를 풀어 해제 하세요.\n\n"+
			"<b>%d + %d = ?</b>\n"+
			"<b>━━━━━━━━━━━━━━━━</b>",
		a, b,
	)

	var btns []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		btns = append(btns,
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), fmt.Sprintf("verify_%d", opt)),
		)
	}

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(btns...),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = markup
	bot.Send(msg)
}

// 상담원 여부 체크 헬퍼 함수
func isSupporter(userID int64) bool {
	for _, adminID := range activeSupportSessions {
		if adminID == userID {
			return true
		}
	}
	return false
}

func handleMessage(msg *tgbotapi.Message) {
	if msg == nil {
		return
	}

	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	text := strings.TrimSpace(msg.Text)

	username := ""
	if msg.From != nil {
		username = msg.From.UserName
	}
	isAdminUser := isAdmin(uid)

	// 사진 메시지 처리
	if len(msg.Photo) > 0 {
		handlePhotoMessage(msg)
		return
	}

	// 미인증 사용자 캡챠 처리
	if !verifiedUsers[uid] {
		a, b, ans := generateCaptcha()
		verificationAnswers[uid] = ans
		sendCaptchaChallenge(chatID, a, b, ans)
		return
	}

	// --- 지갑 등록 입력 대기 상태 처리 ---
	if pendingWalletInput[uid] {
		if text == "/cancel" {
			pendingWalletInput[uid] = false
			sendTelegram(chatID, "지갑 등록이 취소되었습니다.")
			return
		}

		if isValidTronAddress(text) {
			err := saveUserWallet(uid, text, username)
			if err != nil {
				sendTelegram(chatID, "❌ 지갑 등록 실패: "+err.Error())
			} else {
				sendTelegram(chatID, "✅ 지갑이 성공적으로 등록되었습니다.")
				log.Printf("[지갑등록] uid:%d, 주소: %s", uid, text)
			}
		} else {
			sendTelegram(chatID, "❌ 유효하지 않은 TRON 주소입니다. 다시 입력해 주세요.")
		}
		pendingWalletInput[uid] = false
		return
	}
	// 전체 공지 입력 중
	if pendingBroadcastInput[uid] {
		if text == "/cancel" {
			pendingBroadcastInput[uid] = false
			sendTelegram(uid, "전체 공지 입력이 취소되었습니다.")
			return
		}
		var users []User
		err := db.Select("chat_id").Find(&users).Error
		if err != nil {
			sendTelegram(uid, "❌ 전체 유저 조회 실패")
			pendingBroadcastInput[uid] = false
			return
		}
		successCount := 0
		for _, user := range users {
			if user.ChatID == 0 {
				continue
			}
			_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "📢 [공지]\n\n"+text))
			if err == nil {
				successCount++
			}
			time.Sleep(30 * time.Millisecond)
		}
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, fmt.Sprintf("✅ 총 %d명에게 공지를 전송했습니다.", successCount))
		return
	}

	// 상품 추가 대기 상태
	if pid, ok := pendingEditProduct[uid]; ok {
		if text == "취소" || text == "나가기" || text == "/cancel" {
			delete(pendingEditProduct, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "❌ 상품 추가가 취소되었습니다.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			sendTelegram(uid, "카테고리 메뉴로 돌아갑니다.")
			// showCategoryMenu(uid, chatID, 0)
			return
		}
		if pid == 0 {
			delete(pendingEditProduct, uid)
			cat, ok := selectedCategory[uid]
			if !ok || cat == "" {
				sendTelegram(uid, "❌ 먼저 카테고리를 선택하세요!")
				return
			}
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "❌ 올바른 형식이 아닙니다.\n예시: 새상품명:9.99")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price <= 0 {
				sendTelegram(uid, "❌ 가격은 숫자(1 이상)로 입력해 주세요.")
				return
			}
			categoryID, ok := categoryMap[cat]
			if !ok {
				sendTelegram(uid, "❌ 잘못된 카테고리입니다.")
				return
			}
			code := uuid.New().String()
			prod := Product{
				Code:       code,
				Name:       name,
				Price:      price,
				Active:     true,
				CategoryID: categoryID,
			}
			if err := db.Create(&prod).Error; err != nil {
				sendTelegram(uid, fmt.Sprintf("❌ 상품 추가 실패: %v", err))
				return
			}
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("✅ 새 상품 '%s' (%.2f USDT) 추가 완료! [카테고리: %s]", name, price, cat))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}

		if pid != 0 {
			delete(pendingEditProduct, uid)
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "❌ 입력 형식이 올바르지 않습니다.\n(예시: 상품명:9.99)")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price < 0.01 {
				sendTelegram(uid, "❌ 가격은 0.01 이상 숫자로 입력해 주세요.")
				return
			}
			var prod Product
			if err := db.First(&prod, pid).Error; err != nil {
				sendTelegram(uid, "❌ 상품 정보를 불러올 수 없습니다.")
				return
			}
			cat := ""
			for k, v := range categoryMap {
				if v == prod.CategoryID {
					cat = k
					break
				}
			}
			if err := db.Model(&Product{}).Where("id = ?", pid).
				Updates(map[string]interface{}{"name": name, "price": price}).Error; err != nil {
				sendTelegram(uid, "❌ 상품 정보 수정 실패! 다시 시도해 주세요.")
			} else {
				sendTelegram(uid, fmt.Sprintf("✅ 상품이 수정되었습니다!\n이름: %s\n가격: %.2f", name, price))
			}
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}
	}

	// 재고 추가 대기 상태
	if pidStr, ok := pendingStockInput[uid]; ok {
		productID, _ := strconv.Atoi(pidStr)
		var prod Product
		if err := db.First(&prod, productID).Error; err != nil {
			sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
			return
		}
		if !pendingStockInputNotified[uid] {
			sendTelegram(uid, fmt.Sprintf("🔹 [%s] 상품에 재고 코드를 붙여넣거나 입력하세요.\n완료 시 '완료'를 입력하세요.", prod.Name))
			pendingStockInputNotified[uid] = true
		}

		if text == "취소" || text == "나가기" || text == "/cancel" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "❌ 재고 추가가 취소되었습니다.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			return
		}

		lines := strings.Split(text, "\n")
		var added int
		for _, line := range lines {
			code := strings.TrimSpace(line)
			if code == "" || code == "완료" {
				continue
			}
			stock := StockCard{
				Name:    prod.Name,
				Content: code,
				Used:    false,
			}
			if err := db.Create(&stock).Error; err == nil {
				added++
			}
		}
		if strings.Contains(text, "완료") || text == "완료" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("✅ %d개의 코드가 추가되었습니다! (상품명: %s)", added, prod.Name))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
		} else {
			bot.Send(tgbotapi.NewMessage(uid, fmt.Sprintf("임시저장: [%d개] 코드가 입력되었습니다. 계속 붙여넣거나 '완료'를 입력하세요.", added)))
		}
		return
	}
	if _, ok := activeSupportSessions[uid]; ok || isSupporter(uid) {
		relaySupportMessage(uid, text)
		return
	}
	// 입금 금액 직접 입력 처리
	if pendingDepositInput[uid] {
		amount, err := strconv.ParseFloat(text, 64)
		if err != nil || amount < 1 {
			sendTelegram(uid, "❌ 1 USDT 이상, 올바른 숫자만 입력해 주세요.")
			return
		}
		delete(pendingDepositInput, uid)

		prodName := "USDT 충전"
		price := amount

		order := Order{
			UserID:      uid,
			Product:     prodName,
			Amount:      price,
			Status:      "입금대기중",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
		}

		if err := db.Create(&order).Error; err != nil {
			sendTelegram(uid, "❌ 주문 생성 실패! 관리자에게 문의해 주세요.")
			return
		}

		addr := os.Getenv("COIN_PAYMENT_ADDR")
		qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
		_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

		msgText := fmt.Sprintf(
			"💸 <b>충전 주문이 생성되었습니다!</b>\n\n"+
				"아래 주소로 <b>정확히 <code>%.3f USDT</code></b>를 입금해 주세요.\n\n"+
				"• 주문번호: <code>%d</code>\n"+
				"• 입금주소: <code>%s</code>\n"+
				"• 결제금액: <b>%.3f USDT</b>\n\n"+
				"(QR코드로 송금 가능, 소수점까지 정확히!)",
			amount, order.ID, addr, amount,
		)
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		bot.Send(msg)

		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photo.Caption = "QR코드를 사용하면 금액이 자동 지정됩니다."
		photo.ParseMode = "HTML"
		bot.Send(photo)
		return
	}

	// 명령어 처리
	if strings.HasPrefix(text, "/") {
		switch text {
		case "/start":
			handleStart(msg)
		case "/menu":
			showMenu(uid, username, chatID)
		case "/공지":
			if isAdminUser {
				pendingBroadcastInput[uid] = true
				sendTelegram(uid, "전체 공지 내용을 입력하세요. 취소하려면 /cancel 입력")
			} else {
				sendTelegram(uid, "권한이 없습니다.")
			}
		case "/balance":
			handleBalanceCommand(msg)
		case "/addstock":
			handleAddStockCommand(msg)
		case "/내지갑":
			wallet := getUserWallet(uid)
			if wallet == "" {
				sendTelegram(chatID, "❌ 등록된 지갑이 없습니다. /지갑등록 명령어로 지갑을 먼저 등록해 주세요.")
			} else {
				sendTelegram(chatID, fmt.Sprintf("✅ 등록된 TRC20 지갑 주소:\n<code>%s</code>", wallet))
			}
		case "/지갑등록":
			if !isAdminUser {
				sendTelegram(chatID, "❌ 관리자만 지갑 등록을 할 수 있습니다.")
				return
			}
			pendingWalletInput[uid] = true
			sendTelegram(chatID, "관리자 지갑 주소를 입력하세요 (TRON 주소 형식). 취소는 /cancel")
		default:
			log.Printf("[handleMessage] 알 수 없는 명령어: %s", text)
		}
		return
	}

	// 일반 텍스트 처리
	switch text {
	case "에너지":
		showEnergyMenu(uid, chatID, msg.MessageID)
		return
	case "내 정보":
		showBalanceMenu(uid, chatID, 0)
		return
	case "고객센터":
		showSupportMenu(chatID)
		return
	case "주문내역":
		showOrderHistoryMenu(uid, chatID, msg.MessageID)
		return
	}
	if !isAdminUser {
		log.Printf("[handleMessage] uid=%d, text=%q (관리자 아님, 무시)", uid, text)
		return
	}

	if strings.Contains(text, ":") && len(strings.Split(text, ":")) >= 3 {
		if err := saveStockWithImage(text, ""); err != nil {
			sendTelegram(uid, fmt.Sprintf("❌ 재고 추가 실패: %v", err))
		} else {
			sendTelegram(uid, "✅ 재고가 성공적으로 추가되었습니다!")
		}
		return
	}

	if text == "등록" {
		sendTelegram(uid, "❌ 등록할 재고 정보가 없습니다. 먼저 재고 정보를 입력해주세요.")
		return
	}

	log.Printf("[handleMessage] uid=%d, text=%q (처리할 내용 없음)", uid, text)
}

func handleWalletRegistration(uid int64, walletAddress string) error {
	// 지갑 주소 유효성 검사
	if !isValidTronAddress(walletAddress) {
		return fmt.Errorf("유효하지 않은 지갑 주소입니다")
	}

	// 사용자 조회
	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return fmt.Errorf("사용자를 찾을 수 없습니다")
		}
		return err
	}

	// 지갑 주소 저장
	user.DepositWallet = walletAddress
	if err := db.Save(&user).Error; err != nil {
		return fmt.Errorf("지갑 저장 중 오류 발생: %w", err)
	}

	return nil
}

func handlePhotoMessage(msg *tgbotapi.Message) {
	panic("unimplemented")
}

func showBalanceMenu(uid, chatID int64, msgID int) {
	var balance UserBalance
	err := db.Where("user_id = ?", uid).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance.Balance = 0
		} else {
			sendTelegram(uid, "❌ 잔액 조회 중 오류가 발생했습니다.")
			return
		}
	}

	text := fmt.Sprintf("💰 <b>내 정보</b>\n\n• 잔액: <b>%.3f USDT</b>", balance.Balance)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 메인 메뉴", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("잔액 메뉴 편집 실패: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("잔액 메뉴 전송 실패: %v", err)
		}
	}
}

func showOrderHistoryMenu(uid int64, chatID int64, msgID int) {
	// 최근 주문 10개 조회
	var orders []Order
	err := db.
		Where("user_id = ?", uid).
		Order("created_at DESC").
		Limit(10).
		Find(&orders).Error
	if err != nil {
		msg := tgbotapi.NewMessage(chatID, "❌ 주문 내역을 불러오지 못했습니다.")
		bot.Send(msg)
		return
	}

	if len(orders) == 0 {
		msg := tgbotapi.NewMessage(chatID, "최근 주문 내역이 없습니다.")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("🧾 <b>최근 주문 내역 (최대 10개)</b>\n\n")

	for _, order := range orders {
		var txid string
		switch v := any(order.TxID).(type) {
		case sql.NullString:
			if v.Valid {
				txid = v.String
			} else {
				txid = "-"
			}
		case *string:
			if v != nil && *v != "" {
				txid = *v
			} else {
				txid = "-"
			}
		case string:
			if v != "" {
				txid = v
			} else {
				txid = "-"
			}
		default:
			txid = "-"
		}

		sb.WriteString(fmt.Sprintf(
			"• <b>주문번호:</b> <code>%d</code>\n"+
				"  <b>상품명:</b> %s\n"+
				"  <b>금액:</b> %.3f USDT\n"+
				"  <b>상태:</b> %s\n"+
				"  <b>TXID:</b> %s\n"+
				"  <b>일시:</b> %s\n\n",
			order.ID,
			html.EscapeString(order.Product),
			order.Amount,
			order.Status,
			txid,
			order.CreatedAt.Format("2006-01-02 15:04"),
		))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

// 재고 추가 메뉴 예시
func showAdminAddStockMenu(uid, chatID int64, msgID int) {
	text := "🛠 재고 추가 메뉴입니다.\n아래 상품 ID를 선택하거나, '취소'를 입력하여 메뉴를 종료하세요."

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range productCategories {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(cat, "admin_cat_"+cat),
		))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("❌ 취소", "go_admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	bot.Send(msg)
}

// 특정 카테고리별 재고 보기
func showAdminCategoryStock(uid, chatID int64, msgID int, category string) {
	var stockList []Stock

	err := db.Where("category = ?", category).Find(&stockList).Error
	if err != nil {
		sendTelegram(chatID, "❌ 재고 조회 실패: "+err.Error())
		return
	}

	if len(stockList) == 0 {
		sendTelegram(chatID, "📂 '"+category+"' 카테고리에 재고가 없습니다.")
		return
	}

	text := fmt.Sprintf("📂 <b>%s</b> 카테고리 재고 목록:\n\n", category)
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, stock := range stockList {
		text += fmt.Sprintf("- %s (ID: %d)\n", stock.Code, stock.ID)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✏️ 수정", fmt.Sprintf("admin_edit_stock_%d", stock.ID)),
			tgbotapi.NewInlineKeyboardButtonData("🗑 삭제", fmt.Sprintf("admin_del_stock_%d", stock.ID)),
		))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 뒤로", "admin_inventory"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	bot.Send(msg)
}

// 재고 정리 예시
func cleanupStock(uid, chatID int64, msgID int) {
	// 예: DB에서 오래된 재고 자동 삭제, 중복 제거 등 로직 구현
	err := db.Exec("DELETE FROM stocks WHERE created_at < ?", time.Now().AddDate(0, -6, 0)).Error
	if err != nil {
		sendTelegram(chatID, "❌ 재고 정리 실패: "+err.Error())
		return
	}

	sendTelegram(chatID, "🧹 6개월 이상된 재고를 정리 완료했습니다.")
	showAdminAddStockMenu(uid, chatID, msgID)
}

func showAdminStockDetail(chatID int64, msgID int, productID int) {
	// DB에서 productID에 해당하는 상품 재고 상세 조회 후 메시지 편집 또는 새 메시지 전송
	// 예시: 재고 목록, 사용 여부, 코드 등 표시
	var stocks []Stock
	err := db.Where("product_id = ?", productID).Find(&stocks).Error
	if err != nil {
		sendTelegram(chatID, "❌ 상품 재고 정보를 불러올 수 없습니다.")
		return
	}
	text := fmt.Sprintf("📦 상품 ID %d 재고 상세\n\n", productID)
	for i, stock := range stocks {
		text += fmt.Sprintf("%d. 코드: <code>%s</code>, 사용 여부: %v\n", i+1, stock.Code, stock.Used)
		if i >= 20 {
			text += "...\n(더 많은 재고가 있습니다)\n"
			break
		}
	}
	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showAdminStockDetail] 메시지 전송 실패: %v", err)
	}
}

// 재고 수정 UI 보여주기
func showAdminEditStock(chatID int64, msgID int, stockID int) {
	// 재고 수정 UI 예시: 재고 상태 변경, 코드 수정 등
	// 실제 구현 시 메시지 편집 등 UI 처리 필요
	msgText := fmt.Sprintf("✏️ 재고 ID %d 수정 화면 (구현 필요)", stockID)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("[showAdminEditStock] 메시지 전송 실패: %v", err)
	}
}

// 재고 삭제 확인 및 삭제 처리 UI 보여주기
func promptConfirmDeleteStock(uid, chatID int64, msgID int, stockID int) {
	// 삭제 확인 버튼 표시
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✅ 삭제", fmt.Sprintf("confirm_del_stock_%d", stockID)),
			tgbotapi.NewInlineKeyboardButtonData("❌ 취소", "cancel"),
		),
	)
	text := fmt.Sprintf("❗️ 재고 ID %d 를 정말 삭제하시겠습니까?", stockID)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("[promptConfirmDeleteStock] 메시지 전송 실패: %v", err)
	}
}

func showAdminEditProduct(chatID int64, msgID int, productID int) {
	var prod Product
	err := db.First(&prod, productID).Error
	if err != nil {
		sendTelegram(chatID, "❌ 상품 정보를 불러올 수 없습니다.")
		return
	}

	text := fmt.Sprintf(
		"<b>상품 수정</b>\n\n"+
			"상품명: %s\n가격: %.2f USDT\n\n"+
			"새 이름과 가격을 '이름:가격' 형태로 입력하세요.\n"+
			"예시) 새로운상품명:9.99",
		prod.Name, prod.Price,
	)

	cancelKb := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("취소"),
			tgbotapi.NewKeyboardButton("나가기"),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = cancelKb
	bot.Send(msg)
}

func showAdminAddStock(uid, chatID int64, msgID int, productID int) {
	var prod Product
	err := db.First(&prod, productID).Error
	if err != nil {
		sendTelegram(chatID, "❌ 상품 정보를 불러올 수 없습니다.")
		return
	}

	text := fmt.Sprintf(
		"<b>재고 추가 - %s</b>\n\n"+
			"한 줄에 하나씩 재고 코드를 입력하세요.\n"+
			"입력 완료 시 '완료'를 입력해주세요.\n\n"+
			"예시:\n<code>ABC123\nDEF456\nGHI789</code>",
		prod.Name,
	)

	cancelKb := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("취소"),
			tgbotapi.NewKeyboardButton("나가기"),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = cancelKb

	bot.Send(msg)

	// 사용자별 대기 상태 저장
	pendingStockInput[uid] = strconv.Itoa(productID)
}

func isValidTronAddress(addr string) bool {
	return strings.HasPrefix(addr, "T") && len(addr) == 34
}

func showAddStockProductMenu(uid, chatID int64, msgID int, category string) {
	var products []Product
	db.Where("active = true").Joins("JOIN card_categories ON products.category_id = card_categories.id").
		Where("card_categories.name = ?", category).
		Find(&products)

	if len(products) == 0 {
		sendTelegram(chatID, "❌ 해당 카테고리에 등록된 상품이 없습니다.")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, prod := range products {
		cb := fmt.Sprintf("admin_stock_prod_%s_%d", category, prod.ID)
		btn := tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s (%.2f)", prod.Name, prod.Price), cb)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 카테고리 선택", "admin_add_stock"),
	))
	msg := tgbotapi.NewEditMessageText(chatID, msgID, "📦 상품을 선택하세요.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func showAddStockCategoryMenu(uid, chatID int64, msgID int) {
	// DB에서 활성화된 카테고리 조회
	var categories []CardCategory
	if err := db.Where("is_active = ?", true).Find(&categories).Error; err != nil {
		sendTelegram(chatID, "❌ 카테고리 조회 실패")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range categories {
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("📂 %s", cat.DisplayName),
			fmt.Sprintf("add_product_%s", cat.Name),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// 뒤로가기 버튼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, "📂 재고 추가 - 카테고리를 선택하세요.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func promptAddStock(uid, chatID int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}

	pendingStockInput[uid] = strconv.Itoa(productID)

	text := fmt.Sprintf(
		"<b>[%s]</b> 상품에 추가할 재고 코드를 한 줄에 하나씩 입력하세요.\n입력 완료 시 '완료'를 입력해주세요.\n\n"+
			"예시:\n<code>1234-5678-ABCD\nQWER-8888-ZXCV\nA1B2C3D4E5F6</code>\n\n(끝나면 '완료' 입력)",
		prod.Name,
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[promptAddStock] 메시지 전송 실패: %v", err)
	}
}

func isAdmin(uid int64) bool {
	adminIDs := strings.Split(os.Getenv("TELEGRAM_ADMIN_ID"), ",")
	for _, idStr := range adminIDs {
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err == nil && id == uid {
			return true
		}
	}
	return false
}

func completeStockInput(uid, chatID int64) {
	// 입력 대기 상태 종료
	delete(pendingStockInput, uid)

	// 메시지 삭제
	if msgID, ok := pendingStockInputMessageID[uid]; ok {
		err := deleteMessage(chatID, msgID)
		if err == nil {
			delete(pendingStockInputMessageID, uid)
		}
	}

	sendTelegram(uid, "✅ 재고 입력이 완료되었습니다.")
}

func deleteMessage(chatID int64, messageID int) error {
	delMsg := tgbotapi.NewDeleteMessage(chatID, messageID)
	_, err := bot.Request(delMsg)
	if err != nil {
		log.Printf("[deleteMessage] 메시지 삭제 실패: %v", err)
	}
	return err
}

func showProductListMenuByCategory(chatID int64, messageID int, category string) {
	var products []Product
	err := db.Where("category_id = ?", categoryMap[category]).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 해당 카테고리에 상품이 없습니다.")
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_stock_detail_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_inventory"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("📋 [%s] 상품 목록", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showAdminProductList(chatID int64, messageID int) {
	var products []Product
	if err := db.Find(&products).Error; err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 상품 조회 실패")
		bot.Send(msg)
		return
	}
	if len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❗️ 상품이 없습니다.")
		bot.Send(msg)
		return
	}

	rows := buildProductButtons(products)

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, "📦 상품 목록 (관리자)")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showUserGradeChangeMenu(chatID int64, msgID int, userID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🥉", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥈", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥇", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("💎", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_user_list"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, "변경할 등급을 선택하세요.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"
	bot.Send(edit)
}

func promptAddStockInput(uid int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}

	msgText := fmt.Sprintf("➕ 재고 추가 - 상품: <b>%s</b>\n\n재고 코드를 한 줄에 하나씩 입력해 주세요.\n완료 시 '완료'를 입력하거나 /cancel 명령어를 사용하세요.", prod.Name)
	sendTelegram(uid, msgText) // 수정된 부분

	pendingStockInput[uid] = strconv.Itoa(productID)
}

func showCleanupStockMenu(chatID int64, msgID int) {
	msgText := "🧹 재고 정리 기능입니다.\n필요한 작업을 선택하세요."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("사용된 재고 정리", "cleanup_used_stock"),
			tgbotapi.NewInlineKeyboardButtonData("오래된 재고 정리", "cleanup_old_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_stock"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	bot.Send(edit)
}

func handleCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil {
		return
	}
	uid := int64(cb.From.ID)

	var chatID int64
	var msgID int
	if cb.Message != nil {
		chatID = cb.Message.Chat.ID
		msgID = cb.Message.MessageID
	} else {
		// cb.Message가 없으면 기본값 0으로 두고 로그 출력
		log.Printf("[handleCallback] cb.Message가 nil입니다. cb.Data=%s", cb.Data)
		chatID = 0
		msgID = 0
	}

	data := cb.Data

	// 관리자 권한 필요 콜백 처리
	if isAdminRequired(data) && !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자 권한이 필요합니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	switch {
	case data == "admin_menu":
		showAdminMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 메뉴 표시"))
		return

	case data == "admin_list_visitors_today":
		visitors, err := getVisitorsByDate(time.Now())
		if err != nil {
			sendTelegram(uid, "방문자 조회 중 오류 발생")
			return
		}
		users := make([]User, len(visitors))
		for i, v := range visitors {
			userName := ""
			if v.UserName.Valid {
				userName = v.UserName.String
			}
			users[i] = User{
				UserID:   v.UserID,
				UserName: userName,
				Nickname: v.Nickname,
				LastSeen: v.LastSeen,
			}
		}
		msgText := formatUserListMessage(users, 1, 1)
		edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
		edit.ParseMode = "HTML"
		bot.Send(edit)
		bot.Request(tgbotapi.NewCallback(cb.ID, "당일 방문자 목록 표시"))
		return

	case strings.HasPrefix(data, "admin_all_users_page_"):
		pageStr := strings.TrimPrefix(data, "admin_all_users_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showAdminAllUsersMenu(chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("전체 유저 목록 페이지 %d", page)))
		return

	case data == "admin_all_users":
		showAdminAllUsersMenu(chatID, msgID, 1)
		bot.Request(tgbotapi.NewCallback(cb.ID, "전체 유저 목록 표시"))
		return

	case strings.HasPrefix(data, "admin_stock_"):
		handleAdminStockMenuCallbacks(cb)
		return

	case data == "admin_orders":
		showAdminOrdersMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "주문 내역 표시"))
		return

	case data == "tron_wallet_register":
		sendTelegram(uid, "TRON 지갑 주소를 입력해 주세요. 예: TXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
		pendingWalletInput[uid] = true
		bot.Request(tgbotapi.NewCallback(cb.ID, "지갑 주소 입력 대기 중"))
		return

	case data == "admin_member_menu":
		showAdminMemberMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 회원 목록 표시"))
		return

	case data == "admin_add_stock_category":
		showAddStockCategoryMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 추가 카테고리 메뉴 표시"))
		return

	case data == "admin_inventory":
		showAdminInventoryMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 메뉴 표시"))
		return

	case data == "admin_visitor_menu":
		showAdminVisitorMenu(chatID, msgID, cb.ID)
		return

	case data == "weekly_stats":
		showAdminStatsMenu(uid, chatID, msgID, "daily")
		bot.Request(tgbotapi.NewCallback(cb.ID, "통계 표시"))
		return

	case data == "handle_show_orders":
		showOrderHistoryMenu(uid, chatID, msgID)
		return

	case data == "admin_list_visitors":
		handleAdminListVisitors(uid)
		bot.Request(tgbotapi.NewCallback(cb.ID, "방문자 목록 표시"))
		return

	case data == "menu_help":
		kb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" 🪫 ENERGY ", "help_energy"),
				tgbotapi.NewInlineKeyboardButtonData(" 🆔 ACCOUNT ", "help_account"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" 👥 MEMBERS ", "help_membership"),
				tgbotapi.NewInlineKeyboardButtonData(" 📱 ESIM ", "help_esim"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" 🖥️ VPS ", "help_vps"),
				tgbotapi.NewInlineKeyboardButtonData(" 💳 CARD ", "help_card"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" 🔄 SWAP ", "help_swap"),
				tgbotapi.NewInlineKeyboardButtonData(" 🔙 ", "go_main"),
			),
		)
		msg := tgbotapi.NewEditMessageText(chatID, msgID, "ℹ️ 사용방법 안내\n도움이 필요한 항목을 선택하세요.")
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = &kb
		bot.Send(msg)
		return

	case data == "go_main":
		// 기존 메시지 삭제
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("기존 메시지 삭제 실패: %v", err)
			}
		}
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
		return

	case data == "show_balance":
		showBalanceMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "내 정보 메뉴 표시"))
		return

	case data == "go_catmenu":
		if msgID != 0 {
			delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("이전 메시지 삭제 실패: %v", err)
			}
		}
		showCategoryMenu(uid, chatID, 0)
		bot.Request(tgbotapi.NewCallback(cb.ID, "카테고리 메뉴로 이동"))
		return

	case data == "menu_vps":
		showVPSMenu(uid, chatID, msgID)
		return

	case data == "admin_stock":
		showAdminStockMenuSimple(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 메뉴를 불러옵니다"))
		return

	case data == "cancel_pending_add":
		delete(pendingEditProduct, uid)
		delete(pendingStockInput, uid)
		sendTelegram(uid, "❌ 작업이 취소되었습니다.")
		showCategoryMenu(uid, chatID, 0)
		return

	case data == "admin_add_stock":
		showAdminAddStockMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 추가 메뉴 열기"))
		return

	case strings.HasPrefix(data, "admin_cat_"):
		category := strings.TrimPrefix(data, "admin_cat_")
		showAdminCategoryStock(uid, chatID, msgID, category)
		bot.Request(tgbotapi.NewCallback(cb.ID, "카테고리 재고 보기"))
		return

	case data == "admin_cleanup_stock":
		cleanupStock(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 정리 시작"))
		return

	case data == "check_wallet":
		wallet := getUserWallet(uid)
		if wallet == "" {
			sendTelegram(uid, "❌ 등록된 지갑이 없습니다.")
			return
		}
		sendTelegram(uid, fmt.Sprintf("지갑 주소: <code>%s</code>", wallet))
		return

	case data == "admin_today_visitors":
		showTodayVisitorsMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "오늘 방문자 표시"))
		return

	case data == "admin_stock_menu":
		showAdminStockMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 관리"))
		return

	case data == "admin_all_visitors":
		showAllVisitorsMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "전체 방문자 표시"))
		return

	case data == "admin_all_users":
		showAdminAllUsersMenu(chatID, msgID, 1)
		bot.Request(tgbotapi.NewCallback(cb.ID, "전체 유저 표시"))
		return

	case data == "admin_advanced":
		showAdvancedAdminMenu(uid, chatID, int64(msgID))
		bot.Request(tgbotapi.NewCallback(cb.ID, "고급 관리자 메뉴"))
		return

	case data == "admin_system_health":
		showSystemHealthMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "시스템 상태 표시"))
		return

	case data == "deposit_custom":
		pendingDepositInput[uid] = true
		sendTelegram(uid, "원하는 USDT 금액을 숫자로 입력해 주세요 (예: 23.5)")
		bot.Send(tgbotapi.NewCallback(cb.ID, "직접입력 대기중"))
		return

	case strings.HasPrefix(data, "visitor_page_"):
		pageStr := strings.TrimPrefix(data, "visitor_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, "페이지 이동"))
		return

	case strings.HasPrefix(data, "deposit_amount_"):
		amountStr := strings.TrimPrefix(data, "deposit_amount_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(chatID, "❌ 금액 파싱 실패")
			return
		}
		pendingDepositInput[uid] = false
		err = createDepositOrder(uid, amount)
		if err != nil {
			sendTelegram(chatID, "❌ 충전 주문 생성 실패")
			return
		}
		sendTelegram(chatID, fmt.Sprintf("✅ %.2f USDT 충전 주문이 생성되었습니다.", amount))
		return

	case strings.HasPrefix(data, "deposit_"):
		amountStr := strings.TrimPrefix(data, "deposit_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(chatID, "❌ 잘못된 입금 금액입니다.")
			return
		}
		showDepositAddress(uid, chatID, msgID, amount)
		bot.Request(tgbotapi.NewCallback(cb.ID, "입금 안내 표시"))
		return

	case strings.HasPrefix(data, "admin_set_grade_"):
		parts := strings.Split(data, "_")
		if len(parts) < 5 {
			sendTelegram(uid, "❌ 잘못된 등급 변경 콜백")
			return
		}
		userID, err := strconv.ParseInt(parts[3], 10, 64)
		if err != nil {
			sendTelegram(uid, "❌ 잘못된 유저 ID")
			return
		}
		grade := parts[4]

		if err := updateUserGrade(userID, grade); err != nil {
			sendTelegram(uid, "❌ 등급 변경에 실패했습니다.")
			return
		}

		sendTelegram(userID, fmt.Sprintf("등급이 '%s'로 변경되었습니다.", grade))
		bot.Request(tgbotapi.NewCallback(cb.ID, "등급 변경 완료"))
		return

	case strings.HasPrefix(data, "verify_"):
		handleVerificationResponse(cb)
		return

	case data == "menu_products":
		log.Printf("[handleCallback] menu_products 콜백 처리 시작")
		showCategoryMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "상품 목록 표시"))
		log.Printf("[handleCallback] menu_products 콜백 처리 완료")
		return

	case data == "admin_user_list":
		showAdminUserListMenu(chatID, msgID)
		return

	case strings.HasPrefix(data, "support_accept_"):
		targetUIDStr := strings.TrimPrefix(data, "support_accept_")
		targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "❌ 상담 대상자 ID 파싱 실패")
			return
		}

		// 상담원과 유저 연결 세션 저장
		activeSupportSessions[targetUID] = uid

		// 상담 종료 버튼 키보드 (유저용)
		userCloseKb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔚 상담종료", fmt.Sprintf("support_close_%d", uid)),
			),
		)
		// 상담 종료 버튼 키보드 (상담원용)
		adminCloseKb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔚 상담종료", fmt.Sprintf("support_close_%d", targetUID)),
			),
		)

		// 유저에게 상담 시작 메시지 전송
		userMsg := tgbotapi.NewMessage(targetUID,
			"✅ 상담원이 연결되었습니다! 궁금한 내용을 메시지로 보내주세요.\n\n상담이 끝나면 하단의 [상담종료] 버튼을 눌러주세요.")
		userMsg.ReplyMarkup = userCloseKb
		bot.Send(userMsg)
		// 상담원에게 상담 시작 메시지 전송
		adminMsg := tgbotapi.NewMessage(uid,
			"🙋‍♂️ 상담이 시작되었습니다. 유저에게 답변해 주세요.\n\n상담이 끝나면 [상담종료]를 꼭 눌러주세요.")
		adminMsg.ReplyMarkup = adminCloseKb
		bot.Send(adminMsg)

		// 콜백 응답
		bot.Request(tgbotapi.NewCallback(cb.ID, "상담이 시작되었습니다."))
		return

	case strings.HasPrefix(data, "del_stock_"):
		handleDeleteStockCategory(cb)
		return

	case strings.HasPrefix(data, "confirm_del_"):
		handleConfirmDeleteStock(cb)
		return

	case strings.HasPrefix(data, "confirm_deposit_"), strings.HasPrefix(data, "deposit_"):
		handleDepositCallbacks(cb)
		return

	case strings.HasPrefix(data, "userlist_page_"):
		pageStr := strings.TrimPrefix(data, "userlist_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil {
			return
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, "페이지 이동"))
		return

	case strings.HasPrefix(data, "lang_"):
		handleLanguageSelection(cb)
		return

	case strings.HasPrefix(data, "prod_"):
		productCode := strings.TrimPrefix(data, "prod_")
		parts := strings.SplitN(data, "_", 3)
		category := ""
		if len(parts) >= 3 {
			category = parts[1]
			productCode = parts[2]
		}
		handleProductSelection(uid, chatID, msgID, productCode, category)
		return

	case strings.HasPrefix(data, "help_"):
		showHelpMessage(uid, data)
		return

	case strings.HasPrefix(data, "cardcat_"):
		category := strings.TrimPrefix(data, "cardcat_")
		log.Printf("cardcat 콜백 category: %s", category)
		category = strings.ToUpper(category) // 또는 필요시 소문자화

		productsSlice, err := getProductsByCategory(db, category)
		if err != nil || len(productsSlice) == 0 {
			log.Printf("카테고리 %s 상품 없음 또는 조회 오류: %v", category, err)
			sendTelegram(chatID, "❌ 해당 카테고리의 상품이 없습니다.")
			return
		}

		productsMap := make(map[string]Product)
		for _, p := range productsSlice {
			productsMap[p.Name] = p
		}

		showProductMenu(category, chatID, msgID, productsMap)
		bot.Request(tgbotapi.NewCallback(cb.ID, "상품 목록 표시"))
		return

	case strings.HasPrefix(data, "pay_balance_"):
		orderIDStr := strings.TrimPrefix(data, "pay_balance_")
		orderID64, err := strconv.ParseUint(orderIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "❌ 주문번호 파싱 실패")
			return
		}
		orderID := uint(orderID64)
		err = handleBalancePayment(orderID, uid)
		if err != nil {
			sendTelegram(uid, "❌ 잔액 결제 실패: "+err.Error())
		} else {
			sendTelegram(uid, "✅ 잔액 결제가 완료되었습니다.")
		}
		bot.Request(tgbotapi.NewCallback(cb.ID, "잔액 결제 처리 중"))
		return

	case strings.HasPrefix(data, "support_close_"):
		targetUIDStr := strings.TrimPrefix(data, "support_close_")
		targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "❌ 상담 대상자 ID 파싱 실패")
			return
		}

		// 상담 세션 삭제: 유저와 상담원 모두 제거
		delete(activeSupportSessions, targetUID)
		for userID, adminID := range activeSupportSessions {
			if adminID == targetUID {
				delete(activeSupportSessions, userID)
			}
		}

		// 종료 메시지 전송 (유저 및 상담원)
		sendTelegram(targetUID, "상담이 종료되었습니다. 언제든 다시 문의해 주세요.")
		sendTelegram(uid, "상담이 종료되었습니다.")

		// 관리자(전체)에게도 알림 보내기 (필요 시)
		for _, adminID := range adminIDs {
			sendTelegram(int64(adminID), fmt.Sprintf("유저 %d의 상담이 종료되었습니다.", targetUID))
		}

		bot.Request(tgbotapi.NewCallback(cb.ID, "상담이 종료되었습니다."))
		return

	default:
		log.Printf("[handleCallback] 알 수 없는 콜백 데이터: %s", data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "❓ 알 수 없는 동작입니다."))
	}
}

func isAdminRequired(data string) bool {
	adminCallbacks := []string{
		"admin_menu",
		"admin_list_visitors",
		"admin_list_stock",
		"admin_add_admin",
		"admin_cancel_order",
		"admin_cat_",
		"admin_product_",
		"admin_edit_product_",
		"admin_add_stock_",
		"admin_user_detail_",
		"admin_today_visitors",
		"admin_stock_menu",
		"admin_all_visitors",
		"admin_all_users",
		"admin_advanced",
		"admin_system_health",
		"admin_set_grade_",
		"admin_user_list",
	}

	for _, prefix := range adminCallbacks {
		if strings.HasPrefix(data, prefix) {
			return true
		}
	}
	return false
}

func handleAddStockCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있습니다.")
		return
	}

	// 관리자에게 카테고리 선택 메뉴 띄우기 등 재고 추가 안내 메시지
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("MEMBERSHIP", "admin_add_stock_category_membership"),
			tgbotapi.NewInlineKeyboardButtonData("ESIM", "admin_add_stock_category_esim"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("CARD", "admin_add_stock_category_card"),
			tgbotapi.NewInlineKeyboardButtonData("ACCOUNT", "admin_add_stock_category_account"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("취소", "cancel_pending_add"),
		),
	)

	msgText := "✅ 재고를 추가할 카테고리를 선택하세요."
	message := tgbotapi.NewMessage(uid, msgText)
	message.ReplyMarkup = kb
	bot.Send(message)
}

// 총 페이지 수 계산 함수 (10명 단위)
func getTotalVisitorPages() int {
	var total int64
	err := db.Model(&User{}).Count(&total).Error
	if err != nil || total == 0 {
		return 1
	}
	return int((total + 9) / 10) // 올림
}

// 방문자 목록 조회 함수 (페이징 포함)
func getVisitors(page, pageSize int) ([]User, int64, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	err := db.Order("last_seen DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&users).Error
	return users, total, err
}

func initCardCategoriesMap() error {
	var categories []CardCategory
	if err := db.Where("is_active = ?", true).Find(&categories).Error; err != nil {
		return err
	}

	for _, cat := range categories {
		var products []Product
		if err := db.Where("category_id = ? AND active = ?", cat.ID, true).Find(&products).Error; err != nil {
			log.Printf("❌ [%s] 상품 로딩 실패: %v", cat.Name, err)
			continue
		}
		tmp := map[string]Product{}
		for _, p := range products {
			tmp[p.Name] = p
		}
		cardCategories[cat.Name] = tmp
	}
	return nil
}

func formatVisitorListNoNickname(visitors []Visitor) string {
	var sb strings.Builder
	sb.WriteString("<b>👥 방문자 목록</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, v := range visitors {
		username := "없음"
		if v.UserName.Valid && v.UserName.String != "" {
			username = "@" + v.UserName.String
		}
		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <i>%s</i>\n\n",
			i+1, v.UserID, username,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")
	sb.WriteString("🔍 누군지 바로 알 수 있도록 아이디 표시\n")

	return sb.String()
}

func createOrderAndPromptPayment(uid int64, chatID int64, productCode string) error {
	// 1. 상품명과 가격 조회
	var prodName string
	var basePrice float64
	found := false
	for _, cats := range cardCategories {
		for name, prod := range cats {
			if prod.Code == productCode {
				prodName = name
				basePrice = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}
	if !found {
		sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
		return fmt.Errorf("상품 없음")
	}

	// 2. 주문 생성 (초기 상태: 입금대기중)
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      basePrice,
		ExpectedAmt: basePrice,
		Status:      "입금대기중",
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("주문 생성 실패: %v", err)
		return err
	}

	// 3. 주문 ID 기반 고유 결제금액 계산 (소수점 3자리)
	uniqueAmt := toFixed3(basePrice + float64(order.ID)/1000.0)
	order.Amount = uniqueAmt
	order.ExpectedAmt = uniqueAmt
	if err := db.Save(&order).Error; err != nil {
		log.Printf("주문 금액 업데이트 실패: %v", err)
		return err
	}

	// 4. 결제 안내 및 QR 코드 생성 등을 handleCoinPaymentUnified로 처리
	handleCoinPaymentUnified(nil, uid, chatID, uint64(order.ID))

	return nil
}

func showCategoryMenu(uid, chatID int64, messageID int) {
	if messageID > 0 {
		delMsg := tgbotapi.NewDeleteMessage(chatID, messageID)
		if _, err := bot.Send(delMsg); err != nil {
			log.Printf("[showCategoryMenu] 기존 메시지 삭제 실패: %v", err)
		}
	}

	categories, err := getCardCategoriesFromDB()
	if err != nil || len(categories) == 0 {
		sendTelegram(chatID, "❌ 카테고리 불러오기 실패")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	for _, cat := range categories {
		display := cat.DisplayName
		if display == "" {
			display = cat.Name
		}
		btn := tgbotapi.NewInlineKeyboardButtonData("📂 "+display, "cardcat_"+cat.Name)
		currentRow = append(currentRow, btn)
		count++
		if count%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
	))

	msg := tgbotapi.NewMessage(chatID, "📦 <b>카테고리를 선택하세요</b>\n(원하시는 상품 분류를 골라주세요)")
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showCategoryMenu] 메시지 전송 실패: %v", err)
	}
}

func checkDepositMatch(senderAddress string, amount float64) (*Order, error) {
	var order Order
	err := db.Where("sender_address = ? AND status = ?", senderAddress, "pending").First(&order).Error
	if err != nil {
		return nil, err
	}
	return &order, nil
}

func formatVisitorList(users []User) string {
	var sb strings.Builder
	sb.WriteString("<b>👥 방문자 목록</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}

		nickname := u.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n\n",
			i+1, u.UserID, nickname, username,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")
	sb.WriteString("🔍 누군지 바로 알 수 있도록 닉네임과 아이디 표시\n")

	return sb.String()
}

// showHelpMessage 함수 (수정본)
func showHelpMessage(uid int64, data string) {
	switch data {
	case "help_account":
		msg := tgbotapi.NewMessage(uid,
			"🆔 <b>(ACCOUNT) 상품 안내</b>\n\n"+
				"결제 확인 후, <b>자동</b> 메세지로 지급됩니다.\n"+
				"<b>번호 | link</b> 형식으로 발송되며 로그인 🔜 link 🔜 2FA 확인\n"+
				"・<i>EX: <a href=\"https://t.me/EX_TGID\">짧은번호</a> 포커문의</i>\n"+
				"<i>PC 및 모바일 모두 가능합니다.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_account 전송 실패: %v", err)
		}

	case "help_membership":
		msg := tgbotapi.NewMessage(uid,
			"👥 <b>(MEMBERSHIP) 안내</b>\n\n"+
				"・ 결제 후 별도 등록 없이 <b>즉시 선물</b>로 전송됩니다.\n"+
				"・ 각 플랫폼 사용법은 메세지와 함께 안내됩니다.\n"+
				"・ <i>문의 사항은 고객센터로 연락 주세요.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_membership 전송 실패: %v", err)
		}

	case "help_esim":
		photoFile := "/home/minho/epusdt/images/esim_usage.jpeg" // 절대경로
		photoMsg := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(photoFile))
		photoMsg.Caption = "📱 <b>(E-SIM) 안내</b>\n\n" +
			"・ DATA ONLY, 5G/4G 걱정X\n" +
			"・ 결제 후 QR코드 정보가 자동 지급됩니다.\n" +
			"・ 위치 조회시 홍콩 홍콩번호 부여.\n"
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("help_esim 사진 전송 실패: %v", err)
			sendTelegram(uid, "❌ eSIM 안내 이미지 전송에 실패했습니다.")
		}

	case "help_energy":
		msgText := `<b>🪫 USDT 송금 수수료 80% 절감 🪫</b>
	
	💸 전송 1회당 수수료 최대 만원 절감
	
	📊 평균 테더 100회 송금 시 트론 소비량 비교
	
	🔹 일반 송금: 최소 1,800 ~ 2,800 TRX   
	🔹 에너지 송금: 최소 250 ~ 500 TRX
	
	<b>KRW 기준</b>
	일반송금 : 670,000 ~ 1,036,000
	에너지송금 : 92,500 ~ 185,000
	
	1회 전송에 필요한 에너지 = 65K 에너지
	
	65K 에너지 = 2.5 TRX (전송 1회)  
	예: 10 TRX = 260K 에너지 (3~4회)
	
	⏱ 전송한 주소로 5초 이내 에너지 할당 완료
	
	━━━━━━━━━━━━━━━
	
	⬇️ <b>결제 주소</b> ⬇️
	
	<b><code>TDFfEdkdkdkdososlsksospzkPn</code></b>
	
	⬆️ 주소 클릭 시 자동 복사 ⬆️
	
	━━━━━━━━━━━━━━━
	
	⏳ 에너지는 1시간 후 자동 소멸  
	⚠️ USDT가 없는 새 지갑으로 송금 시  
	130K 에너지(5 TRX) 발생 가능  
	송금 전 수수료 꼭 확인`

		msg := tgbotapi.NewMessage(uid, msgText)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_energy 전송 실패: %v", err)
		}

	case "help_card":
		msg := tgbotapi.NewMessage(uid,
			"💳 <b>(CARD) 결제 안내</b>\n\n"+
				"・ 대리 및 VPN 결제가 가능합니다.\n"+
				"・ 구매 후 '고객센터' 버튼을 눌러 문의해 주세요.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_card 전송 실패: %v", err)
		}

	case "help_swap":
		msg := tgbotapi.NewMessage(uid,
			"🔄 <b>스왑 안내</b>\n\n"+
				"코인 스왑 잠시 점검 중입니다.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_swap 전송 실패: %v", err)
		}

	case "help_vps":
		msg := tgbotapi.NewMessage(uid,
			"🖥️ <b>VPS/KVM 안내</b>\n\n"+
				"여러 가지 VPS 및 KVM 서버 옵션을 제공합니다.\n"+
				"더 자세한 내용은 제품 목록에서 확인하세요.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_vps 전송 실패: %v", err)
		}

	default:
		msg := tgbotapi.NewMessage(uid,
			"❓ 해당 도움말이 존재하지 않습니다.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_default 전송 실패: %v", err)
		}
	}
}

func handleBalancePayment(orderID uint, userID int64) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("주문 조회 실패: %w", err)
	}

	if order.Status != "입금대기중" {
		return fmt.Errorf("잘못된 주문 상태: %s", order.Status)
	}

	balance, err := getUserBalance(userID)
	if err != nil {
		return fmt.Errorf("잔액 조회 실패: %w", err)
	}
	if balance < order.Amount {
		return fmt.Errorf("잔액 부족 (보유: %.2f, 필요: %.2f)", balance, order.Amount)
	}

	// 트랜잭션 처리 권장 (아래는 단순 예시)
	if err := deductBalance(userID, order.Amount); err != nil {
		return fmt.Errorf("잔액 차감 실패: %w", err)
	}

	order.Status = "완료"
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("주문 상태 저장 실패: %w", err)
	}

	// 관리자 알림
	adminChatID := getAdminChatID()
	adminMsg := fmt.Sprintf(
		"💳 잔액 결제 완료\n주문번호: %d\n사용자ID: %d\n금액: %.2f USDT",
		order.ID, userID, order.Amount)
	if _, err := bot.Send(tgbotapi.NewMessage(adminChatID, adminMsg)); err != nil {
		log.Printf("관리자 알림 실패: %v", err)
	}

	// 유저 알림
	sendTelegram(userID, fmt.Sprintf(
		"✅ 잔액 결제가 완료되었습니다.\n주문번호: %d\n금액: %.2f USDT",
		order.ID, order.Amount,
	))

	return nil
}

func handleMenuCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleMenuCallback] cb.Data: %s", cb.Data)
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	switch cb.Data {
	case "menu_products":
		showCategoryMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "🛒 상품 목록을 불러옵니다"))
		return

	case "menu_swap":
		showSwapMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "🔄 코인 교환"))
		return

	case "admin_monthly_report":
		handleAdminMonthlyReport(uid, chatID, messageID, cb.ID)
		return

	case "admin_yearly_report":
		handleAdminYearlyReport(uid, chatID, messageID, cb.ID)
		return

	case "go_main":
		// 기존 메시지 삭제
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(cb.Message.Chat.ID, cb.Message.MessageID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("[go_main] 기존 메시지 삭제 실패: %v", err)
			}
		}

		// 새 메뉴 출력
		showMenu(uid, cb.From.UserName, cb.Message.Chat.ID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
		return

	default:
		log.Printf("[handleMenuCallback] 알 수 없는 메뉴: %s", cb.Data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "❓ 알 수 없는 메뉴입니다"))
		return
	}
}

func getStockCount(productName string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).
		Where("name = ? AND used = ?", productName, false).
		Count(&count).Error
	if err != nil {
		return 0, err
	}
	return count, nil
}

func showSwapMenu(uid, chatID int64, messageID int) {
	swapPairs := []struct {
		display string
		data    string
	}{
		{"USDT → TRX", "swap_usdt_trx"},
		{"TRX → USDT", "swap_trx_usdt"},
		{"USDT → ETH", "swap_usdt_eth"},
		{"ETH → USDT", "swap_eth_usdt"},
		{"USDT → SOL", "swap_usdt_sol"},
		{"SOL → USDT", "swap_sol_usdt"},
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(swapPairs); i += 2 {
		var row []tgbotapi.InlineKeyboardButton
		row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i].display, swapPairs[i].data))
		if i+1 < len(swapPairs) {
			row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i+1].display, swapPairs[i+1].data))
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// 마지막 한 줄은 메뉴로 가기 버튼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "🔄 코인 스왑 메뉴\n 변경할 코인을 선택하세요.[점검]")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showSwapMenu 메시지 전송 실패: %v", err)
	}
}

// 상품 콜백 처리
func handleProductCallback(cb *tgbotapi.CallbackQuery) {
	data := cb.Data // 예: "prod_vps1"
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID

	code := strings.TrimPrefix(data, "prod_")

	for _, category := range cardCategories {
		for name, prod := range category {
			if prod.Code == code {
				text := fmt.Sprintf("<b>%s</b>\n\n%s\n\n💰 가격: %.2f USDT", name, prod.Description, prod.Price)
				edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
				edit.ParseMode = "HTML"
				bot.Send(edit)

				// 확인 버튼 보여주기
				showOrderConfirmButtons(cb, code)
				return
			}
		}
	}

	bot.Send(tgbotapi.NewMessage(chatID, "❌ 상품을 찾을 수 없습니다."))
}

func showOrderConfirmButtons(cb *tgbotapi.CallbackQuery, productCode string) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	var prodName string
	var price float64
	found := false

	// VPS 상품인지 먼저 체크
	if vpsProd, ok := vpsProductMap[productCode]; ok {
		prodName = vpsProd.Name
		price = vpsProd.Price
		found = true
	} else {
		// 일반 카드 상품에서 찾기
		for _, products := range cardCategories {
			for _, prod := range products {
				if prod.Code == productCode {
					prodName = prod.Name
					price = prod.Price
					found = true
					break
				}
			}
			if found {
				break
			}
		}
	}

	if !found {
		sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
		callback := tgbotapi.NewCallback(cb.ID, "상품 정보 없음")
		bot.Request(callback)
		return
	}

	// 주문 생성
	order, err := createOrder(uid, prodName, price)
	if err != nil {
		sendTelegram(uid, "❌ 주문 생성 실패: "+err.Error())
		return
	}

	// 메시지 텍스트 구성
	msgText := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🛒 <b>%s</b>\n"+
			"💰 가격: <b>%.3f USDT</b>\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"<b>결제수단을 선택해 주세요.</b>\n",
		prodName, price,
	)

	// 인라인 버튼 구성
	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("💸 코인 결제", fmt.Sprintf("pay_coin_%d", order.ID)),
			tgbotapi.NewInlineKeyboardButtonData("🏦 잔액 결제", fmt.Sprintf("pay_balance_%d", order.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	// 메시지 수정 및 전송
	edt := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, markup)
	edt.ParseMode = "HTML"
	if _, err := bot.Send(edt); err != nil {
		log.Printf("❌ 주문 확인 버튼 표시 실패: %v", err)
	}
}

func main() {
	var err error
	db, err = initDB()
	if err != nil {
		log.Fatalf("초기화 실패: %v", err)
	}

	if err := migrateDB(db); err != nil {
		log.Fatalf("마이그레이션 실패: %v", err)
	}

	err = addProductsByCategory(db, map[string][]Product{
		"VPS": {
			{Code: "vps1", Name: "KVM - E1", Description: "CPU: 4코어, RAM: 4GB, 저장공간: 100GB NVMe", Price: 70, Active: true},
			{Code: "vps2", Name: "KVM - E2", Description: "CPU: 4코어, RAM: 6GB, 저장공간: 140GB NVMe", Price: 90, Active: true},
			{Code: "vps3", Name: "KVM - T1", Description: "CPU: 8코어, RAM: 16GB, 저장공간: 160GB NVMe", Price: 120, Active: true},
			{Code: "vps4", Name: "KVM - T2", Description: "CPU: 12코어, RAM: 24GB, 저장공간: 256GB NVMe", Price: 150, Active: true},
			{Code: "vps5", Name: "맞춤 제작", Description: "맞춤형 사양 제공, 문의 후 견적 안내", Price: 1, Active: true},
		},
		"ACCOUNT": {
			{Code: "tgid1", Name: "TG 1년", Price: 8, Active: true},
			{Code: "tgid2", Name: "TG 2년", Price: 20, Active: true},
			{Code: "tgid3", Name: "짧은 번호", Price: 60, Active: true},
		},
		"MEMBERSHIP": {
			{Code: "tp3", Name: "TG 프리미엄 3개월", Price: 17, Active: true},
			{Code: "tp12", Name: "TG 프리미엄 1년", Price: 45, Active: true},
			{Code: "yp12", Name: "YT 프리미엄 1년", Price: 60, Active: true},
		},
		"ESIM": {
			{Code: "es1", Name: "DATA 30 DAY", Price: 70, Active: true},
			{Code: "es2", Name: "KOREA|HK", Price: 999, Active: true},
			{Code: "es3", Name: "NO KYC", Price: 999, Active: true},
		},
		"CARD": {
			{Code: "card1", Name: "국내결제", Price: 10, Active: true},
			{Code: "card2", Name: "국외결제", Price: 10, Active: true},
			{Code: "card3", Name: "항공권", Price: 10, Active: true},
		},
	})
	if err != nil {
		log.Fatalf("상품 등록 실패: %v", err)
	} else {
		log.Println("✅ 전체 상품 등록 완료")
	}

	log.Println("✅ 초기화 완료")
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	rand.Seed(time.Now().UnixNano())
	log.Println("🚀 EPUSDT 봇 시작 중...")

	startTime := time.Now()

	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		log.Fatal("❌ TELEGRAM_BOT_TOKEN 환경변수가 설정되지 않았습니다.")
	}
	log.Printf("🔍 로드된 토큰: %s", token)

	startDepositMonitoring()

	bot, err = initBotWithWebhook()
	if err != nil {
		log.Fatalf("❌ 봇 초기화 실패: %v", err)
	}
	log.Println("✅ 봇 초기화 완료")

	router := gin.Default()
	router.SetTrustedProxies(nil)
	router.POST("/webhook", handleWebhook)
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok", "uptime": time.Since(startTime).String()})
	})

	log.Println("🌐 서버를 9020 포트에서 시작합니다...")
	if err := router.Run(":9020"); err != nil {
		log.Fatalf("❌ 서버 실행 실패: %v", err)
	}
}

// 문자열 포인터 생성 함수
func ptr(s string) *string {
	sCopy := s
	return &sCopy
}

func createOrder(uid int64, prodName string, price float64) (*Order, error) {
	emptyTxID := "" // 빈 문자열 변수 선언
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "입금대기중",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        &emptyTxID, // 빈 문자열 포인터 전달
	}
	if err := db.Create(&order).Error; err != nil {
		return nil, err
	}
	return &order, nil
}

func confirmDeposit(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return err
	}

	// 주문 상태 업데이트
	order.Status = "입금확인"
	txIDCopy := txID
	order.TxID = &txIDCopy

	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// 카드 자동 지급 부분 제거됨
	// 카드 정보 업데이트는 필요에 따라 직접 처리하세요
	// 예를 들어, 카드 정보 없이 상태만 완료 처리할 경우:

	order.Status = "완료"
	if err := db.Save(&order).Error; err != nil {
		return err
	}
	if err := addVPSProducts(); err != nil {
		log.Fatalf("VPS 상품 등록 실패: %v", err)
	}
	// 사용자에게 알림 (에러 로그만 남기고 리턴은 안함)
	if err := sendTelegram(order.UserID, fmt.Sprintf("✅ 주문이 완료되었습니다!\n\n상품: %s\n", order.Product)); err != nil {
		log.Printf("사용자 알림 전송 실패: %v", err)
	}

	return nil
}

// 잔액 확인
func getUserBalance(userID int64) (float64, error) {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// 잔액이 없으면 0으로 초기화
			balance = UserBalance{UserID: userID, Balance: 0}
			db.Create(&balance)
			return 0, nil
		}
		return 0, err
	}
	return balance.Balance, nil
}

// 잔액 차감
func deductBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		return err
	}

	if balance.Balance < amount {
		return fmt.Errorf("잔액 부족")
	}

	balance.Balance -= amount
	return db.Save(&balance).Error
}

// 잔액 추가
func addBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance = UserBalance{UserID: userID, Balance: amount}
			return db.Create(&balance).Error
		}
		return err
	}

	balance.Balance += amount
	return db.Save(&balance).Error
}

// 주문 내역 조회
func getUserOrders(userID int64) ([]Order, error) {
	var orders []Order
	err := db.Where("user_id = ?", userID).Order("timestamp desc").Find(&orders).Error
	return orders, err
}

// 주문 상태 업데이트
func updateOrderStatus(orderID uint, status string) error {
	return db.Model(&Order{}).Where("id = ?", orderID).Update("status", status).Error
}

// 카드 재고 확인
func getCardStock(category string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).Where("category = ? AND used = ?", category, false).Count(&count).Error
	return count, err
}

// 사용된 카드 조회
func getUsedCards(userID int64) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("used_by = ?", userID).Find(&cards).Error
	return cards, err
}

// 통계 데이터 조회
func updateDailyStats(amount float64) error {
	today := time.Now().Format("2006-01-02")

	var stats SalesStats
	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: amount, TotalCount: 1, Count: 1, SalesCount: 1}
			return db.Create(&stats).Error
		}
		return err
	}

	stats.TotalSales += amount
	stats.TotalCount++
	stats.Count++
	stats.SalesCount++

	return db.Save(&stats).Error
}

func handleCreateTransaction(c *gin.Context) {
	var req struct {
		UserID      int64   `json:"user_id"`
		ProductCode string  `json:"product_code"`
		Amount      float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "잘못된 요청"})
		return
	}

	// 주문 생성
	order, err := createOrder(req.UserID, req.ProductCode, req.Amount)
	if err != nil {
		c.JSON(500, gin.H{"error": "주문 생성 실패"})
		return
	}

	// 지갑 주소 생성
	walletAddress, err := generateWalletAddress()
	if err != nil {
		c.JSON(500, gin.H{"error": "지갑 생성 실패"})
		return
	}

	c.JSON(200, gin.H{
		"order_id": order.ID,
		"address":  walletAddress,
		"amount":   req.Amount,
	})
}

func showAdminStockMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	text := "📦 재고 현황\n\n"
	totalStock := int64(0)

	for _, category := range categories {
		count, err := getCardStock(category)
		if err != nil {
			text += fmt.Sprintf("❌ %s: 조회 실패\n", category)
		} else {
			text += fmt.Sprintf("✅ %s: %d개\n", category, count)
			totalStock += count
		}
	}

	text += fmt.Sprintf("\n📊 총 재고: %d개", totalStock)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📋 상세보기", "admin_stock_detail"),
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", "admin_add_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🗑️ 재고삭제", "admin_del_stock"),
			tgbotapi.NewInlineKeyboardButtonData("📊 분석", "admin_stock_analytics"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자메뉴", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 재고 메뉴 수정 실패: %v", err)
	}
}

func createProductManagementKeyboard(productID int, productName string, price float64) tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s %.2fUSDT", productName, price), fmt.Sprintf("product_detail_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📝 수정", fmt.Sprintf("product_edit_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("🗑️ 삭제", fmt.Sprintf("product_delete_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("📦 재고", fmt.Sprintf("product_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", fmt.Sprintf("product_add_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자메뉴로", "admin_menu"),
		),
	)
}

func showProductListForCategory(uid, chatID int64, messageID int, category string) {
	products, err := getProductsByCategory(db, category)
	if err != nil {
		sendTelegram(uid, "❌ 상품 목록 조회 실패")
		return
	}

	text := fmt.Sprintf("📋 %s 상품 목록\n\n", category)
	for i, p := range products {
		text += fmt.Sprintf("%d. %s - %.2f USDT\n", i+1, p.Name, p.Price)
	}

	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		kb := createProductManagementKeyboard(int(p.ID), p.Name, p.Price)
		keyboardRows = append(keyboardRows, kb.InlineKeyboard...)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: keyboardRows}
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("상품 리스트 전송 실패: %v", err)
	}
}

func getProductsByCategory(db *gorm.DB, categoryName string) ([]Product, error) {
	var category Category
	if err := db.Where("name = ?", categoryName).First(&category).Error; err != nil {
		return nil, err
	}

	var products []Product
	if err := db.Where("category_id = ? AND active = ?", category.ID, true).Find(&products).Error; err != nil {
		return nil, err
	}

	return products, nil
}

func showAdminStatsMenu(uid int64, chatID int64, msgID int, period string) {
	var text string
	var kb tgbotapi.InlineKeyboardMarkup

	switch period {
	case "daily":
		stats, err := getDailyStatsNew()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "❌ 통계 조회 실패")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"📊 일일 통계 (%s)\n\n총 매출: %.4f USDT\n총 주문: %d건\n완료 주문: %d건",
			stats.Date, stats.TotalSales, stats.TotalCount, stats.SalesCount,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("주간 통계", "admin_stats_weekly"),
				tgbotapi.NewInlineKeyboardButtonData("월간 통계", "admin_stats_monthly"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("전체 통계", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
			),
		)

	case "weekly":
		stats, err := getWeeklyStats()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "❌ 주간 통계 조회 실패")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"📅 주간 통계\n기간: %s ~ %s\n\n총 매출: %.2f USDT\n총 주문 수: %d건",
			stats.StartDate, stats.EndDate, stats.TotalSales, stats.TotalOrders,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("월간 통계", "admin_stats_monthly"),
				tgbotapi.NewInlineKeyboardButtonData("전체 통계", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
			),
		)

	case "monthly":
		stats, err := getMonthlyStats()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "❌ 월간 통계 조회 실패")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"📅 월간 통계\n기간: %s\n\n총 매출: %.2f USDT\n총 주문 수: %d건",
			stats.Date, stats.TotalSales, stats.TotalCount,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("전체 통계", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
			),
		)

	case "all":
		var totalSales float64
		var totalOrders int64
		db.Model(&Order{}).Select("SUM(amount)").Row().Scan(&totalSales)
		db.Model(&Order{}).Count(&totalOrders)

		text = fmt.Sprintf(
			"<b>전체 통계</b>\n\n총 매출: %.2f USDT\n총 주문 수: %d건",
			totalSales, totalOrders,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
			),
		)

	default:
		showAdminStatsMenu(uid, chatID, msgID, "daily")
		return
	}

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminUserListMenu(chatID int64, messageID int) {
	// 유저 목록 조회 (최근 10명)
	users, err := getRecentUsers(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 유저 목록 조회 실패")
		bot.Request(msg)
		return
	}

	text := "👥 최근 가입 유저 (10명)\n\n"
	var rows [][]tgbotapi.InlineKeyboardButton

	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(닉네임없음)"
		}
		userName := user.UserName
		if userName == "" {
			userName = "없음"
		}
		text += fmt.Sprintf(
			"%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1, nickname, user.UserID, userName, user.LastSeen.Format("01-02 15:04"),
		)
		// 버튼에도 닉네임 표시
		btn := tgbotapi.NewInlineKeyboardButtonData(
			nickname,
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// 하단 고정 버튼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("전체 유저", "admin_all_users"),
	))
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Request(msg)
}

func getUserByUserID(userID int64) (*User, error) {
	var user User
	result := db.Where("user_id = ?", userID).First(&user)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

func showAdminUserDetailMenu(chatID int64, messageID int, userID int64) {
	user, err := getUserByUserID(userID)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 유저 정보 조회 실패")
		bot.Send(msg)
		return
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := func() string {
		if user.UserName == "" {
			return "(없음)"
		}
		return "@" + user.UserName
	}()

	fullMsg := fmt.Sprintf(
		`<b>━━━━━━━━━━━━━━━━</b>
🆔 <b>고유번호</b> : %d
👤 <b>유저네임</b> : %s
⏰ <b>최근 접속</b> : %s
등급 : %s %s
<b>━━━━━━━━━━━━━━━━</b>`,
		user.UserID,
		displayName,
		user.LastSeen.Format("2006-01-02 15:04:05"),
		emoji,
		user.Grade,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🥉", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥈", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥇", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("💎", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("👑", fmt.Sprintf("admin_set_grade_vip_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_user_list"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, fullMsg)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	if _, err := bot.Send(msg); err != nil {
		log.Printf("유저 상세 정보 메시지 전송 실패: %v", err)
	}
}

func showAdminOrderListMenu(uid, chatID int64, messageID int) {
	// 최근 주문 내역 조회
	orders, err := getRecentOrders(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 주문 내역 조회 실패")
		bot.Request(msg)
		return
	}

	text := "📋 최근 주문 내역 (10건)\n\n"
	for i, order := range orders {
		text += fmt.Sprintf("%d. %s - %.4f USDT - %s\n",
			i+1, order.Product, order.Amount, order.Status)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "전체 주문", CallbackData: ptr("admin_all_orders")}},
			{{Text: "미처리 주문", CallbackData: ptr("admin_pending_orders")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 유틸리티 함수들
func getRecentUsers(limit int) ([]User, error) {
	var users []User
	err := db.Order("last_seen desc").Limit(limit).Find(&users).Error
	return users, err
}

func getRecentOrders(limit int) ([]Order, error) {
	var orders []Order
	err := db.Order("timestamp desc").Limit(limit).Find(&orders).Error
	return orders, err
}

func getPendingOrders() ([]Order, error) {
	var orders []Order
	err := db.Where("status = ?", "입금대기중").Find(&orders).Error
	return orders, err
}

func getSumAmountBetweenDatesAndCategory(start, end, categoryLike string) (float64, error) {
	var total sql.NullFloat64
	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		start, end, categoryLike+"%",
	).Scan(&total).Error
	if err != nil {
		return 0, err
	}
	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULL인 경우 0 반환
}

// 주간/월간 통계
func getWeeklyStats() (WeeklyStats, error) {
	var stats WeeklyStats

	now := time.Now()
	weekday := int(now.Weekday())
	if weekday == 0 {
		weekday = 7
	}
	startOfWeek := now.AddDate(0, 0, -(weekday - 1))
	endOfWeek := startOfWeek.AddDate(0, 0, 6)

	stats.StartDate = startOfWeek.Format("2006-01-02")
	stats.EndDate = endOfWeek.Format("2006-01-02")

	err := db.Model(&Order{}).
		Select("IFNULL(SUM(amount),0)").
		Where("created_at BETWEEN ? AND ?", stats.StartDate+" 00:00:00", stats.EndDate+" 23:59:59").
		Scan(&stats.TotalSales).Error
	if err != nil {
		return stats, err
	}

	err = db.Model(&Order{}).
		Where("created_at BETWEEN ? AND ?", stats.StartDate+" 00:00:00", stats.EndDate+" 23:59:59").
		Count(&stats.TotalOrders).Error
	if err != nil {
		return stats, err
	}

	return stats, nil
}

func showWeeklyStatsMenu(chatID int64, msgID int) {
	stats, err := getWeeklyStats()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, msgID, "❌ 주간 통계 조회 실패")
		bot.Send(msg)
		return
	}

	text := fmt.Sprintf(
		"📅 주간 통계\n기간: %s ~ %s\n\n총 매출: %.2f USDT\n총 주문 수: %d건",
		stats.StartDate, stats.EndDate, stats.TotalSales, stats.TotalOrders,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("월간 통계", "admin_monthly_report"),
			tgbotapi.NewInlineKeyboardButtonData("연간 통계", "admin_yearly_report"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func getMonthlyStats() (SalesStats, error) {
	var stats SalesStats

	now := time.Now()
	year, month, _ := now.Date()
	location := now.Location()

	// 월 시작: 이번 달 1일 00:00:00
	monthStart := time.Date(year, month, 1, 0, 0, 0, 0, location)
	// 다음 달 시작 (월 종료)
	nextMonthStart := monthStart.AddDate(0, 1, 0)

	// 월간 총 매출과 주문 건수 합산
	err := db.Model(&Order{}).
		Select("IFNULL(SUM(amount),0) as total_sales, COUNT(*) as total_orders").
		Where("created_at >= ? AND created_at < ?", monthStart, nextMonthStart).
		Scan(&stats).Error

	if err != nil {
		return stats, err
	}

	stats.Date = monthStart.Format("2006-01")

	return stats, nil
}

// 카드 재고 관리
func addCardStock(category, name, content string) error {
	card := StockCard{
		Category:  category,
		Name:      name,
		Content:   content,
		Used:      false,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	return db.Create(&card).Error // ★ 수정!
}

func deleteCardStock(cardID uint) error {
	return db.Delete(&StockCard{}, cardID).Error
}

func getCardStockByCategory(category string) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("category = ?", category).Find(&cards).Error
	return cards, err
}

// 사용자 활동 로그
func logUserActivity(userID int64, action string) error {
	log := UserActivityLog{
		UserID:     userID,
		LastActive: time.Now(),
	}
	return db.Create(&log).Error
}

// 시스템 상태 체크
func checkSystemHealth() map[string]interface{} {
	health := make(map[string]interface{})

	// DB 연결 상태
	sqlDB, err := db.DB()
	if err != nil {
		health["database"] = "error"
	} else if err = sqlDB.Ping(); err != nil {
		health["database"] = "error"
	} else {
		health["database"] = "ok"
	}

	// 봇 상태
	if bot != nil {
		health["bot"] = "ok"
	} else {
		health["bot"] = "error"
	}

	// 메모리 사용량
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	health["memory_mb"] = float64(m.Alloc) / 1024 / 1024

	// 업타임
	health["uptime"] = time.Since(startTime).String()

	return health
}

func updateBotSettings(newSettings map[string]interface{}) error {
	for key, value := range newSettings {
		if err := db.Model(&BotSetting{}).
			Where("key = ?", key).
			Update("value", value).Error; err != nil {
			log.Printf("설정 업데이트 실패: %v", err)
			return err
		}
	}

	// 필요하면 전역변수, 캐시 등도 여기서 업데이트

	log.Println("봇 설정이 성공적으로 업데이트 되었습니다.")
	return nil
}

func getBotSettings() map[string]string {
	settings := make(map[string]string)
	settings["webhook_url"] = os.Getenv("WEBHOOK_URL")
	settings["tron_api_key"] = os.Getenv("TRON_API_KEY")
	settings["admin_user_id"] = os.Getenv("ADMIN_USER_ID")
	return settings
}

// 로그 관리
func getSystemLogs(limit int) ([]string, error) {
	// 시스템 로그 조회 로직
	logs := []string{
		"2025-06-29 21:14:15 [INFO] 봇 시작됨",
		"2025-06-29 21:14:16 [INFO] DB 연결 성공",
		"2025-06-29 21:14:17 [INFO] 웹훅 설정 완료",
	}
	return logs, nil
}

func clearSystemLogs() error {
	// 시스템 로그 정리 로직
	log.Println("시스템 로그 정리 완료")
	return nil
}

// 시스템 상태 체크 메뉴
func showSystemHealthMenu(uid, chatID int64, messageID int) {
	health := checkSystemHealth()

	text := "🔍 시스템 상태\n\n"
	text += fmt.Sprintf("데이터베이스: %s\n", health["database"])
	text += fmt.Sprintf("봇 상태: %s\n", health["bot"])
	text += fmt.Sprintf("메모리 사용량: %.2f MB\n", health["memory_mb"])
	text += fmt.Sprintf("업타임: %s\n", health["uptime"])

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "새로고침", CallbackData: ptr("admin_refresh_health")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 로그 관리 메뉴
func showLogsMenu(uid, chatID int64, messageID int) {
	logs, err := getSystemLogs(5)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 로그 조회 실패")
		bot.Request(msg)
		return
	}

	text := "📋 최근 시스템 로그 (5건)\n\n"
	for _, log := range logs {
		text += log + "\n"
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "로그 정리", CallbackData: ptr("admin_clear_logs")}},
			{{Text: "전체 로그", CallbackData: ptr("admin_all_logs")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 재고 조회 및 사용 가능한 카드 내용 반환 함수
func getCardStockAndContent(productName string) (int64, string, error) {
	var card StockCard
	count, err := getStockCount(productName)
	if err != nil {
		return 0, "", err
	}
	if count == 0 {
		return 0, "", nil
	}

	// 재고 중 하나의 카드 내용을 가져옴
	err = db.Where("name = ? AND used = ?", productName, false).First(&card).Error
	if err != nil {
		return count, "", err
	}

	return count, card.Content, nil
}

func addUserBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", userID).Error
	if err != nil { // 잔액 기록이 없으면 새로 생성
		balance = UserBalance{
			UserID:  userID,
			Balance: amount,
		}
		return db.Create(&balance).Error
	}
	// 기존 잔액에 추가
	balance.Balance += amount
	return db.Save(&balance).Error
}

func processOrderWithValidation(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("주문 조회 실패: %w", err)
	}

	if order.Status != "입금대기중" && order.Status != "결제완료" {
		return fmt.Errorf("주문 상태가 올바르지 않습니다: %s", order.Status)
	}

	stock, cardContent, err := getCardStockAndContent(order.Product)
	if err != nil {
		return fmt.Errorf("재고 조회 실패: %w", err)
	}
	if stock <= 0 {
		order.Status = "재고없음"
		if err := db.Save(&order).Error; err != nil {
			return fmt.Errorf("재고 부족 상태 저장 실패: %w", err)
		}
		sendTelegram(order.UserID, "❌ 주문하신 상품의 재고가 부족합니다. 관리자에게 문의해 주세요.")
		return fmt.Errorf("상품 재고 부족: %s", order.Product)
	}

	err = db.Model(&StockCard{}).
		Where("name = ? AND used = 0", order.Product).
		Limit(1).
		Updates(map[string]interface{}{
			"used":     true,
			"used_by":  order.UserID,
			"order_id": order.ID,
		}).Error
	if err != nil {
		return fmt.Errorf("재고 카드 사용 처리 실패: %w", err)
	}

	txIDCopy := txID
	order.CardInfo = cardContent
	order.Status = "완료"
	order.TxID = &txIDCopy
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("주문 상태 저장 실패: %w", err)
	}

	if err := updateDailyStats(order.Amount); err != nil {
		log.Printf("통계 업데이트 실패: %v", err)
	}

	notifyMsg := fmt.Sprintf(
		"주문이 완료되었습니다\n\n상품명: %s\n상품 정보:\n%s\n\n오류 시 문의 주세요.",
		order.Product, cardContent,
	)
	sendTelegram(order.UserID, notifyMsg)

	return nil
}

func sendOrderCompletionNotification(userID int64, product, cardContent string) {
	text := fmt.Sprintf(
		"🎁 *상품 지급 완료!*\n\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"+
			"📦 **상품명**: %s\n"+
			"🎫 **카드정보**:\n`%s`\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"+
			"✅ 주문이 성공적으로 완료되었습니다!\n"+
			"🙏 이용해 주셔서 감사합니다.\n\n"+
			"💡 문의사항이 있으시면 고객센터를 이용해주세요.",
		product, cardContent,
	)
	sendTelegram(userID, text)
}

func validateAdminAccess(userID int64) bool {
	adminUserIDStr := os.Getenv("ADMIN_USER_ID")
	if adminUserIDStr == "" {
		return false
	}

	adminUserID, err := strconv.ParseInt(adminUserIDStr, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID 변환 실패: %v", err)
		return false
	}

	return userID == adminUserID
}

func logAdminAction(userID int64, action string) {
	log.Printf("[ADMIN] User %d performed action: %s", userID, action)
}

func getAllValidProductCodes() []string {
	var codes []string
	for _, products := range cardCategories {
		for _, p := range products {
			codes = append(codes, p.Code)
		}
	}
	return codes
}

// 알림 및 모니터링 기능들
func sendSystemAlert(message string) {
	adminUserID := os.Getenv("ADMIN_USER_ID")
	if adminUserID == "" {
		return
	}

	adminID, err := strconv.ParseInt(adminUserID, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID 변환 실패: %v", err)
		return
	}

	if err := sendTelegram(adminID, "🚨 시스템 알림: "+message); err != nil {
		log.Printf("시스템 알림 전송 실패: %v", err)
	}
}

// 고급 사용자 관리 기능들
func getUserDetailedInfo(userID int64) (map[string]interface{}, error) {
	info := make(map[string]interface{})

	// 사용자 기본 정보
	var user User
	err := db.Where("user_id = ?", userID).First(&user).Error
	if err != nil {
		return nil, err
	}

	// 주문 내역
	orders, err := getUserOrders(userID)
	if err != nil {
		return nil, err
	}

	// 잔액 정보
	balance, err := getUserBalance(userID)
	if err != nil {
		return nil, err
	}

	// 사용된 카드
	cards, err := getUsedCards(userID)
	if err != nil {
		return nil, err
	}

	info["user"] = user
	info["orders"] = orders
	info["balance"] = balance
	info["used_cards"] = cards
	info["total_spent"] = calculateTotalSpent(orders)
	info["order_count"] = len(orders)

	return info, nil
}

func calculateTotalSpent(orders []Order) float64 {
	total := 0.0
	for _, order := range orders {
		if order.Status == "완료" {
			total += order.Amount
		}
	}
	return total
}

// 고급 재고 관리 기능들
func getStockAnalytics() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}

	for _, category := range categories {
		var total int64
		var used int64
		var available int64

		// 총 재고
		db.Model(&StockCard{}).Where("category = ?", category).Count(&total)
		// 사용된 재고
		db.Model(&StockCard{}).Where("category = ? AND used = true", category).Count(&used)
		available = total - used

		usageRate := 0.0
		if total > 0 {
			usageRate = float64(used) / float64(total) * 100
		}

		result[category] = map[string]interface{}{
			"total":      total,
			"used":       used,
			"available":  available,
			"usage_rate": usageRate,
		}
	}
	return result, nil
}

func showStockAnalyticsMenu(_ /*uid*/, chatID int64, messageID int) {
	analytics, err := getStockAnalytics()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 재고 분석 실패")
		bot.Send(msg)
		return
	}

	text := "📊 재고 분석\n\n"

	categories := []string{"VPS", "MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	for _, category := range categories {
		raw, ok := analytics[category]
		if !ok || raw == nil {
			continue
		}
		data, ok := raw.(map[string]interface{})
		if !ok {
			continue
		}

		text += fmt.Sprintf("%s:\n", category)
		if total, ok := data["total"].(int64); ok {
			text += fmt.Sprintf("  총 재고: %d개\n", total)
		}
		if used, ok := data["used"].(int64); ok {
			text += fmt.Sprintf("  사용됨: %d개\n", used)
		}
		if available, ok := data["available"].(int64); ok {
			text += fmt.Sprintf("  사용가능: %d개\n", available)
		}
		if usage, ok := data["usage_rate"].(float64); ok {
			text += fmt.Sprintf("  사용률: %.1f%%\n\n", usage)
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{
				tgbotapi.NewInlineKeyboardButtonData("재고 추가", "admin_add_stock"),
				tgbotapi.NewInlineKeyboardButtonData("재고 정리", "admin_cleanup_stock"),
			},
			{
				tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
			},
		},
	}

	bot.Send(msg)
}

// 관리자 재고 삭제 메뉴
func showAdminStockDeleteMenu(uid, chatID int64, msgID int, productID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "ACCOUNT"}

	text := "🗑️ 재고 삭제\n\n삭제할 카테고리를 선택하세요:\n\n"

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	btnCount := 0

	for _, category := range categories {
		stockCount, err := getCardStock(category)
		if err != nil {
			continue
		}

		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s (%d개)", category, stockCount),
			fmt.Sprintf("del_stock_%s", category),
		)
		currentRow = append(currentRow, btn)
		btnCount++

		if btnCount%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}

	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_inventory"),
	))

	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("재고 삭제 메뉴 수정 실패: %v", err)
	}
}

// 카테고리별 재고 삭제 처리
func handleDeleteStockCategory(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "del_stock_")

	// 삭제 전 확인 메시지
	stockCount, err := getCardStock(category)
	if err != nil {
		sendTelegram(uid, "❌ 재고 조회 실패")
		bot.Request(tgbotapi.NewCallback(cb.ID, "조회 실패"))
		return
	}

	text := fmt.Sprintf("⚠️ 정말로 %s 카테고리의 모든 재고(%d개)를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다!", category, stockCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✅ 삭제 확인", fmt.Sprintf("confirm_del_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("❌ 취소", "admin_del_stock"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("삭제 확인 메뉴 수정 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 확인"))
}

// 재고 삭제 확인 처리
func handleConfirmDeleteStock(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "confirm_del_")

	// 실제 삭제 실행
	var deletedCount int64
	result := db.Where("category = ?", category).Delete(&StockCard{})
	if result.Error != nil {
		log.Printf("재고 삭제 실패: %v", result.Error)
		sendTelegram(uid, "❌ 재고 삭제 중 오류가 발생했습니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 실패"))
		return
	}

	deletedCount = result.RowsAffected

	// 성공 메시지
	text := fmt.Sprintf("✅ %s 카테고리의 재고 %d개가 성공적으로 삭제되었습니다.", category, deletedCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 재고메뉴", "admin_inventory"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("삭제 완료 메뉴 수정 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 완료"))
}
