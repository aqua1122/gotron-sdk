package main

import (
	crand "crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/google/uuid"
	"github.com/skip2/go-qrcode"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	telegramAdminID            int64
	db                         *gorm.DB
	mu                         sync.Mutex
	adminIDs                   = []int64{6647879650} // ì‹¤ì œ ê´€ë¦¬ì IDë¡œë§Œ êµ¬ì„± (í•„ìš”ì‹œ ì¶”ê°€)
	processedOrders            = map[uint]bool{}
	processedOrdersMu          sync.Mutex
	mySuperAdminID             int64 = 6647879650
	verifiedUsers                    = make(map[int64]bool)
	lastAlertedCategories            = make(map[string]time.Time)
	verificationAnswers              = make(map[int64]int)
	userMessageIDs                   = map[int64][]int{}
	pendingSupportQueue              = make(map[int64]time.Time)
	activeSupportSessions            = make(map[int64]int64)
	userSelectedProduct              = make(map[int64]string)
	pendingStockImageID              = make(map[int64]string)
	pendingWalletInput               = make(map[int64]bool)
	userLanguages                    = make(map[int64]string)
	pendingStockInput                = make(map[int64]string)
	startTime                        = time.Now()
	selectedCategory                 = make(map[int64]string)
	tronGridAPIKey                   = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract                = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
	walletReceiveAddress             = os.Getenv("WALLET_RECEIVE_ADDRESS")
	unmatchedAdminChatID       int64 = 6647879650
	pendingAddProductCategory        = make(map[int64]string)
	processedTxsMu             sync.RWMutex
	adminChatID                int64 = 6647879650
	lastShownMenuMessageID           = make(map[int64]int)
	userReplyKeyboardMsgID           = make(map[int64]int)
	processedTxs                     = make(map[string]bool)
	pendingEditProduct               = map[int64]int{}
	pendingAdminInput                = make(map[int64]bool)
	pendingStockInputNotified        = make(map[int64]bool)
	pendingBroadcastInput            = make(map[int64]bool)
	pendingDepositInput              = make(map[int64]bool)
	pendingDepositAmount             = make(map[int64]float64)
	pendingStockInputMessageID       = make(map[int64]int)
	productDB                        = make(map[string]Product)
	cachedProducts                   = make(map[string][]Product)
	cachedProductOrder               = make(map[string][]string)
	cachedCategories           []string
)

var vpsProductMap = map[string]VPSProduct{
	"vps1": {Name: "KVM - E1", Price: 70.0},
	"vps2": {Name: "KVM - E2", Price: 90.0},
	"vps3": {Name: "KVM - T1", Price: 120.0},
	"vps4": {Name: "KVM - T2", Price: 150.0},
	"vps5": {Name: "ë§ì¶¤ ì œì‘", Price: 1.0}, // ë³„ë„ ê²¬ì ìš© ì²˜ë¦¬ ê°€ëŠ¥
}

var productCategories = []string{
	"VPS", "ACCOUNT", "MEMBERSHIP", "ESIM", "CARD",
}

var validGrades = map[string]bool{
	"bronze":  true,
	"silver":  true, // ìˆ˜ì •: silvedb.Where("categoryr" â†’ "silver"
	"gold":    true,
	"diamond": true,
	"admin":   true,
}

var bot *tgbotapi.BotAPI
var adminStates = make(map[int64]AdminState)

// categoryMapì— VPS í¬í•¨ ë° ID ë§ì¶¤
var categoryMap = map[string]uint{
	"VPS":        1,
	"ESIM":       2,
	"ACCOUNT":    3, // ì´ ë¶€ë¶„ì´ 3ì´ì–´ì•¼ í•©ë‹ˆë‹¤
	"MEMBERSHIP": 4,
	"CARD":       5,
}

var categoryOrder = []string{
	"VPS",
	"ACCOUNT",
	"MEMBERSHIP",
	"ESIM",
	"CARD",
}

// 3. ìƒí’ˆ(ì´ë¦„) ë…¸ì¶œ ìˆœì„œ ì •ì˜ (ë©”ë‰´ UI ë“±ì—ì„œ ì‚¬ìš©)
var productOrder = map[string][]string{
	"VPS":        {"KVM - E1", "KVM - E2", "KVM - T1", "KVM - T2", "ë§ì¶¤ ì œì‘"},
	"ACCOUNT":    {"TG 1ë…„", "TG 2ë…„", "ì§§ì€ ë²ˆí˜¸"},
	"MEMBERSHIP": {"TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”", "TG í”„ë¦¬ë¯¸ì—„ 1ë…„", "YT í”„ë¦¬ë¯¸ì—„ 1ë…„"}, // ë³€ê²½ë¨
	"ESIM":       {"DATA 30 DAY", "KOREA|HK", "NO KYC"},
	"CARD":       {"êµ­ë‚´ê²°ì œ", "êµ­ì™¸ê²°ì œ", "í•­ê³µê¶Œ"},
}

// 4. ì‹¤ì œ ìƒí’ˆ DB/ë©”ëª¨ë¦¬ ì´ˆê¸°í™”ì‹œ ì‚¬ìš© (ìƒí’ˆëª…â†’ìƒí’ˆ ì •ë³´)
var cardCategories = map[string]map[string]Product{
	"VPS": {
		"KVM - E1": {Code: "vps1", Name: "KVM - E1", Price: 70, Description: "CPU: 4ì½”ì–´, RAM: 4GB, ì €ì¥ê³µê°„: 100GB NVMe, ê°€ê²©: 70 USDT", Active: true},
		"KVM - E2": {Code: "vps2", Name: "KVM - E2", Price: 90, Description: "CPU: 4ì½”ì–´, RAM: 6GB, ì €ì¥ê³µê°„: 140GB NVMe, ê°€ê²©: 90 USDT", Active: true},
		"KVM - T1": {Code: "vps3", Name: "KVM - T1", Price: 120, Description: "CPU: 8ì½”ì–´, RAM: 16GB, ì €ì¥ê³µê°„: 160GB NVMe, ê°€ê²©: 120 USDT", Active: true},
		"KVM - T2": {Code: "vps4", Name: "KVM - T2", Price: 150, Description: "CPU: 12ì½”ì–´, RAM: 24GB, ì €ì¥ê³µê°„: 256GB NVMe, ê°€ê²©: 150 USDT", Active: true},
		"ë§ì¶¤ ì œì‘":    {Code: "vps5", Name: "ë§ì¶¤ ì œì‘", Price: 1, Description: "ë§ì¶¤í˜•ì€ ìµœì†Œ 3ê°œì›” ë¶€í„°, ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´, ì›í•˜ëŠ” ì˜µì…˜ì— ë§ì¶° ì œì‘", Active: true},
	},
	"ACCOUNT": {
		"TG 1ë…„": {Code: "tgid1", Name: "TG 1ë…„", Price: 8, Active: true},
		"TG 2ë…„": {Code: "tgid2", Name: "TG 2ë…„", Price: 20, Active: true},
		"ì§§ì€ ë²ˆí˜¸": {Code: "tgid3", Name: "ì§§ì€ ë²ˆí˜¸", Price: 60, Active: true},
	},
	"MEMBERSHIP": { // ëŒ€ë¬¸ì MEMEBERSHIP
		"TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”": {Code: "tp3", Name: "TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”", Price: 17, Active: true},
		"TG í”„ë¦¬ë¯¸ì—„ 1ë…„":  {Code: "tp12", Name: "TG í”„ë¦¬ë¯¸ì—„ 1ë…„", Price: 45, Active: true},
		"YT í”„ë¦¬ë¯¸ì—„ 1ë…„":  {Code: "yp12", Name: "YT í”„ë¦¬ë¯¸ì—„ 1ë…„", Price: 60, Active: true},
	},
	"ESIM": {
		"DATA 30Day": {Code: "es1", Name: "DATA 30 DAY", Price: 70, Active: true},
		"KOREA|HK":   {Code: "es2", Name: "KOREA|HK", Price: 999, Active: true},
		"NO KYC":     {Code: "es3", Name: "NO KYC", Price: 999, Active: true},
	},
	"CARD": {
		"êµ­ë‚´ê²°ì œ": {Code: "card1", Name: "êµ­ë‚´ê²°ì œ", Price: 10, Active: true},
		"êµ­ì™¸ê²°ì œ": {Code: "card2", Name: "êµ­ì™¸ê²°ì œ", Price: 10, Active: true},
		"í•­ê³µê¶Œ":  {Code: "card3", Name: "í•­ê³µê¶Œ", Price: 10, Active: true},
	},
}

type StockCard struct {
	ID          uint64 `gorm:"primaryKey"`
	Category    string `gorm:"type:varchar(100);index:idx_category"`
	Name        string `gorm:"type:text"`
	Content     string `gorm:"type:text"`
	Used        bool
	UsedBy      int64
	OrderID     int64
	PhotoFileID string `gorm:"type:text"`
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type Stock struct {
	ID        uint   `gorm:"primaryKey"`
	ProductID int    // ì—°ê´€ëœ ìƒí’ˆ ID
	Code      string // ì¬ê³  ì½”ë“œ
	Used      bool   // ì‚¬ìš© ì—¬ë¶€
	CreatedAt time.Time
	UpdatedAt time.Time
}

type CardProduct struct {
	ID         uint `gorm:"primaryKey"`
	CategoryID uint
	Name       string
	Code       string `gorm:"type:varchar(255);uniqueIndex"`
	Price      float64
	IsActive   bool `gorm:"default:true"`
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

type AdminState struct {
	Mode     string
	Category string
	Name     string
}

type BotSetting struct {
	ID    uint   `gorm:"primaryKey"`
	Key   string `gorm:"unique;not null"`
	Value string `gorm:"type:text"`
}

type WeeklyStats struct {
	StartDate   string
	EndDate     string
	TotalSales  float64
	TotalOrders int64
}

type MonitoringWallet struct {
	ID        uint `gorm:"primaryKey"`
	UserID    int64
	Address   string `gorm:"unique"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Category struct {
	ID          uint   `gorm:"primaryKey"`
	Name        string `gorm:"type:varchar(191);uniqueIndex;not null"`
	DisplayName string `gorm:"type:varchar(191)"`
	IsActive    bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type CardCategory struct {
	ID          uint
	Name        string
	DisplayName string
	IsActive    bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type ProcessedDeposit struct {
	ID        uint      `gorm:"primaryKey"`
	TxID      string    `gorm:"uniqueIndex;not null;size:100"`
	CreatedAt time.Time `gorm:"autoCreateTime:milli"`
}

type TronDeposit struct {
	Amount float64
	TxID   string
	// ... í•„ìš”ì‹œ ì¶”ê°€
}

type Result struct {
	Error        error
	RowsAffected int64
}

type UserWallet struct {
	ID        uint      `gorm:"primaryKey"`
	UserID    int64     `gorm:"column:user_id"`
	Address   string    `gorm:"column:address"`
	CreatedAt time.Time `gorm:"autoCreateTime"`
}

type VPSProduct struct {
	Name  string
	Price float64
}

type User struct {
	ID            uint      `gorm:"primaryKey;autoIncrement"`
	UserID        int64     `gorm:"column:user_id;uniqueIndex"` // ì¤‘ë³µ í‚¤ ë¬¸ì œ ì—†ë‹¤ë©´ uniqueIndex
	UserName      string    `gorm:"column:username"`
	Nickname      string    `gorm:"column:nickname"`
	ChatID        int64     `gorm:"column:chat_id"`
	LastSeen      time.Time `gorm:"column:last_seen"`
	JoinedAt      time.Time `gorm:"column:joined_at"`
	Grade         string    `gorm:"column:grade;type:varchar(20)"`
	DepositWallet string    `gorm:"column:wallet_address"`
	Verified      bool      `gorm:"column:verified"`
	Lang          string    `gorm:"column:lang"`
}

type Transaction struct {
	TransactionID  string `json:"transaction_id"`
	From           string `json:"from"`
	To             string `json:"to"`
	Value          string `json:"value"`
	BlockTimestamp int64  `json:"block_timestamp"`
	Confirmations  int    `json:"confirmations"`
}

type TronGridResponse struct {
	Data  []Transaction `json:"data"`
	Total int           `json:"total"`
}

type TronTransaction struct {
	TxID      string
	From      string
	To        string
	AmountStr string
	Timestamp int64
}

type Deposit struct {
	TxID   string
	Amount float64
	Time   time.Time
}

type ChatInfoConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Order struct {
	ID          uint `gorm:"primaryKey"`
	UserID      int64
	Product     string
	Amount      float64
	Status      string `gorm:"type:varchar(255);index"`
	ExpectedAmt float64
	CardInfo    string  `gorm:"type:text"`
	TxID        *string `gorm:"type:varchar(255);index"`
	Timestamp   time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserBalance struct {
	UserID  int64 `gorm:"primaryKey"`
	Balance float64
}

type Visitor struct {
	UserID   int64
	UserName sql.NullString
	Nickname string
	LastSeen time.Time
}

type WalletMap struct {
	ID        uint64 `gorm:"primaryKey"`
	UserID    int64  `gorm:"uniqueIndex"`
	Wallet    string
	Username  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Wallet struct {
	ID        uint   `gorm:"primaryKey"`
	UserID    int64  `gorm:"index"`
	Address   string `gorm:"size:100;uniqueIndex"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserActivityLog struct {
	UserID     int64
	Username   string
	Nickname   string
	LastActive time.Time
}

type Inventory struct {
	ID          uint `gorm:"primaryKey"`
	Category    string
	ProductName string
	Stock       int64
	UpdatedAt   time.Time
}

type SalesStats struct {
	Date        string // ì˜ˆ: ì¼ë³„ í†µê³„ìš© ë‚ ì§œ
	StartDate   string // ì˜ˆ: ì£¼ê°„/ì›”ê°„ ì‹œì‘ì¼
	EndDate     string // ì˜ˆ: ì£¼ê°„/ì›”ê°„ ì¢…ë£Œì¼
	TotalSales  float64
	TotalCount  int64
	SalesCount  int64
	TotalOrders int64 // í•„ìš”í•˜ë‹¤ë©´ ì¶”ê°€
	Count       int64
}

type Admin struct {
	ID     uint  `gorm:"primaryKey"`
	UserID int64 `gorm:"uniqueIndex"`
}

type Product struct {
	ID          uint   `gorm:"primaryKey"`
	Code        string `gorm:"unique;not null" json:"code"`
	Name        string `gorm:"not null" json:"name"`
	Description string
	Price       float64 `gorm:"not null"`
	CategoryID  uint    `gorm:"index;not null"`
	Category    string  `gorm:"-"` // DB ì»¬ëŸ¼ ì•„ë‹˜, ë‹¨ì§€ í¸ì˜ìš© í•„ë“œ
	Active      bool    `gorm:"default:true"`
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type SimpleProduct struct {
	Code  string
	Price float64
}

type NgrokTunnel struct {
	PublicURL string `json:"public_url"`
}

type NgrokAPIResponse struct {
	Tunnels []struct {
		Name      string `json:"name"`
		PublicURL string `json:"public_url"`
		Proto     string `json:"proto"`
	} `json:"tunnels"`
}

const timeFormat = "2006-01-02 15:04:05"

func init() {
	verificationAnswers = make(map[int64]int)

	tronGridAPIKey = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract = os.Getenv("USDT_TRC20_CONTRACT")
	walletReceiveAddress = os.Getenv("WALLET_RECEIVE_ADDRESS")
	adminIDStr := os.Getenv("TELEGRAM_ADMIN_ID")

	if tronGridAPIKey == "" {
		log.Fatal("âŒ TRONGRID_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	if usdtTRC20Contract == "" {
		log.Fatal("âŒ USDT_TRC20_CONTRACT í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	if walletReceiveAddress == "" {
		log.Fatal("âŒ WALLET_RECEIVE_ADDRESS í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	if adminIDStr == "" {
		log.Fatal("âŒ TELEGRAM_ADMIN_ID í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}

	var err error
	telegramAdminID, err = strconv.ParseInt(adminIDStr, 10, 64)
	if err != nil {
		log.Fatalf("âŒ TELEGRAM_ADMIN_ID íŒŒì‹± ì˜¤ë¥˜: %v", err)
	}
}

func getNgrokPublicURL(apiEndpoint string) (string, error) {
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(apiEndpoint)
	if err != nil {
		return "", fmt.Errorf("ngrok API ìš”ì²­ ì‹¤íŒ¨: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("ngrok API ì‘ë‹µ ì½”ë“œ %d", resp.StatusCode)
	}

	var data NgrokAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", fmt.Errorf("ngrok API JSON ë””ì½”ë”© ì‹¤íŒ¨: %w", err)
	}

	for _, tunnel := range data.Tunnels {
		if strings.HasPrefix(tunnel.PublicURL, "https") {
			return tunnel.PublicURL, nil
		}
	}

	return "", fmt.Errorf("ngrok https í„°ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
}

func addVPSProducts() error {
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		return fmt.Errorf("VPS ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	products := []Product{
		{
			Code:        "vps1",
			Name:        "KVM - E1",
			Description: "CPU: 4ì½”ì–´, RAM: 4GB, ì €ì¥ê³µê°„: 100GB NVMe, ê°€ê²©: 70 USDT",
			Price:       70,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps2",
			Name:        "KVM - E2",
			Description: "CPU: 4ì½”ì–´, RAM: 6GB, ì €ì¥ê³µê°„: 140GB NVMe, ê°€ê²©: 90 USDT",
			Price:       90,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps3",
			Name:        "KVM - T1",
			Description: "CPU: 8ì½”ì–´, RAM: 16GB, ì €ì¥ê³µê°„: 160GB NVMe, ê°€ê²©: 120 USDT",
			Price:       120,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps4",
			Name:        "KVM - T2",
			Description: "CPU: 12ì½”ì–´, RAM: 24GB, ì €ì¥ê³µê°„: 256GB NVMe, ê°€ê²©: 150 USDT",
			Price:       150,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
		{
			Code:        "vps5",
			Name:        "ë§ì¶¤ ì œì‘",
			Description: "ë§ì¶¤í˜• ì‚¬ì–‘ ì œê³µ, ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´, ì•ˆì •ì„±ê³¼ ì„±ëŠ¥ ìš°ì„ ",
			Price:       0,
			CategoryID:  vpsCategoryID,
			Active:      true,
		},
	}

	for _, p := range products {
		var existing Product
		err := db.Where("code = ?", p.Code).First(&existing).Error

		if errors.Is(err, gorm.ErrRecordNotFound) {
			if err := db.Create(&p).Error; err != nil {
				log.Printf("âŒ [%s] ìƒí’ˆ ë“±ë¡ ì‹¤íŒ¨: %v", p.Code, err)
			} else {
				log.Printf("âœ… [%s] ìƒí’ˆ ë“±ë¡ ì™„ë£Œ", p.Code)
			}
		} else if err != nil {
			log.Printf("âŒ [%s] ì¡°íšŒ ì‹¤íŒ¨: %v", p.Code, err)
		} else {
			log.Printf("â„¹ï¸ [%s] ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìƒí’ˆ, ë“±ë¡ ìƒëµ", p.Code)
		}
	}

	return nil
}

func initBotWithWebhook() (*tgbotapi.BotAPI, error) {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		return nil, fmt.Errorf("í…”ë ˆê·¸ë¨ ë´‡ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
	}

	var err error

	bot, err := tgbotapi.NewBotAPI(token)
	if err != nil {
		return nil, fmt.Errorf("í…”ë ˆê·¸ë¨ ë´‡ ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	ngrokAPI := "http://127.0.0.1:4040/api/tunnels"
	publicURL, err := getNgrokPublicURL(ngrokAPI)
	if err != nil {
		log.Printf("ngrok URL ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		publicURL = os.Getenv("WEBHOOK_URL")
		if publicURL == "" {
			return nil, fmt.Errorf("ì›¹í›… URLì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤")
		}
	}

	webhookURL := fmt.Sprintf("%s/webhook", publicURL)
	log.Printf("ì›¹í›… URL ì„¤ì •: %s", webhookURL)

	webhook, err := tgbotapi.NewWebhook(webhookURL)
	if err != nil {
		return nil, fmt.Errorf("ì›¹í›… ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	_, err = bot.Request(webhook)
	if err != nil {
		return nil, fmt.Errorf("ì›¹í›… ë“±ë¡ ì‹¤íŒ¨: %w", err)
	}

	log.Println("ì›¹í›… ë“±ë¡ ì™„ë£Œ")

	return bot, nil
}

func generateCaptcha() (int, int, int) {
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b
	return a, b, answer
}

func sendVerificationChallenge(uid int64, chatID int64) {
	// ë¬¸ì œ ìƒì„± (ì˜ˆ: ê°„ë‹¨í•œ ë§ì…ˆ)
	a := rand.Intn(10) + 1
	b := rand.Intn(10) + 1
	answer := a + b

	// ìœ ì €ë³„ ì •ë‹µ ì €ì¥ (ì „ì—­ë§µ ë˜ëŠ” DBì— ì €ì¥í•´ì•¼ í•¨)
	verificationAnswers[uid] = answer

	msgText := "<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n" +
		"ğŸ”’ <b>PRIVATE ACCESS ONLY</b>\n\n" +
		"ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\n" +
		"ì•„ë˜ ë¬¸ì œë¥¼ í’€ì–´ ì¸ì¦ì„ í•˜ì„¸ìš”.\n\n" +
		fmt.Sprintf("ë¬¸ì œ: <b>%d + %d = ?</b>\n\n", a, b) +
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>"

	// ë‹µë³€ ë²„íŠ¼ 3ê°œ (ì •ë‹µ í¬í•¨ ëœë¤ ë°°ì¹˜)
	options := generateAnswerOptions(answer)
	var buttons []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		data := fmt.Sprintf("verify_%d", opt)
		buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), data))
	}
	kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(buttons...))

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

func generateAnswerOptions(answer int) []int {
	var options []int
	options = append(options, answer)

	// ì •ë‹µê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ ë‘ ê°œì˜ ì˜¤ë‹µ ìƒì„±
	for len(options) < 3 {
		delta := rand.Intn(5) + 1 // 1~5 ë²”ìœ„
		wrong := answer + delta
		if rand.Intn(2) == 0 {
			wrong = answer - delta
		}
		// ì¤‘ë³µ ë°©ì§€
		exists := false
		for _, opt := range options {
			if opt == wrong {
				exists = true
				break
			}
		}
		if !exists && wrong >= 0 {
			options = append(options, wrong)
		}
	}

	// ëœë¤ ìˆœì„œë¡œ ì„ê¸°
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	return options
}

func handleProductSelection(uid int64, chatID int64, messageID int, productCode string, category string) {
	product, ok := cardCategories[category][productCode]
	if !ok {
		sendTelegram(chatID, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	text := fmt.Sprintf(
		"<b>%s</b>\nê°€ê²©: %.2f USDT\nì„¤ëª…: %s\n\nêµ¬ë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
		product.Name, product.Price, product.Description,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìœ¼ë¡œ êµ¬ë§¤", "pay_coin_"+product.Code),
			tgbotapi.NewInlineKeyboardButtonData("ì”ì•¡ìœ¼ë¡œ êµ¬ë§¤", "pay_balance_"+product.Code),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì·¨ì†Œ", "go_main"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func handleVerificationResponse(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	log.Printf("[handleVerificationResponse] uid=%d, data=%s", uid, data)

	if !strings.HasPrefix(data, "verify_") {
		return
	}

	selectedStr := strings.TrimPrefix(data, "verify_")
	selected, err := strconv.Atoi(selectedStr)
	if err != nil {
		sendTelegram(uid, "âŒ ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.")
		return
	}

	correctAnswer, ok := verificationAnswers[uid]
	log.Printf("[Captcha] uid=%d, selected=%d, correctAnswer=%d, exists=%v", uid, selected, correctAnswer, ok)
	if !ok {
		sendTelegram(uid, "âŒ ì¸ì¦ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
		return
	}

	if selected == correctAnswer {
		// ì¸ì¦ ì„±ê³µ ì²˜ë¦¬
		markUserVerified(uid)
		delete(verificationAnswers, uid)

		delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
		if _, err := bot.Send(delMsg); err != nil {
			log.Printf("ì¸ì¦ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
		}

		var user User
		if err := db.Where("user_id = ?", uid).First(&user).Error; err != nil {
			log.Printf("ìœ ì € ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		}

		emoji := getGradeEmoji(user.Grade)
		displayName := user.UserName
		if displayName == "" {
			displayName = user.Nickname
		}
		if displayName == "" {
			displayName = "unknown"
		}

		fullMsg := fmt.Sprintf(
			`<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
		ğŸ”“ âœ… <b>Access Granted</b> âœ…
		
		ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b> : %d
		ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b> : %s
		â° : %s
		<b>ë“±ê¸‰</b> : %s %s
		<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>`,
			user.UserID,
			displayName,
			user.LastSeen.Format("2006-01-02 15:04:05"),
			emoji,
			user.Grade,
		)

		isAdminUser := isAdmin(uid)
		var menu tgbotapi.InlineKeyboardMarkup
		if isAdminUser {
			menu = tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
					tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
					tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
					tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
				),
			)
		} else {
			menu = tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
					tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
					tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
					tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
				),
			)
		}

		msg1 := tgbotapi.NewMessage(chatID, fullMsg)
		msg1.ParseMode = "HTML"
		msg1.ReplyMarkup = menu
		bot.Send(msg1)

		replyKeyboard := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("ë‚´ ì •ë³´"),
				tgbotapi.NewKeyboardButton("ì—ë„ˆì§€"),
			),
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("ì£¼ë¬¸ë‚´ì—­"),
				tgbotapi.NewKeyboardButton("ê³ ê°ì„¼í„°"),
			),
		)
		replyKeyboard.ResizeKeyboard = true
		msg2 := tgbotapi.NewMessage(chatID, "PING ğŸ›œ")
		msg2.ReplyMarkup = replyKeyboard
		bot.Send(msg2)

		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¸ì¦ ì™„ë£Œ"))
	} else {
		// ì¸ì¦ ì‹¤íŒ¨ ì²˜ë¦¬
		failMsg := `<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
âŒ <b>Verification Failed</b> âŒ

ì„ íƒí•œ ë‹µë³€ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
ì•„ë˜ ë¬¸ì œë¥¼ ë‹¤ì‹œ í’€ì–´ ì£¼ì„¸ìš”.

ì§€ì†ë  ê²½ìš° ì°¨ë‹¨ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
`
		sendTelegram(uid, failMsg)
		delete(verificationAnswers, uid)
		sendVerificationChallenge(uid, chatID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¸ì¦ ì‹¤íŒ¨"))
	}
}

// ì¸ì¦ ìƒíƒœ ê¸°ë¡ í•¨ìˆ˜ (ë©”ëª¨ë¦¬ + DB ë™ê¸°í™”)
func markUserVerified(uid int64) {
	verifiedUsers[uid] = true

	// DBì—ë„ ì €ì¥ (í•„ìš”í•œ ê²½ìš°)
	if err := db.Model(&User{}).
		Where("user_id = ?", uid).
		Update("verified", true).Error; err != nil {
		log.Printf("DB ì¸ì¦ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (uid=%d): %v", uid, err)
	}
}

func saveStockWithImage(inputText, photoFileID string) error {
	lines := strings.Split(strings.TrimSpace(inputText), "\n")
	tx := db.Begin() // íŠ¸ëœì­ì…˜ ì‹œì‘ (ì›ìì„± ë³´ì¥)

	for _, line := range lines {
		parts := strings.SplitN(line, ":", 3)
		if len(parts) != 3 {
			tx.Rollback()
			log.Printf("ì¬ê³  ì…ë ¥ í˜•ì‹ ì˜¤ë¥˜, ë¡¤ë°±: %s", line)
			return fmt.Errorf("ì˜ëª»ëœ ì…ë ¥ í˜•ì‹: %s", line)
		}
		category := strings.TrimSpace(parts[0])
		name := strings.TrimSpace(parts[1])
		codes := strings.Split(parts[2], ",")

		for _, code := range codes {
			code = strings.TrimSpace(code)
			if code == "" {
				continue
			}
			stockCard := StockCard{
				Category:    category,
				Name:        name,
				Content:     code,
				Used:        false,
				PhotoFileID: photoFileID,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}
			if err := tx.Create(&stockCard).Error; err != nil {
				tx.Rollback()
				log.Printf("DB ì €ì¥ ì˜¤ë¥˜, ë¡¤ë°±: %v", err)
				return fmt.Errorf("DB ì˜¤ë¥˜: %w", err)
			}
		}
	}

	if err := tx.Commit().Error; err != nil {
		log.Printf("íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹¤íŒ¨: %v", err)
		return err
	}

	return nil
}

func getCardCategoriesFromDB() ([]CardCategory, error) {
	var categories []CardCategory
	err := db.Where("is_active = ?", true).Find(&categories).Error
	if err != nil {
		log.Println("[ì¹´í…Œê³ ë¦¬ ë¡œë”© ì‹¤íŒ¨]:", err)
		return nil, err
	}
	return categories, nil
}

func showProductMenu(category string, chatID int64, msgID int, products map[string]Product) {
	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	orderList, orderOk := productOrder[category]
	if !orderOk {
		// orderListê°€ ì—†ìœ¼ë©´ products ë§µ ìˆœíšŒí•˜ë©° ë²„íŠ¼ ìƒì„±
		for _, p := range products {
			if !p.Active {
				continue
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "prod_"+category+"_"+p.Code)
			currentRow = append(currentRow, btn)
			count++
			if count%2 == 0 {
				rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
				currentRow = []tgbotapi.InlineKeyboardButton{}
			}
		}
	} else {
		// orderListì— ë§ê²Œ ë²„íŠ¼ ìƒì„±
		for _, name := range orderList {
			p, exists := products[name]
			if !exists || !p.Active {
				continue
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "prod_"+category+"_"+p.Code)
			currentRow = append(currentRow, btn)
			count++
			if count%2 == 0 {
				rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
				currentRow = []tgbotapi.InlineKeyboardButton{}
			}
		}
	}

	// ë‚¨ì€ ë²„íŠ¼ì´ ìˆìœ¼ë©´ í–‰ ì¶”ê°€
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ì¶”ê°€
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë’¤ë¡œê°€ê¸°", "go_catmenu"),
	))

	// ë©”ì‹œì§€ í¸ì§‘ ìš”ì²­ ìƒì„± ë° ì „ì†¡
	edit := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf("ğŸ“¦ <b>%s</b> ìƒí’ˆ ëª©ë¡", category))
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
}

var lastMenuMessageID = make(map[int64]int)

func getAllMonitoringWallets() ([]MonitoringWallet, error) {
	var wallets []MonitoringWallet
	err := db.Table("monitoring_wallets").Find(&wallets).Error
	if err != nil {
		return nil, fmt.Errorf("ëª¨ë‹ˆí„°ë§ ì§€ê°‘ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}
	return wallets, nil
}

func generateWalletAddress() (string, error) {
	bytes := make([]byte, 20)
	_, err := crand.Read(bytes)
	if err != nil {
		return "", err
	}
	return "T" + hex.EncodeToString(bytes), nil
}

func showAdminMenu(uid, chatID int64, messageID int) {
	// ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
	status := getStatusReport()

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.")
		return
	}

	text := "ğŸ‘‘ ê´€ë¦¬ì ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤. ğŸ‘‘\n\n" + status

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ìƒí’ˆê´€ë¦¬", "admin_inventory"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“† ì£¼ê°„í†µê³„", "weekly_stats"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸªª íšŒì›ëª©ë¡", "admin_member_menu"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‘¥ ë°©ë¬¸ìì¡°íšŒ", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š í†µê³„ë³´ê¸°", "admin_stats"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ì£¼ë¬¸ë‚´ì—­", "admin_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âš™ï¸ ì„¤ì •", "showAdminSettings"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”§ ê³ ê¸‰ê´€ë¦¬", "admin_advanced"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func getStatusReport() string {
	now := time.Now().Format("2006-01-02 15:04:05")

	// DB ìƒíƒœëŠ” í•­ìƒ OKë¡œ ê°€ì • (dummy)
	dbOK := true

	// ë”ë¯¸ê°’: í•„ìš”ì‹œ ì „ì—­ ë³€ìˆ˜/ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ê°¯ìˆ˜ êµ¬í•˜ê¸°
	orderCount := int64(1) // ë¯¸ì²˜ë¦¬ ì£¼ë¬¸ ì˜ˆì‹œ
	cardStock := int64(10) // ë‚¨ì€ ì¬ê³  ì˜ˆì‹œ
	userCount := int64(5)  // ê°€ì…ì ìˆ˜ ì˜ˆì‹œ

	uptime := time.Since(startTime).Truncate(time.Second).String()

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return fmt.Sprintf(
		"<b>ğŸ“Š BOT STATUS</b>\nâ° ì„œë²„ì‹œê°„: %s\nğŸŸ¢ DBìƒíƒœ: %s\nğŸ›’ ë¯¸ì²˜ë¦¬: %d\nğŸ’³ ì¬ê³ : %d\nğŸ™‹ ê°€ì…ì: %d\nâ± ì—…íƒ€ì„: %s\nğŸ’¾ ë©”ëª¨ë¦¬: %.2fMB",
		now,
		map[bool]string{true: "OK", false: "ì˜¤ë¥˜"}[dbOK],
		orderCount,
		cardStock,
		userCount,
		uptime,
		float64(m.Alloc)/1024/1024,
	)
}

func initDB() (*gorm.DB, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		os.Getenv("MYSQL_USER"),
		os.Getenv("MYSQL_PASSWORD"),
		os.Getenv("MYSQL_HOST"),
		os.Getenv("MYSQL_PORT"),
		os.Getenv("MYSQL_DB"),
	)

	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Error),
	})
	if err != nil {
		return nil, fmt.Errorf("DB ì—°ê²° ì‹¤íŒ¨: %w", err)
	}
	log.Println("âœ… DB ì—°ê²° ì„±ê³µ")

	// 1. Category í…Œì´ë¸” ë¨¼ì € ë§ˆì´ê·¸ë ˆì´ì…˜
	if err := db.AutoMigrate(&Category{}); err != nil {
		return nil, fmt.Errorf("ì¹´í…Œê³ ë¦¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %w", err)
	}

	// 2. ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ ì‹œë”© (ì˜ˆì‹œ)
	categories := []Category{
		{Name: "VPS", DisplayName: "VPS"},
		{Name: "ACCOUNT", DisplayName: "ACCOUNT"},
		{Name: "MEMBERSHIP", DisplayName: "MEMBERSHIP"},
		{Name: "ESIM", DisplayName: "ESIM"},
		{Name: "CARD", DisplayName: "CARD"},
	}
	for _, cat := range categories {
		var existing Category
		err := db.Where("name = ?", cat.Name).First(&existing).Error
		if err != nil {
			if err == gorm.ErrRecordNotFound {
				if err := db.Create(&cat).Error; err != nil {
					log.Printf("âŒ ì¹´í…Œê³ ë¦¬ ë“±ë¡ ì‹¤íŒ¨: %v", err)
				} else {
					log.Printf("âœ… ì¹´í…Œê³ ë¦¬ ë“±ë¡ ì™„ë£Œ: %s", cat.Name)
				}
			} else {
				log.Printf("âŒ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
			}
		} else {
			log.Printf("â„¹ï¸ ì¹´í…Œê³ ë¦¬ ì´ë¯¸ ì¡´ì¬: %s", cat.Name)
		}
	}

	// 3. Product í…Œì´ë¸” ë§ˆì´ê·¸ë ˆì´ì…˜
	if err := db.AutoMigrate(&Product{}); err != nil {
		return nil, fmt.Errorf("ìƒí’ˆ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %w", err)
	}
	log.Println("âœ… DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ")

	return db, nil
}

func getAdminChatID() int64 {
	return adminChatID
}

func handleWebhook(c *gin.Context) {
	var update tgbotapi.Update

	// 1. JSON ë°”ì¸ë”© ì‹œë„
	if err := c.ShouldBindJSON(&update); err != nil {
		log.Printf("ì›¹í›… JSON ë°”ì¸ë”© ì‹¤íŒ¨: %v", err)
		c.JSON(400, gin.H{"status": "bad request"})
		return
	}

	// 2. ë°”ì¸ë”© ì„±ê³µ ì‹œ ë¡œê·¸ ì¶œë ¥ ë° ì²˜ë¦¬
	log.Printf("[handleWebhook] update: %+v", update)
	processUpdate(update)

	// 3. ì²˜ë¦¬ ì™„ë£Œ ì‘ë‹µ
	c.JSON(200, gin.H{"status": "ok"})
}

func seedCategories(db *gorm.DB) error {
	categories := []Category{
		{Name: "VPS", DisplayName: "VPS"},
		{Name: "ACCOUNT", DisplayName: "ACCOUNT"},
		{Name: "MEMBERSHIP", DisplayName: "MEMBERSHIP"},
		{Name: "ESIM", DisplayName: "ESIM"},
		{Name: "CARD", DisplayName: "CARD"},
	}

	for _, cat := range categories {
		var existing Category
		err := db.Where("name = ?", cat.Name).First(&existing).Error
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				if err := db.Create(&cat).Error; err != nil {
					log.Printf("âŒ ì¹´í…Œê³ ë¦¬ ë“±ë¡ ì‹¤íŒ¨: %v", err)
				} else {
					log.Printf("âœ… ì¹´í…Œê³ ë¦¬ ë“±ë¡ ì™„ë£Œ: %s", cat.Name)
				}
			} else {
				log.Printf("âŒ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
			}
		} else {
			log.Printf("â„¹ï¸ ì¹´í…Œê³ ë¦¬ ì´ë¯¸ ì¡´ì¬: %s", cat.Name)
		}
	}

	return nil
}

func setWebhook(bot *tgbotapi.BotAPI, url string) error {
	webhookConfig, err := tgbotapi.NewWebhook(url)
	if err != nil {
		return err
	}
	_, err = bot.Request(webhookConfig)
	return err
}

func initBot() {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	var err error
	bot, err = tgbotapi.NewBotAPI(token)
	if err != nil {
		log.Fatalf("âŒ í…”ë ˆê·¸ë¨ ë´‡ ìƒì„± ì‹¤íŒ¨: %v", err)
	}
	log.Printf("ğŸ¤– ë´‡ ì‹œì‘ë¨: @%s", bot.Self.UserName)

	webhookURL := os.Getenv("WEBHOOK_URL")
	if webhookURL != "" {
		if err := setWebhook(bot, webhookURL); err != nil {
			log.Fatalf("âŒ ì›¹í›… ì„¤ì • ì‹¤íŒ¨: %v", err)
		}
		log.Printf("âœ… ì›¹í›… ì„¤ì • ì™„ë£Œ: %s", webhookURL)
	} else {
		log.Println("âš ï¸ WEBHOOK_URL í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ì›¹í›… ì„¤ì •í•˜ì§€ ì•ŠìŒ")
	}
}

func migrateDB(db *gorm.DB) error {
	if err := db.AutoMigrate(&Category{}); err != nil {
		return fmt.Errorf("ì¹´í…Œê³ ë¦¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %w", err)
	}

	if err := seedCategories(db); err != nil {
		return fmt.Errorf("ì¹´í…Œê³ ë¦¬ ì‹œë”© ì‹¤íŒ¨: %w", err)
	}

	if err := db.AutoMigrate(&Product{}); err != nil {
		return fmt.Errorf("ìƒí’ˆ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %w", err)
	}

	// MonitoringWallet í…Œì´ë¸” ì¶”ê°€ ë§ˆì´ê·¸ë ˆì´ì…˜
	if err := db.AutoMigrate(&MonitoringWallet{}); err != nil {
		return fmt.Errorf("ëª¨ë‹ˆí„°ë§ ì§€ê°‘ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %w", err)
	}

	return nil
}

func relaySupportMessage(fromUserID int64, text string) {
	// fromUserIDê°€ ìƒë‹´ì›ì¸ì§€ ìœ ì €ì¸ì§€ êµ¬ë¶„
	// ìƒë‹´ì›ì´ë¼ë©´ ìœ ì €ì—ê²Œ ë©”ì‹œì§€ ì „ë‹¬
	// ìœ ì €ë¼ë©´ ìƒë‹´ì›ì—ê²Œ ë©”ì‹œì§€ ì „ë‹¬

	var toUserID int64
	var isSupporter bool = false

	// ìƒë‹´ì›ì¼ ê²½ìš°
	for userID, adminID := range activeSupportSessions {
		if adminID == fromUserID {
			toUserID = userID
			isSupporter = true
			break
		}
	}
	if !isSupporter {
		// fromUserIDê°€ ìœ ì €ì¼ ê²½ìš°
		toUserID = activeSupportSessions[fromUserID]
	}

	if toUserID == 0 {
		// ìƒë‹´ ì„¸ì…˜ì´ ì—†ìœ¼ë©´ ë¬´ì‹œí•˜ê±°ë‚˜ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡
		return
	}

	// ë©”ì‹œì§€ ì „ì†¡
	msg := tgbotapi.NewMessage(toUserID, text)
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("ìƒë‹´ ë©”ì‹œì§€ ì¤‘ê³„ ì‹¤íŒ¨: %v", err)
	}
}

func processUpdate(update tgbotapi.Update) {
	if update.CallbackQuery != nil {
		handleCallback(update.CallbackQuery) // ê¸°ì¡´ handleCallbackQuery ëŒ€ì‹  handleCallback í˜¸ì¶œ
	} else if update.Message != nil {
		handleMessage(update.Message)
	} else {
		log.Printf("ì²˜ë¦¬í•˜ì§€ ì•ŠëŠ” ì—…ë°ì´íŠ¸ íƒ€ì…: %+v", update)
	}
}

func sendReplyKeyboard(uid, chatID int64) error {
	// ì´ì „ ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ë©”ì‹œì§€ ì‚­ì œ (ìˆìœ¼ë©´)
	if msgID, ok := userReplyKeyboardMsgID[uid]; ok && msgID != 0 {
		delMsg := tgbotapi.DeleteMessageConfig{
			ChatID:    chatID,
			MessageID: msgID,
		}
		if _, err := bot.Request(delMsg); err != nil {
			log.Printf("ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ì´ì „ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
		}
	}

	// ìƒˆ ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ë©”ì‹œì§€ ì „ì†¡
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ë‚´ ì •ë³´"),
			tgbotapi.NewKeyboardButton("ì—ë„ˆì§€"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ì£¼ë¬¸ë‚´ì—­"),
			tgbotapi.NewKeyboardButton("ê³ ê°ì„¼í„°"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	msg := tgbotapi.NewMessage(chatID, "PING ğŸ›œ") // ë¹ˆ í…ìŠ¤íŠ¸
	msg.ReplyMarkup = replyKeyboard

	sentMsg, err := bot.Send(msg)
	if err != nil {
		return err
	}

	userReplyKeyboardMsgID[uid] = sentMsg.MessageID
	return nil
}

func showMenu(uid int64, username string, chatID int64) {
	if username == "" {
		username = "unknown"
	}

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	introMsg := fmt.Sprintf(
		`<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b> : %d
ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b> : %s
â° : %s
<b>ë“±ê¸‰</b> : %s
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>`,
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	if isAdmin(uid) {
		introMsg += "\n<b>ê¶Œí•œ: ê´€ë¦¬ì</b>\n"
	}

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdmin(uid) {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("showMenu ì¸íŠ¸ë¡œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	if err := sendReplyKeyboard(uid, chatID); err != nil {
		log.Printf("showMenu ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì”ì•¡ ì¡°íšŒ í•¨ìˆ˜
func handleBalanceCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	var userBal UserBalance
	err := db.Where("user_id = ?", uid).First(&userBal).Error
	balance := 0.0
	if err == nil {
		balance = userBal.Balance
	}
	reply := fmt.Sprintf(
		"ğŸ‘¤ : <code>%d</code>\n\nğŸ’° ì”ì•¡ : %.3f USDT\n\nì…ê¸ˆì€ /ì…ê¸ˆ ì•ˆë‚´ ë©”ë‰´ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.",
		uid, balance,
	)
	sendTelegram(uid, reply)
}

func RoundFloat(val float64, precision int) float64 {
	ratio := math.Pow(10, float64(precision))
	return math.Round(val*ratio) / ratio
}

func showVPSMenu(uid, chatID int64, msgID int) {
	var vpsCat CardCategory
	err := db.Where("name = ?", "vps").First(&vpsCat).Error
	if err != nil {
		sendTelegram(chatID, "âŒ VPS ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		log.Printf("âŒ VPS ì¹´í…Œê³ ë¦¬ ë¡œë”© ì‹¤íŒ¨: %v", err)
		return
	}

	var products []CardProduct
	err = db.Where("category_id = ? AND is_active = ?", vpsCat.ID, true).Find(&products).Error
	if err != nil || len(products) == 0 {
		sendTelegram(chatID, "âŒ VPS ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		log.Printf("âŒ VPS ìƒí’ˆ ë¡œë”© ì‹¤íŒ¨: %v", err)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, "order_"+p.Name)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
	))

	msgText := "ğŸ–¥ï¸ <b>VPS / ê°€ìƒì„œë²„ ìƒí’ˆ ëª©ë¡</b>\n\nêµ¬ë§¤í•˜ì‹¤ ìƒí’ˆì„ ì„ íƒí•´ì£¼ì„¸ìš”."
	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showVPSMenu ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func showLanguageMenu(uid int64, chatID int64, msgID int) {
	text := "ğŸŒ ì–¸ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš” / Select Language"
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡°ğŸ‡·", "lang_ko"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡ºğŸ‡¸", "lang_en"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡¨ğŸ‡³", "lang_zh"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main"),
		),
	)

	if msgID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("showLanguageMenu ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showLanguageMenu ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
		}
	}
}

func handleLanguageSelection(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID

	var selectedLang string

	switch cb.Data {
	case "lang_ko":
		selectedLang = "ko"
	case "lang_en":
		selectedLang = "en"
	case "lang_zh":
		selectedLang = "zh"
	case "go_main":
		// ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(cb.Message.Chat.ID, cb.Message.MessageID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("[go_main] ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
			}
		}
		// ìƒˆ ë©”ë‰´ ì¶œë ¥ (showMenu í•¨ìˆ˜ëŠ” ì‚¬ìš©ì ID, username, chatIDë¥¼ ì¸ìë¡œ ë°›ëŠ”ë‹¤ê³  ê°€ì •)
		showMenu(uid, cb.From.UserName, chatID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
		return
	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤."))
		return
	}

	// ì–¸ì–´ ì €ì¥
	setUserLanguage(uid, selectedLang)

	// ì½œë°± ì‘ë‹µ ë° ë©”ë‰´ ë‹¤ì‹œ í‘œì‹œ
	bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸŒ ì–¸ì–´ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."))
	showMenu(uid, cb.From.UserName, chatID)
}

func setUserLanguage(uid int64, lang string) {
	// DBì— ì–¸ì–´ ì €ì¥ ë¡œì§ (ì˜ˆ: gorm ì‚¬ìš©)
	if err := db.Model(&User{}).Where("user_id = ?", uid).Update("lang", lang).Error; err != nil {
		log.Printf("[setUserLanguage] ì–¸ì–´ ì €ì¥ ì‹¤íŒ¨ uid=%d, lang=%s, err=%v", uid, lang, err)
	}
}

func setUserLang(uid int64, lang string) error {
	// ì˜ˆì‹œ: ìœ ì € í…Œì´ë¸”ì´ ìˆê³  lang í•„ë“œê°€ ìˆë‹¤ë©´
	err := db.Model(&User{}).Where("user_id = ?", uid).Update("lang", lang).Error
	return err
}

func showSupportMenu(chatID int64) {
	msgText := " ğŸ‘¤ ê³ ê°ì„¼í„° ë©”ë‰´ì…ë‹ˆë‹¤.\n\n ë¬¸ì˜ ë²„íŠ¼ì„ ëˆ„ë¥¸í›„ ëŒ€ê¸° í•´ì£¼ì„¸ìš”."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì‹¤ì‹œê°„ ë¬¸ì˜", "support_request"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main"),
		),
	)

	photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.ch.jpeg"))
	photo.Caption = msgText
	photo.ReplyMarkup = kb

	if _, err := bot.Send(photo); err != nil {
		log.Printf("ê³ ê°ì„¼í„° ë©”ë‰´(ì´ë¯¸ì§€) ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func getUserWallet(uid int64) string {
	var wallet UserWallet
	if err := db.Where("user_id = ?", uid).First(&wallet).Error; err != nil {
		log.Printf("[ì§€ê°‘ì¡°íšŒ] uid: %d â†’ ì¡°íšŒ ì‹¤íŒ¨: %v", uid, err)
		return ""
	}
	log.Printf("[ì§€ê°‘ì¡°íšŒ] uid: %d â†’ ì§€ê°‘ì£¼ì†Œ: %s", uid, wallet.Address)
	return wallet.Address
}

func isDepositProcessed(txID string) bool {
	processedTxsMu.RLock()
	processed, exists := processedTxs[txID]
	processedTxsMu.RUnlock()

	if exists && processed {
		return true
	}

	// ë©”ëª¨ë¦¬ì— ì—†ìœ¼ë©´ DB í™•ì¸ (ë“œë¬¼ê²Œë§Œ ë°œìƒ)
	var count int64
	if err := db.Model(&ProcessedDeposit{}).Where("tx_id = ?", txID).Count(&count).Error; err != nil {
		log.Printf("DB ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return false // DB ì˜¤ë¥˜ ì‹œ ì•ˆì „í•˜ê²Œ false ë¦¬í„´
	}
	if count > 0 {
		// DBì— ìˆìœ¼ë©´ ë©”ëª¨ë¦¬ ìºì‹œì—ë„ ì¶”ê°€
		processedTxsMu.Lock()
		processedTxs[txID] = true
		processedTxsMu.Unlock()
		return true
	}
	return false
}

func markDepositProcessed(txID string) {
	processedTxsMu.Lock()
	processedTxs[txID] = true
	processedTxsMu.Unlock()

	// DBì— ê¸°ë¡
	rec := ProcessedDeposit{TxID: txID}
	if err := db.Create(&rec).Error; err != nil {
		// ì¤‘ë³µ ì‚½ì… ë“± ì—ëŸ¬ ë¡œê·¸ë§Œ ê¸°ë¡
		log.Printf("DB ì €ì¥ ì‹¤íŒ¨ (ì¤‘ë³µ ê°€ëŠ¥): %v", err)
	}
}

// ë°©ë¬¸ì ê¸°ë³¸ ì •ë³´ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ (User íƒ€ì…)
func getUserListByPage(page, pageSize int) ([]User, error) {
	offset := (page - 1) * pageSize
	var users []User
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

// 2. ë°©ë¬¸ì ë¦¬ìŠ¤íŠ¸ ë©”ì‹œì§€ HTML í¬ë§·íŒ…
func formatUserListMessage(users []User, page, totalPages int) string {
	const pageSize = 10
	if len(users) == 0 {
		return "<b>ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(ì—†ìŒ)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}
		lastSeen := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\nìµœê·¼ ì ‘ì†: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			(i+1)+(page-1)*pageSize, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

// 3. ë°©ë¬¸ì ë¦¬ìŠ¤íŠ¸ í˜ì´ì§€ í‘œì‹œ í•¨ìˆ˜
func showUserListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, err := getUserListByPage(page, pageSize)
	if err != nil {
		sendTelegram(uid, "âŒ ë°©ë¬¸ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	var total int64
	err = db.Model(&User{}).Count(&total).Error
	if err != nil {
		sendTelegram(uid, "âŒ ì´ ë°©ë¬¸ì ìˆ˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// 5. ì½œë°± ì²˜ë¦¬ ì˜ˆì‹œ (handleCallback ë‚´ë¶€ ë˜ëŠ” ë³„ë„ í•¨ìˆ˜ë¡œ)
func handleVisitorCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	switch {
	case strings.HasPrefix(data, "visitor_page_"):
		pageStr := strings.TrimPrefix(data, "visitor_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("í˜ì´ì§€ %d ë¡œ ì´ë™", page)))

	case data == "admin_visitor_menu":
		// ê´€ë¦¬ì ë°©ë¬¸ì ë©”ë‰´ ë‹¤ì‹œ ë³´ì—¬ì£¼ê¸° (êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¦„)
		showAdminVisitorMenu(chatID, msgID, cb.ID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ë°©ë¬¸ì ë©”ë‰´"))

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´"))
	}
}

func getCategoryIDByName(name string) (uint, error) {
	var cat Category
	// LOWER()ë¥¼ ì¨ì„œ ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ì¡°íšŒ
	if err := db.Where("LOWER(name) = LOWER(?)", name).First(&cat).Error; err != nil {
		return 0, err
	}
	return cat.ID, nil
}

func getGradeEmoji(grade string) string {
	switch strings.ToLower(grade) {
	case "bronze":
		return "ğŸ¥‰"
	case "silver":
		return "ğŸ¥ˆ"
	case "gold":
		return "ğŸ¥‡"
	case "diamond":
		return "ğŸ’"
	case "vip":
		return "ğŸ‘‘"
	case "":
		return "â”" // ë“±ê¸‰ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°
	default:
		return "ğŸ¥‰"
	}
}

// showEnergyMenu í•¨ìˆ˜ ìˆ˜ì •ë³¸
func showEnergyMenu(uid int64, chatID int64, messageID int) {
	msgText := `<b>ğŸª« USDT ì†¡ê¸ˆ ìˆ˜ìˆ˜ë£Œ 80% ì ˆê°</b>

2.5 TRX â†’  65K ì—ë„ˆì§€  = 1íšŒ ì†¡ê¸ˆ
5.0 TRX â†’ 130kì—ë„ˆì§€  = 2íšŒ ì†¡ê¸ˆ

â¬‡ï¸ <b>ê²°ì œ ì£¼ì†Œ</b> â¬‡ï¸
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
<code>TDFfED6MK7hj6a9GXJMG3emXdd3b6XtHPn</code>
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
â¬†ï¸<b> ì£¼ì†Œ í´ë¦­ ì‹œ ìë™ ë³µì‚¬</b> â¬†ï¸

â± ì „ì†¡í›„ 10ì´ˆ ì´ë‚´ ì—ë„ˆì§€ ì¶©ì „
ì´ì²´í•˜ì‹¤ ì§€ê°‘ì— USDT ë¶€ì¡±ì‹œ 130k
ì†¡ê¸ˆ ì „ ìˆ˜ìˆ˜ë£Œ ê¸ˆì•¡ í™•ì¸ í›„ ì „ì†¡`

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageCaption(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showEnergyMenu ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v, ìƒˆ ë©”ì‹œì§€ë¡œ ëŒ€ì²´ ì „ì†¡ ì‹œë„", err)
			// í¸ì§‘ ì‹¤íŒ¨ ì‹œ ìƒˆ ë©”ì‹œì§€ ì „ì†¡
			photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.trx.jpeg"))
			photoMsg.Caption = msgText
			photoMsg.ParseMode = "HTML"
			photoMsg.ReplyMarkup = kb
			if _, err := bot.Send(photoMsg); err != nil {
				log.Printf("showEnergyMenu ì‚¬ì§„+ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
			}
		}
	} else {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("/home/minho/epusdt/images/energy_image.jpeg"))
		photoMsg.Caption = msgText
		photoMsg.ParseMode = "HTML"
		photoMsg.ReplyMarkup = kb

		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("showEnergyMenu ì‚¬ì§„+ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func getUserDisplayName(uid int64) string {
	var user User
	if err := db.Where("user_id = ?", uid).First(&user).Error; err != nil {
		return "ì•Œ ìˆ˜ ì—†ìŒ"
	}
	if user.Nickname != "" {
		return user.Nickname
	}
	if user.UserName != "" {
		return "@" + user.UserName
	}
	return "ì•Œ ìˆ˜ ì—†ìŒ"
}

func saveUserWallet(userID int64, wallet, username string) error {
	var wm WalletMap
	err := db.Where("user_id = ?", userID).First(&wm).Error

	if err == nil {
		// ê¸°ì¡´ ì‚¬ìš©ì â†’ ì—…ë°ì´íŠ¸
		wm.Wallet = wallet
		wm.Username = username
		if err = db.Save(&wm).Error; err != nil {
			log.Printf("âŒ saveUserWallet: ì €ì¥ ì‹¤íŒ¨ userID=%d â†’ %v", userID, err)
			return err
		}
		log.Printf("âœ… saveUserWallet: ê¸°ì¡´ ì§€ê°‘ ê°±ì‹  userID=%d", userID)
		return nil
	}

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// ì‹ ê·œ ì‚¬ìš©ì â†’ ìƒì„±
		wm = WalletMap{
			UserID:   userID,
			Wallet:   wallet,
			Username: username,
		}
		if err := db.Create(&wm).Error; err != nil {
			log.Printf("âŒ saveUserWallet: DB ìƒì„± ì‹¤íŒ¨ userID=%d â†’ %v", userID, err)
			return err
		}
		log.Printf("âœ… saveUserWallet: ìƒˆ ì§€ê°‘ ë“±ë¡ userID=%d", userID)
		return nil
	}

	// ì˜ˆì™¸ ì¼€ì´ìŠ¤: ì¡°íšŒ ì‹¤íŒ¨
	log.Printf("âŒ saveUserWallet: DB ì¡°íšŒ ì‹¤íŒ¨ userID=%d â†’ %v", userID, err)
	return err
}

func createDepositOrder(userID int64, amount float64) error {
	prodName := "USDT ì¶©ì „"
	price := amount

	order := Order{
		UserID:      userID,
		Product:     prodName,
		Amount:      price,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
	}

	if err := db.Create(&order).Error; err != nil {
		return err
	}

	addr := os.Getenv("COIN_PAYMENT_ADDR")
	qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
	_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

	msgText := fmt.Sprintf(
		"ğŸ’¸ <b>ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</b>\n\n"+
			"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•íˆ <code>%.3f USDT</code></b>ë¥¼ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n\n"+
			"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\n"+
			"â€¢ ì…ê¸ˆì£¼ì†Œ: <code>%s</code>\n"+
			"â€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
			"(QRì½”ë“œë¡œ ì†¡ê¸ˆ ê°€ëŠ¥, ì†Œìˆ˜ì ê¹Œì§€ ì •í™•íˆ!)",
		amount, order.ID, addr, amount,
	)

	msg := tgbotapi.NewMessage(userID, msgText)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	photo := tgbotapi.NewPhoto(userID, tgbotapi.FilePath(qrPath))
	photo.Caption = "QRì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê¸ˆì•¡ì´ ìë™ ì§€ì •ë©ë‹ˆë‹¤."
	photo.ParseMode = "HTML"
	bot.Send(photo)

	return nil
}

func showDepositConfirm(uid, chatID int64, msgID int, amount float64) {
	amountStr := fmt.Sprintf("%.3f", amount)
	encodedAmount := base64.StdEncoding.EncodeToString([]byte(amountStr))
	callbackData := "confirm_deposit_" + encodedAmount

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœ… í™•ì¸", callbackData),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "show_deposit_menu"),
		),
	)
	text := fmt.Sprintf("ğŸ’¸ <b>%.3f USDT</b> ì¶©ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", amount)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì…ê¸ˆ ì£¼ì†Œ ë° QRì½”ë“œ ì•ˆë‚´
func showDepositAddress(uid, chatID int64, messageID int, amount float64) {
	addr, err := getWalletAddress(uid)
	if err != nil || addr == "" {
		sendTelegram(chatID, "â—ï¸ ì…ê¸ˆ ì§€ê°‘ì´ ë“±ë¡ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.\n\në¨¼ì € <b>/ì…ê¸ˆì§€ê°‘ë“±ë¡ [ì§€ê°‘ì£¼ì†Œ]</b> ëª…ë ¹ì–´ë¡œ ë“±ë¡í•´ ì£¼ì„¸ìš”.")
		return
	}

	var username string
	if err := db.Model(&User{}).Select("username").Where("user_id = ?", uid).Take(&username).Error; err != nil {
		username = "-"
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf(
			"ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b>: <code>%d</code>\n"+
				"ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b>: %s\n\n"+
				"ğŸ’² <b>ì…ê¸ˆ ì•ˆë‚´</b>\n"+
				"ì…ê¸ˆ ì£¼ì†Œ: <code>%s</code>\n"+
				"ì…ê¸ˆ ê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
				"ì…ê¸ˆ ì™„ë£Œ í›„, ìë™ìœ¼ë¡œ ì”ì•¡ì´ ì¶©ì „ë©ë‹ˆë‹¤.",
			uid, username, addr, amount,
		),
	)
	editMsg.ParseMode = "HTML"

	if _, err = bot.Send(editMsg); err != nil {
		log.Printf("ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
	}

	qrFilename := fmt.Sprintf("./qrcodes/wallet_%d_%d.png", uid, time.Now().UnixNano())
	qrData := fmt.Sprintf("%s?amount=%.3f", addr, amount)

	if err := generateWalletQRCode(qrData, qrFilename); err == nil {
		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrFilename))
		photo.Caption = fmt.Sprintf(
			"ğŸ’³ <b>ì…ê¸ˆì£¼ì†Œ QR</b> (%.3f USDT)\n\n<code>%s</code>",
			amount, addr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("showDepositAddress: QRì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡ ì‹¤íŒ¨ chatID=%d err=%v", chatID, err)
		}
	} else {
		log.Printf("showDepositAddress: QR ìƒì„± ì‹¤íŒ¨ err=%v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ìƒì„¸ ëª©ë¡ í‘œì‹œ í•¨ìˆ˜ ì˜ˆì‹œ
func showAdminStockList(chatID int64, messageID int) {
	// TODO: DBì—ì„œ ì¬ê³  ëª©ë¡ ì¡°íšŒ í›„ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ë˜ëŠ” ë©”ì‹œì§€ í¸ì§‘ìœ¼ë¡œ ì¶œë ¥
	msgText := "ğŸ“‹ ì¬ê³  ìƒì„¸ ëª©ë¡ (ì˜ˆì‹œ)\n- ìƒí’ˆA: 10ê°œ\n- ìƒí’ˆB: 5ê°œ\n- ìƒí’ˆC: 0ê°œ\n"
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì¬ê³  ìƒì„¸ ëª©ë¡ ì¶œë ¥ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ì‚­ì œ ì•ˆë‚´ í•¨ìˆ˜ ì˜ˆì‹œ
func promptStockDeletion(chatID int64) {
	msgText := "ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\nì‚­ì œí•  ì¬ê³  í•­ëª© ì½”ë“œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ì¶”ê°€ ì•ˆë‚´ í•¨ìˆ˜ ì˜ˆì‹œ
func promptStockAddition(chatID int64) {
	msgText := "â• ì¬ê³  ì¶”ê°€ ê¸°ëŠ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\nì¶”ê°€í•  ì¬ê³  í•­ëª© ì •ë³´ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì¬ê³  ì¶”ê°€ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ í•¨ìˆ˜ ì˜ˆì‹œ
func showAdminMainMenu(chatID int64, messageID int) {
	msgText := "ğŸ‘‘ ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ì…ë‹ˆë‹¤."
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ ì¶œë ¥ ì‹¤íŒ¨: %v", err)
	}
}

// ì½œë°± ì²˜ë¦¬ ì˜ˆì‹œ
func handleDepositCallbacks(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	if strings.HasPrefix(data, "confirm_deposit_") {
		encodedAmount := strings.TrimPrefix(data, "confirm_deposit_")
		decodedBytes, err := base64.StdEncoding.DecodeString(encodedAmount)
		if err != nil {
			sendTelegram(uid, "âŒ ì¶©ì „ ê¸ˆì•¡ í™•ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
			return
		}
		amountStr := string(decodedBytes)
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ì¶©ì „ ê¸ˆì•¡ íŒŒì‹±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
			return
		}

		err = createDepositOrder(uid, amount) // DBì— ì£¼ë¬¸ ìƒì„± í•¨ìˆ˜
		if err != nil {
			sendTelegram(uid, "âŒ ì¶©ì „ ì£¼ë¬¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
			return
		}

		sendTelegram(uid, fmt.Sprintf("âœ… %.3f USDT ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", amount))
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."))
		return
	}

	if strings.HasPrefix(data, "deposit_") {
		amountStr := strings.TrimPrefix(data, "deposit_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ì…ê¸ˆ ê¸ˆì•¡ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.")
			return
		}

		showDepositAddress(uid, chatID, msgID, amount) // ì…ê¸ˆ ì£¼ì†Œ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì…ê¸ˆ ì•ˆë‚´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."))
		return
	}
}

// ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ í‘œì‹œ
func showAdminStockMenuSimple(chatID int64, messageID int) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ìƒì„¸ ë³´ê¸°", "admin_stock_list")},
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ", "admin_stock_delete")},
		{tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³  ì¶”ê°€", "admin_stock")},
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ“¦ ì¬ê³  ê´€ë¦¬", "admin_stock_menu")}, // <- ë°°ì—´ë¡œ ë¬¶ìŒ
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu")},
	}

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, "ê´€ë¦¬ìë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.")
		edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
		if _, err := bot.Send(edit); err != nil {
			log.Printf("ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, "ê´€ë¦¬ìë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.")
		msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(rows...)
		if _, err := bot.Send(msg); err != nil {
			log.Printf("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func handleAdminStockMenuCallbacks(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	// ê´€ë¦¬ì ê¶Œí•œ ì²´í¬
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì´ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	switch {
	case data == "admin_stock_list":
		showAdminStockList(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ëª©ë¡ í‘œì‹œ"))
		return

	case data == "admin_stock_delete":
		promptStockDeletion(chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì‚­ì œ ì•ˆë‚´"))
		return

	case data == "admin_stock_add":
		promptStockAddition(chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì¶”ê°€ ì•ˆë‚´"))
		return

	case data == "admin_main_menu":
		showAdminMainMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ í‘œì‹œ"))
		return

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´"))
		return
	}
}

func buildProductButtons(products []Product) [][]tgbotapi.InlineKeyboardButton {
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		rows = append(rows,
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ", fmt.Sprintf("admin_add_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("â„¹ï¸ ìƒì„¸", fmt.Sprintf("admin_stock_detail_%d", p.ID)),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("âœï¸ ìˆ˜ì •", fmt.Sprintf("admin_edit_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ ì‚­ì œ", fmt.Sprintf("admin_del_stock_%d", p.ID)),
			),
		)
	}
	return rows
}

func showAdminVisitorMenu(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“… ë‹¹ì¼ ë°©ë¬¸ì", "admin_list_visitors_today"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“† ì „ì²´ ë°©ë¬¸ì", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ‘¥ ë°©ë¬¸ì ì¡°íšŒ ë©”ë‰´")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨")); callbackErr != nil {
			log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

// ìƒˆë¡œìš´ ë°©ì‹ì˜ ì¼ì¼ ë§¤ì¶œ í†µê³„ ì¡°íšŒ
func getDailyStatsNew() (SalesStats, error) {
	today := time.Now().Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func createUserActivityKeyboard(page, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	var navButtons []tgbotapi.InlineKeyboardButton

	// ì´ì „ í˜ì´ì§€ ë²„íŠ¼ (ì²« í˜ì´ì§€ê°€ ì•„ë‹ ê²½ìš°ì—ë§Œ í‘œì‹œ)
	if page > 1 {
		navButtons = append(navButtons, tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸", fmt.Sprintf("visitors_page_%d", page-1)))
	}
	// ë‹¤ìŒ í˜ì´ì§€ ë²„íŠ¼ (ë§ˆì§€ë§‰ í˜ì´ì§€ê°€ ì•„ë‹ ê²½ìš°ì—ë§Œ í‘œì‹œ)
	if page < totalPages {
		navButtons = append(navButtons, tgbotapi.NewInlineKeyboardButtonData("â¡ï¸", fmt.Sprintf("visitors_page_%d", page+1)))
	}

	// ì´ì „/ë‹¤ìŒ ë²„íŠ¼ì´ ìˆë‹¤ë©´ í•œ ì¤„ë¡œ ì¶”ê°€
	if len(navButtons) > 0 {
		rows = append(rows, navButtons)
	}

	// í•­ìƒ ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ì¶”ê°€ (ìƒˆ í–‰ìœ¼ë¡œ)
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
	))

	// ì¸ë¼ì¸ í‚¤ë³´ë“œ ë§ˆí¬ì—… ìƒì„±
	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

// .env íŒŒì¼ì— ngrok ë° ê´€ë ¨ URL ìë™ ì—…ë°ì´íŠ¸
func updateEnvNgrokURL(envPath, newURL string) error {
	data, err := os.ReadFile(envPath)
	if err != nil {
		return err
	}

	lines := strings.Split(string(data), "\n")
	updates := map[string]string{
		"NGROK_URL":         "NGROK_URL=" + newURL,
		"WEBHOOK_URL":       "WEBHOOK_URL=" + newURL + "/webhook",
		"EPUSDT_API_URL":    "EPUSDT_API_URL=" + newURL + "/api/notify/set",
		"EPUSDT_NOTIFY_URL": "EPUSDT_NOTIFY_URL=" + newURL + "/epusdt_notify",
	}

	keysUpdated := make(map[string]bool)
	var newLines []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			newLines = append(newLines, line)
			continue
		}
		parts := strings.SplitN(trimmed, "=", 2)
		key := parts[0]
		if val, ok := updates[key]; ok && !keysUpdated[key] {
			newLines = append(newLines, val)
			keysUpdated[key] = true
		} else {
			newLines = append(newLines, line)
		}
	}

	// ìƒˆë¡œ ì¶”ê°€í•  í‚¤ë“¤ ì¶”ê°€
	for key, val := range updates {
		if !keysUpdated[key] {
			newLines = append(newLines, val)
		}
	}

	output := strings.Join(newLines, "\n") + "\n"
	return os.WriteFile(envPath, []byte(output), 0644)
}

func answerCallbackQuery(callbackID, text string) {
	callback := tgbotapi.NewCallback(callbackID, text)
	if _, err := bot.Request(callback); err != nil {
		log.Printf("CallbackQuery ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

func processTronTransaction(tx TronTransaction) {
	// 1. processedTxs ë§µì— TXID ì¤‘ë³µ ì—¬ë¶€ ì²´í¬ (ë®¤í…ìŠ¤ ë™ê¸°í™”)
	processedTxsMu.Lock()
	if processedTxs[tx.TxID] {
		processedTxsMu.Unlock()
		return // ì´ë¯¸ ì²˜ë¦¬ëœ íŠ¸ëœì­ì…˜ì´ë©´ ë¬´ì‹œ
	}
	processedTxs[tx.TxID] = true
	processedTxsMu.Unlock()

	// 2. DBì—ì„œ TXID ì¤‘ë³µ ì¡°íšŒ (ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€)
	var existing Order
	if err := db.Where("tx_id = ?", tx.TxID).First(&existing).Error; err == nil {
		return // ì´ë¯¸ ë“±ë¡ëœ ì£¼ë¬¸ì´ë©´ ë¬´ì‹œ
	}

	// 3. ì…ê¸ˆ ê¸ˆì•¡ íŒŒì‹±
	amount, err := strconv.ParseFloat(tx.AmountStr, 64)
	if err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì…ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨ txid=%s, value=%s", tx.TxID, tx.AmountStr)
		return
	}

	// 4. DBì—ì„œ ì…ê¸ˆëŒ€ê¸°ì¤‘ ìƒíƒœì´ê³  ì •í™•í•œ ê¸ˆì•¡ ë˜ëŠ” ê·¼ì ‘ ê¸ˆì•¡ ì£¼ë¬¸ ì¡°íšŒ
	var order Order
	err = db.Where("expected_amt = ? AND status = ?", amount, "ì…ê¸ˆëŒ€ê¸°ì¤‘").First(&order).Error
	if err != nil {
		err = db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.001, amount+0.001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").First(&order).Error
	}
	if err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: amount=%.3f", amount)
		createUnmatchedOrder(amount, tx) // ë¯¸ë§¤ì¹­ ì£¼ë¬¸ ë³„ë„ ì²˜ë¦¬
		return
	}

	// 5. ì£¼ë¬¸ì— TXID ë“±ë¡ ë° DB ì €ì¥
	setOrderTxID(&order, tx.TxID)
	if err := db.Save(&order).Error; err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
		return
	}

	// 6. ì”ì•¡ì¶©ì „ ìƒí’ˆì¸ ê²½ìš° ì”ì•¡ë§Œ ì¶©ì „í•˜ê³  ì¢…ë£Œ
	if order.Product == "ì”ì•¡ì¶©ì „" {
		if err := addUserBalance(order.UserID, order.Amount); err != nil {
			sendTelegram(order.UserID, "âŒ ì”ì•¡ ì¶©ì „ ì‹¤íŒ¨! ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.")
			log.Printf("[ì”ì•¡ì¶©ì „] ì˜¤ë¥˜: %v", err)
		} else {
			sendTelegram(order.UserID, fmt.Sprintf("âœ… %.3f USDT ì”ì•¡ì´ ì¶©ì „ë˜ì—ˆìŠµë‹ˆë‹¤!", order.Amount))
		}
		return
	}

	// 7. ì‚¬ìš©ìì—ê²Œ ì…ê¸ˆ í™•ì¸ ë©”ì‹œì§€ ë°œì†¡
	userMsg := fmt.Sprintf(
		"ğŸŸ¢ *ì…ê¸ˆ í™•ì¸ ì™„ë£Œ!*\n\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ“‹ ì£¼ë¬¸ë²ˆí˜¸: #%d\n"+
			"ğŸ“¦ ìƒí’ˆëª…: %s\n"+
			"ğŸ’° ì…ê¸ˆê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— íŠ¸ëœì­ì…˜: `%s`\n"+
			"â° í™•ì¸ì‹œê°„: %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"âœ… ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n"+
			"ğŸš€ ìƒí’ˆì´ ê³§ ìë™ìœ¼ë¡œ ì§€ê¸‰ë©ë‹ˆë‹¤.",
		order.ID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	msg := tgbotapi.NewMessage(order.UserID, userMsg)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	// 8. ê´€ë¦¬ìì—ê²Œ ì…ê¸ˆ í™•ì¸ ë¡œê·¸ ì „ì†¡
	adminMsg := fmt.Sprintf(
		"ğŸŸ¢ *ì…ê¸ˆ í™•ì¸ (ë§¤ì¹­ë¨)*\n\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ“‹ ì£¼ë¬¸ë²ˆí˜¸: #%d\n"+
			"ğŸ‘¤ ìœ ì €ë„¤ì„: %d\n"+
			"ğŸ“¦ ìƒí’ˆ: %s\n"+
			"ğŸ’° ê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— TxID: `%s`\n"+
			"â° ì‹œê°„: %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"âœ… ìë™ ì¹´ë“œ ì§€ê¸‰ ì²˜ë¦¬ ì¤‘...",
		order.ID, order.UserID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	adminMsgObj := tgbotapi.NewMessage(unmatchedAdminChatID, adminMsg)
	adminMsgObj.ParseMode = "HTML"
	bot.Send(adminMsgObj)

	// 9. ìë™ ì¹´ë“œ ì§€ê¸‰ ì²˜ë¦¬ ë¹„ë™ê¸° ì‹¤í–‰
	go func(orderID uint, userID int64, txID string) {
		if err := processOrderWithValidation(orderID, txID); err != nil {
			log.Printf("[ìë™ì§€ê¸‰] ì‹¤íŒ¨ orderID=%d, err=%v", orderID, err)
			msg := tgbotapi.NewMessage(userID, "âŒ ì§€ê¸‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê³ ê°ì„¼í„°ë¡œ ë¬¸ì˜í•˜ì„¸ìš”.")
			bot.Send(msg)
		}
	}(order.ID, order.UserID, tx.TxID)
}

// TxID ì„¤ì • ë³´ì¡° í•¨ìˆ˜ (sql.NullString íƒ€ì…ì— ëŒ€ì‘)
func setOrderTxID(order *Order, txID string) {
	order.TxID = &txID // âœ… string ê°’ë§Œ í• ë‹¹
}

func toFixed3(f float64) float64 {
	return math.Floor(f*1000) / 1000
}

func notifySend(chatID int64, msg string) {
	sendTelegram(chatID, msg)
	// sendTelegramì´ ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì—ëŸ¬ ì²´í¬ ë¶ˆê°€
}
func showUserStats(chatID int64, msgID int) {
	count, err := getUserCount()
	if err != nil {
		sendTelegram(chatID, "ìœ ì € ì¹´ìš´íŠ¸ ì¡°íšŒ ì‹¤íŒ¨")
		return
	}
	text := fmt.Sprintf("ì „ì²´ ê°€ì… ìœ ì € ìˆ˜: %dëª…", count)
	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	bot.Send(msg)
}

func getUsersByPageFromAllUsers(page, pageSize int) ([]User, error) {
	allUsers, err := getAllUsers()
	if err != nil {
		return nil, err
	}

	start := (page - 1) * pageSize
	if start >= len(allUsers) {
		return []User{}, nil
	}

	end := start + pageSize
	if end > len(allUsers) {
		end = len(allUsers)
	}

	return allUsers[start:end], nil
}

// í•œ ë²ˆì— 10ëª…ì”©, í˜ì´ì§€ë„¤ì´ì…˜ ì§€ì›
func getAllUsers() ([]User, error) {
	var users []User
	if err := db.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

func getUserCount() (int64, error) {
	var count int64
	err := db.Model(&User{}).Count(&count).Error
	return count, err
}

func showAdminAllUsersMenu(chatID int64, messageID int, page int) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}

	users, err := getUsersByPageFromAllUsers(page, pageSize)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì „ì²´ ìœ ì € ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ë” ì´ìƒ ì¡°íšŒí•  ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤.")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("ğŸ‘¥ ì „ì²´ ìœ ì € (Page %d)\n\n", page)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(ë‹‰ë„¤ì„ì—†ìŒ)"
		}
		username := user.UserName
		if username == "" {
			username = "ì—†ìŒ"
		}
		text += fmt.Sprintf("%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1+(page-1)*pageSize, nickname, user.UserID, username, user.LastSeen.Format("01-02 15:04"))

		btn := tgbotapi.NewInlineKeyboardButtonData(
			nickname,
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼
	var navigation []tgbotapi.InlineKeyboardButton
	if page > 1 {
		navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ", fmt.Sprintf("admin_all_users_page_%d", page-1)))
	}
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"))
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("â¡ï¸ ", fmt.Sprintf("admin_all_users_page_%d", page+1)))

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(navigation...))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Request(msg)
}

func showAdminCategoryMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	var rows [][]tgbotapi.InlineKeyboardButton

	// 2ê°œì”© ë²„íŠ¼ì„ ë¬¶ì–´ í•œ í–‰(row)ì— ì¶”ê°€
	for i := 0; i < len(categories); i += 2 {
		end := i + 2
		if end > len(categories) {
			end = len(categories)
		}
		var row []tgbotapi.InlineKeyboardButton
		for _, cat := range categories[i:end] {
			var callbackData string
			if cat == "VPS" {
				callbackData = "menu_vps" // VPSëŠ” ë³„ë„ ë©”ë‰´ë¡œ ì—°ê²°
			} else {
				callbackData = "admin_cat_" + cat
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(cat, callbackData)
			row = append(row, btn)
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ“‚ìƒí’ˆìˆ˜ì • ì¹´í…Œê³ ë¦¬ ì„ íƒ")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func addProductsByCategory(db *gorm.DB, productsByCategory map[string][]Product) error {
	for categoryName, products := range productsByCategory {
		catID, err := getCategoryIDByName(categoryName)
		if err != nil {
			log.Printf("âŒ [%s] ì¹´í…Œê³ ë¦¬ ID ì¡°íšŒ ì‹¤íŒ¨: %v", categoryName, err)
			continue
		}
		for _, p := range products {
			p.CategoryID = catID
			var existing Product
			err := db.Where("code = ?", p.Code).First(&existing).Error
			if err != nil {
				if err == gorm.ErrRecordNotFound {
					if err := db.Create(&p).Error; err != nil {
						log.Printf("âŒ [%s] ìƒí’ˆ ë“±ë¡ ì‹¤íŒ¨: %v", p.Code, err)
					} else {
						log.Printf("âœ… [%s] ìƒí’ˆ ë“±ë¡ ì™„ë£Œ (ì¹´í…Œê³ ë¦¬ID: %d)", p.Code, catID)
					}
				} else {
					log.Printf("âŒ [%s] ì¡°íšŒ ì‹¤íŒ¨: %v", p.Code, err)
				}
			} else {
				log.Printf("â„¹ï¸ [%s] ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìƒí’ˆ, ìƒëµ", p.Code)
			}
		}
	}
	return nil
}

// ë¯¸ë§¤ì¹­ ì…ê¸ˆ ì£¼ë¬¸ ìƒì„± ë° ê´€ë¦¬ì ì•Œë¦¼
func createUnmatchedOrder(amount float64, tx TronTransaction) {
	unmatchedMsg := fmt.Sprintf(
		"ğŸŸ¢ *ì…ê¸ˆ ì•Œë¦¼*\n\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"+
			"ğŸ’° ê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— íŠ¸ëœì­ì…˜: `%s`\n"+
			"â° ì‹œê°„: %s\n"+
			"ğŸ“¤ ë³´ë‚¸ì£¼ì†Œ: `%s`\n"+
			"ğŸ“¥ ë°›ì€ì£¼ì†Œ: `%s`\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"+
			"â“ ìƒíƒœ: ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤\n"+
			"ğŸ’¡ ì¡°ì¹˜: ìˆ˜ë™ í™•ì¸ í•„ìš”\n\n"+
			"ğŸ” ì£¼ë¬¸ë²ˆí˜¸ì™€ ê¸ˆì•¡ ë‹¤ì‹œ í™•ì¸ ë¶€íƒë“œë¦½ë‹ˆë‹¤.",
		amount, tx.TxID, time.Now().Format("2006-01-02 15:04:05"),
		tx.From, tx.To,
	)

	notifySend(unmatchedAdminChatID, unmatchedMsg)

	txID := tx.TxID
	order := Order{
		UserID:      0,
		Product:     "ë¯¸ìƒ",
		Amount:      amount,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: amount,
		TxID:        &txID, // í¬ì¸í„° í• ë‹¹
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("ë¯¸ë§¤ì¹­ ì…ê¸ˆ ì£¼ë¬¸ ì €ì¥ ì‹¤íŒ¨: %v", err)
	}
}

func updateUserGrade(userID int64, newGrade string) error {
	// 1. ë“±ê¸‰ ì—…ë°ì´íŠ¸
	if err := db.Model(&User{}).Where("user_id = ?", userID).Update("grade", newGrade).Error; err != nil {
		log.Printf("ë“±ê¸‰ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ userID=%d, newGrade=%s, err=%v", userID, newGrade, err)
		return err
	}

	// 2. ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
	var user User
	if err := db.Where("user_id = ?", userID).First(&user).Error; err != nil {
		log.Printf("ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ userID=%d, err=%v", userID, err)
		// ë“±ê¸‰ ë³€ê²½ì€ ì„±ê³µí–ˆìœ¼ë¯€ë¡œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
		return nil
	}

	username := user.UserName
	if username == "" {
		username = "unknown"
	}

	if user.ChatID == 0 {
		log.Printf("ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: chatIDê°€ 0ì…ë‹ˆë‹¤. userID=%d", userID)
		return nil
	}

	msgText := fmt.Sprintf(
		"ğŸ”” <b>íšŒì› ë“±ê¸‰ ë³€ê²½ ì•Œë¦¼</b>\n\n"+
			"ìœ ì €ë„¤ì„: <b>@%s</b> ë‹˜\n"+
			"ë“±ê¸‰ì´ ì„±ê³µì ìœ¼ë¡œ <b>%s</b> ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"+
			"ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ê²½í—˜í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤.\n"+
			"WELCOME",
		username, newGrade,
	)

	msg := tgbotapi.NewMessage(user.ChatID, msgText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("íšŒì› ë“±ê¸‰ ë³€ê²½ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨ userID=%d: %v", userID, err)
	}

	return nil
}

// â”€â”€â”€ value(AmountStr) â†’ float64 ë³€í™˜ ìœ í‹¸ â”€â”€â”€
func parseUSDTAmount(raw string) float64 {
	val, _ := strconv.ParseFloat(raw, 64)
	return val / 1_000_000 // TRC20 USDTëŠ” ì†Œìˆ˜ì  6ìë¦¬(1 USDT == 1,000,000)
}

// â”€â”€â”€ íƒ€ì„ìŠ¤íƒ¬í”„(ms) â†’ ì‚¬ëŒì´ ì½ì„ ìˆ˜ ìˆëŠ” ë‚ ì§œ â”€â”€â”€
func formatTronTimestamp(ts int64) string {
	return time.UnixMilli(ts).Format("2006-01-02 15:04:05")
}

func getTronDeposits(address string) ([]Deposit, error) {
	apiKey := getTronGridAPIKey()
	if apiKey == "" {
		return nil, fmt.Errorf("íŠ¸ë¡ ê·¸ë¦¬ë“œ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
	}

	usdtContract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 ë©”ì¸ë„· ì»¨íŠ¸ë™íŠ¸

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=50&contract_address=%s",
		address, usdtContract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	req.Header.Set("Accept", "application/json")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("íŠ¸ë¡ ê·¸ë¦¬ë“œ API ì‘ë‹µ ì˜¤ë¥˜: %d %s", resp.StatusCode, string(body))
	}

	var apiResp struct {
		Data []struct {
			TxID      string `json:"transaction_id"`
			Value     string `json:"value"`
			Timestamp int64  `json:"block_timestamp"`
			From      string `json:"from"`
			To        string `json:"to"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, err
	}

	var deposits []Deposit
	for _, tx := range apiResp.Data {
		if !strings.EqualFold(tx.To, address) {
			continue
		}

		amount, err := strconv.ParseFloat(tx.Value, 64)
		if err != nil {
			log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì…ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨ txid=%s, value=%s", tx.TxID, tx.Value)
			continue
		}
		amount = amount / 1_000_000

		deposits = append(deposits, Deposit{
			TxID:   tx.TxID,
			Amount: amount,
			Time:   time.UnixMilli(tx.Timestamp),
		})
	}
	return deposits, nil
}

func handleBroadcastInput(uid int64, text string) {
	// ì…ë ¥ ì·¨ì†Œ
	if text == "/cancel" {
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, "ì „ì²´ ê³µì§€ ì…ë ¥ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
		return
	}

	// ì „ì²´ ìœ ì € ì±„íŒ…ID ì¡°íšŒ
	var users []User
	err := db.Select("chat_id").Find(&users).Error
	if err != nil {
		sendTelegram(uid, "âŒ ì „ì²´ ìœ ì € ì¡°íšŒ ì‹¤íŒ¨")
		pendingBroadcastInput[uid] = false
		return
	}

	count := 0
	for _, user := range users {
		if user.ChatID == 0 {
			continue
		}
		_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "ğŸ“¢ <b>ê³µì§€ì‚¬í•­</b>\n\n"+text))
		if err != nil {
			log.Printf("ê³µì§€ ë°œì†¡ ì‹¤íŒ¨: chat_id=%d, error=%v", user.ChatID, err)
			continue
		}
		count++
		time.Sleep(50 * time.Millisecond) // API ì œí•œ íšŒí”¼ìš© ì¡°ì ˆ ê°€ëŠ¥
	}

	pendingBroadcastInput[uid] = false
	sendTelegram(uid, fmt.Sprintf("âœ… %dëª…ì—ê²Œ ê³µì§€ë¥¼ ë°œì†¡í–ˆìŠµë‹ˆë‹¤.", count))
}

// ì…ê¸ˆ í™•ì¸ ë° ì£¼ë¬¸ ë§¤ì¹­ ì²˜ë¦¬ (ê°„ê²° ë¡œê·¸ ë²„ì „)
func processTronDeposits() {
	wallets, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] ì§€ê°‘ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return
	}

	log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] %dê°œ ì§€ê°‘ ëª¨ë‹ˆí„°ë§ ì‹œì‘", len(wallets))

	var (
		totalDeposits  int
		matchedCount   int
		unmatchedCount int
	)

	for _, wallet := range wallets {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] %s... ì…ê¸ˆ ì¡°íšŒ ì‹¤íŒ¨: %v", wallet.Address[:10], err)
			continue
		}
		totalDeposits += len(deposits)

		for _, deposit := range deposits {
			if isDepositProcessed(deposit.TxID) {
				continue
			}

			// ì£¼ë¬¸ ë§¤ì¹­ í™•ì¸
			var existingOrder Order
			matchErr := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
				deposit.Amount-0.0001, deposit.Amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
				First(&existingOrder).Error

			if matchErr == nil {
				matchedCount++
				log.Printf("[ì…ê¸ˆë§¤ì¹­] ì£¼ë¬¸ #%d, ê¸ˆì•¡: %.3f USDT, TxID: %.8s...", existingOrder.ID, deposit.Amount, deposit.TxID)
			} else {
				unmatchedCount++
				log.Printf("[ë¯¸ë§¤ì¹­ì…ê¸ˆ] %.3f USDT (TxID: %.8s...)", deposit.Amount, deposit.TxID)
			}

			processTronTransaction(TronTransaction{
				TxID:      deposit.TxID,
				From:      "", // í•„ìš”ì‹œ ì±„ìš°ê¸°
				To:        wallet.Address,
				AmountStr: fmt.Sprintf("%f", deposit.Amount),
				Timestamp: deposit.Time.UnixMilli(),
			})
			markDepositProcessed(deposit.TxID)
		}
	}

	// ìµœì¢… ìš”ì•½
	if totalDeposits > 0 {
		log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] ìš”ì•½: ì´ %dê±´ | ë§¤ì¹­ %d | ë¯¸ë§¤ì¹­ %d", totalDeposits, matchedCount, unmatchedCount)
	}
}

// ì…ê¸ˆ ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
func startDepositMonitoring() {
	go func() {
		ticker := time.NewTicker(40 * time.Second)
		defer ticker.Stop()
		log.Println("ğŸ” ì…ê¸ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘... (40ì´ˆ ê°„ê²©)")
		for {
			processTronDeposits()
			<-ticker.C
		}
	}()
}

func sendTelegram(chatID int64, message string) error {
	if strings.TrimSpace(message) == "" {
		log.Printf("âš ï¸ sendTelegram í˜¸ì¶œ ì‹œ ë¹ˆ ë©”ì‹œì§€ì…ë‹ˆë‹¤. chatID=%d", chatID)
		return fmt.Errorf("ë¹ˆ ë©”ì‹œì§€")
	}
	msg := tgbotapi.NewMessage(chatID, message)
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
	return err
}

// ì „ì²´ ë°©ë¬¸ì ì¡°íšŒ (ì¤‘ë³µ ì—†ì´ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡)
func getAllVisitors() ([]Visitor, error) {
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen FROM (
			SELECT user_id, user_name, last_seen,
				ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_seen DESC) as rn
			FROM users
		) t
		WHERE rn = 1
		ORDER BY last_seen DESC
	`).Scan(&visitors).Error
	return visitors, err
}

// íŠ¹ì • ë‚ ì§œ ë°©ë¬¸ì ì¡°íšŒ
func getVisitorsByDate(date time.Time) ([]Visitor, error) {
	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)

	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen
		FROM users
		WHERE last_seen BETWEEN ? AND ?
		ORDER BY last_seen DESC
	`, start, end).Scan(&visitors).Error
	return visitors, err
}

func handleCoinPaymentUnified(cb *tgbotapi.CallbackQuery, uid int64, chatID int64, orderID uint64) {
	// 1. ì½œë°± ë°ì´í„° nil ì²´í¬ ë° ë¡œê·¸
	if cb != nil {
		log.Printf("[handleCoinPaymentUnified] ì½œë°± ë°ì´í„° ìˆìŒ: %s", cb.Data)
	} else {
		log.Println("[handleCoinPaymentUnified] ì½œë°± ë°ì´í„°ê°€ nilì…ë‹ˆë‹¤. ì½œë°± ì‘ë‹µ ì—†ì´ ì²˜ë¦¬í•©ë‹ˆë‹¤.")
	}

	// 2. ì£¼ë¬¸ ì •ë³´ DBì—ì„œ ì¡°íšŒ
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		sendTelegram(uid, "âŒ ì£¼ë¬¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		if cb != nil {
			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "ì£¼ë¬¸ ì •ë³´ ì—†ìŒ")); err != nil {
				log.Printf("ì½œë°± ì‘ë‹µ ì‹¤íŒ¨: %v", err)
			}
		}
		return
	}

	// 3. ì£¼ë¬¸ ìƒíƒœ í™•ì¸ (ì…ê¸ˆëŒ€ê¸°ì¤‘ì¸ì§€)
	if order.Status != "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
		sendTelegram(uid, "âŒ ì´ë¯¸ ì²˜ë¦¬ëœ ì£¼ë¬¸ì…ë‹ˆë‹¤.")
		if cb != nil {
			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "ì´ë¯¸ ì²˜ë¦¬ëœ ì£¼ë¬¸")); err != nil {
				log.Printf("ì½œë°± ì‘ë‹µ ì‹¤íŒ¨: %v", err)
			}
		}
		return
	}

	// 4. ê²°ì œ ì£¼ì†Œ í™˜ê²½ë³€ìˆ˜ í™•ì¸
	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		log.Println("âš ï¸ COIN_PAYMENT_ADDR í™˜ê²½ë³€ìˆ˜ ì„¤ì • ì•ˆë¨")
		sendTelegram(uid, "âŒ ê²°ì œ ì£¼ì†Œê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.")
		return
	}

	// 5. QR ì½”ë“œ ìƒì„±
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID)
	paymentURI := fmt.Sprintf("%s?amount=%.3f", coinAddr, order.ExpectedAmt)
	if err := generateWalletQRCode(paymentURI, qrPath); err != nil {
		log.Printf("QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨: %v", err)
	}

	// 6. ì£¼ë¬¸ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡
	msgText := fmt.Sprintf(
		"ğŸ›’ <b>ì£¼ë¬¸ ì ‘ìˆ˜ ì™„ë£Œ</b>\n\n"+
			"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\nâ€¢ ìƒí’ˆëª…: <b>%s</b>\nâ€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
			"(ì†Œìˆ˜ì ê¹Œì§€ ì •í™•í•˜ê²Œ, QR ì½”ë“œ í™œìš© ê¶Œì¥)\n20ë¶„ ë‚´ ë¯¸ì…ê¸ˆì‹œ ìë™ì·¨ì†Œ ë©ë‹ˆë‹¤.",
		order.ID, order.Product, order.ExpectedAmt,
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì£¼ë¬¸ì·¨ì†Œ", fmt.Sprintf("cancel_order_%d", order.ID)),
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("ì£¼ë¬¸ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	// 7. userMessageIDs ë§µ nil ì²´í¬ ë° ì´ˆê¸°í™”
	if userMessageIDs == nil {
		userMessageIDs = make(map[int64][]int)
	}
	userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)

	// 8. QR ì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡
	if qrPath != "" {
		photo := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(qrPath))
		photo.Caption = fmt.Sprintf(
			"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•í•œ ê¸ˆì•¡</b>ì„ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n<code>%s</code>\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\nì£¼ì†Œ í´ë¦­ì‹œ ë³µì‚¬ ë©ë‹ˆë‹¤.",
			coinAddr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("QR ì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}

	// 9. 20ë¶„ ë¯¸ì…ê¸ˆ ìë™ì·¨ì†Œ ê³ ë£¨í‹´ ì‹œì‘
	go func(orderID uint64, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
			ord.Status = "ìë™ì·¨ì†Œ"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("ì£¼ë¬¸ ìë™ì·¨ì†Œ ì €ì¥ ì‹¤íŒ¨: %v", err)
			}
			sendTelegram(userID, fmt.Sprintf("âŒ ì£¼ë¬¸ #%d 20ë¶„ ë‚´ ë¯¸ì…ê¸ˆìœ¼ë¡œ ìë™ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.", orderID))
		}
	}(uint64(order.ID), uid)

	// 10. ì½œë°± ì‘ë‹µ (cb ì¡´ì¬ ì‹œì—ë§Œ)
	if cb != nil {
		if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "ì£¼ë¬¸ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.")); err != nil {
			log.Printf("ì½œë°± ì‘ë‹µ ì‹¤íŒ¨: %v", err)
		}
	}
}

func sendTelegramHTML(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ (chatID=%d): %v", chatID, err)
	}
}

func handleAdminListVisitors(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
		return
	}

	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil {
		log.Printf("[handleAdminListVisitors] DB ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		sendTelegram(uid, "âŒ DB ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
		return
	}
	if len(activities) == 0 {
		sendTelegram(uid, "âš ï¸ ìµœê·¼ ë°©ë¬¸ìê°€ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ì „ì²´ ë°©ë¬¸ì ëª©ë¡ (ìµœì‹  50ëª…)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, act := range activities {
		username := "(ì—†ìŒ)"
		if act.Username != "" {
			username = "@" + act.Username
		}

		nickname := "(ì´ë¦„ ì—†ìŒ)"
		if act.Nickname != "" {
			nickname = act.Nickname
		}

		lastActive := "(ë¯¸ê¸°ë¡)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code>\nâ€¢ %s / %s\nâ€¢ ğŸ•’ ìµœê·¼ í™œë™: <i>%s</i>\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

	msg := tgbotapi.NewMessage(uid, sb.String())
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[handleAdminListVisitors] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func handleAdminListVisitorsToday(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
		return
	}

	today := time.Now().Format("2006-01-02")

	var visitors []UserActivityLog
	err := db.Where("DATE(last_active) = ?", today).Order("last_active DESC").Find(&visitors).Error
	if err != nil || len(visitors) == 0 {
		sendTelegram(uid, "âŒ ì˜¤ëŠ˜ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë°©ë¬¸ì ì—†ìŒ")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ“… ì˜¤ëŠ˜ ë°©ë¬¸ì ëª©ë¡</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, v := range visitors {
		username := v.Username
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}
		lastActive := v.LastActive.Format("15:04")

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n  ìµœê·¼ í™œë™: %s\n\n",
			i+1, v.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

	sendTelegram(uid, sb.String())
}

func showAdminProductDetail(chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(chatID, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	stockCount, err := getCardStock(product.Name)
	if err != nil {
		stockCount = 0
	}

	text := fmt.Sprintf(
		"ğŸ“„ <b>ìƒí’ˆ ìƒì„¸</b>\n\n"+
			"â€¢ ì´ë¦„: %s\n"+
			"â€¢ ê°€ê²©: %.2f USDT\n"+
			"â€¢ ì„¤ëª…: %s\n"+
			"â€¢ ì¬ê³ : %d\n",
		product.Name, product.Price, product.Description, stockCount,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", fmt.Sprintf("admin_add_stock_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“¦ ì¬ê³  ê´€ë¦¬", "admin_stock_menu"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœï¸ ìƒí’ˆìˆ˜ì •", fmt.Sprintf("admin_edit_product_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ ìƒí’ˆì‚­ì œ", fmt.Sprintf("admin_delete_product_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ìƒí’ˆëª©ë¡", fmt.Sprintf("admin_cat_back_%d", product.CategoryID)),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func sendTelegramSafe(chatID int64, text string) {
	if strings.TrimSpace(text) == "" {
		log.Printf("sendTelegram í˜¸ì¶œ ì‹œ ë¹ˆ ë©”ì‹œì§€ ì°¨ë‹¨ chatID=%d", chatID)
		return
	}
	sendTelegram(chatID, text)
}

func showTodayVisitorsMenu(chatID int64, messageID int) {
	// ì˜¤ëŠ˜ ë‚ ì§œ 00:00 ~ 23:59 ê¸°ì¤€
	today := time.Now().Format("2006-01-02")
	var users []User
	// last_seen ë˜ëŠ” last_login ì¹¼ëŸ¼ ê¸°ì¤€ (ì¹¼ëŸ¼ ì´ë¦„ì— ë§ê²Œ ìˆ˜ì •)
	err := db.Where("DATE(last_seen) = ?", today).Order("last_seen DESC").Find(&users).Error
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì˜¤ëŠ˜ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "ì˜¤ëŠ˜ ë°©ë¬¸ìê°€ ì—†ìŠµë‹ˆë‹¤.")
		bot.Request(msg)
		return
	}

	text := "ğŸ‘€ <b>ì˜¤ëŠ˜ ë°©ë¬¸ì (ìµœì‹ ìˆœ)</b>\n\n"
	for i, u := range users {
		text += fmt.Sprintf("%d. <code>%d</code> @%s (%s)\n",
			i+1, u.UserID, u.UserName, u.LastSeen.Format("15:04"))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ë©”ì¸ìœ¼ë¡œ", "admin_visitor_menu"),
		),
	)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

// QRì½”ë“œ ìƒì„± í•¨ìˆ˜
func generateWalletQRCode(data string, filename string) error {
	if data == "" {
		log.Println("QRì½”ë“œ ìƒì„± ìŠ¤í‚µ: ì£¼ì†Œ(ë°ì´í„°) ì—†ìŒ")
		return fmt.Errorf("QRì½”ë“œ ìƒì„± ì‹¤íŒ¨: ì…ë ¥ ë°ì´í„° ì—†ìŒ")
	}

	// íŒŒì¼ ì €ì¥ ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
	dir := filepath.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		log.Printf("QRì½”ë“œ ì €ì¥ í´ë” ìƒì„± ì‹¤íŒ¨: %v", err)
		return fmt.Errorf("QRì½”ë“œ í´ë” ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	// QRì½”ë“œ íŒŒì¼ ìƒì„±
	if err := qrcode.WriteFile(data, qrcode.Medium, 256, filename); err != nil {
		log.Printf("QRì½”ë“œ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: %v", err)
		return fmt.Errorf("QRì½”ë“œ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	return nil // ì„±ê³µ
}

func findMatchingOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: %.6f", amount)
	}
	return &order, nil
}

// íŠ¸ë¡ ê·¸ë¦¬ë“œ API í‚¤ ê°€ì ¸ì˜¤ê¸°
func getTronGridAPIKey() string {
	apiKey := os.Getenv("TRONGRID_API_KEY")
	if apiKey == "" {
		log.Println("âš ï¸ TRONGRID_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	return apiKey
}

func getUsersByPage(limit int, offset int) ([]User, error) {
	var users []User
	err := db.Limit(limit).Offset(offset).Find(&users).Error
	return users, err
}

func showAllVisitorsMenu(chatID int64, messageID int) {
	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil || len(activities) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì „ì²´ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë°©ë¬¸ì ì—†ìŒ")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ì „ì²´ ë°©ë¬¸ì (ìµœì‹  50ëª…)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}
		lastActive := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n  ìµœê·¼ í™œë™: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”\n")

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ë©”ì¸ìœ¼ë¡œ", "admin_visitor_menu"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func handleStart(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	username := msg.From.UserName
	sendTelegram(uid, "")
	showMenu(uid, username, chatID) // ê´„í˜¸ì™€ ì¸ì ì¶”ê°€!
}

func formatUserActivitiesMessagePaged(activities []UserActivityLog, page, pageSize int) string {
	total := len(activities)
	if total == 0 {
		return "ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."
	}

	start := (page - 1) * pageSize
	if start >= total {
		return fmt.Sprintf("ğŸ“„ í˜ì´ì§€ %d ëŠ” ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ %d í˜ì´ì§€ê¹Œì§€ ì¡´ì¬í•©ë‹ˆë‹¤.", page, (total+pageSize-1)/pageSize)
	}

	end := start + pageSize
	if end > total {
		end = total
	}

	totalPages := (total + pageSize - 1) / pageSize

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n", page, totalPages))

	for _, act := range activities[start:end] {
		lastActive := "(ê¸°ë¡ ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(ì—†ìŒ)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ <code>%d</code> | %s / @%s\n  ğŸ•’ %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			act.UserID, nickname, username, lastActive,
		))
	}

	return sb.String()
}

func showAdminBroadcastMenu(chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ“¢ <b>ì „ì²´ ê³µì§€ ëª¨ë“œ</b>\n\nëª¨ë“  ì‚¬ìš©ìì—ê²Œ ë³´ë‚¼ ê³µì§€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.\n\nì·¨ì†Œ: /cancel")
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("âŒ ì „ì²´ê³µì§€ ë©”ë‰´ í‘œì‹œ ì‹¤íŒ¨: %v", err)
	}
}

func matchOrderByDepositAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.0001, amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
		Order("id ASC").First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("âŒ ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ (ì…ê¸ˆì•¡: %.6f)", amount)
	}
	return &order, nil
}

func getVisitorPaginationKeyboard(currentPage, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var navRow []tgbotapi.InlineKeyboardButton

	if currentPage > 1 {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ì´ì „", fmt.Sprintf("visitor_page_%d", currentPage-1)),
		)
	} else {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("ã€€", "noop"),
		)
	}

	navRow = append(navRow,
		tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("ğŸ“„ %d / %d", currentPage, totalPages), "noop"),
	)

	if currentPage < totalPages {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("ë‹¤ìŒ â¡ï¸", fmt.Sprintf("visitor_page_%d", currentPage+1)),
		)
	} else {
		navRow = append(navRow,
			tgbotapi.NewInlineKeyboardButtonData("ã€€", "noop"),
		)
	}

	backRow := tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë’¤ë¡œê°€ê¸°", "admin_visitor_menu"),
	)

	return tgbotapi.NewInlineKeyboardMarkup(navRow, backRow)
}

func showVisitorListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, total, err := getVisitors(page, pageSize)
	if err != nil {
		sendTelegram(uid, "âŒ ë°©ë¬¸ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	visitors := convertUsersToVisitors(users)
	msgText := formatVisitorListMessage(visitors, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func convertUsersToVisitors(users []User) []Visitor {
	visitors := make([]Visitor, len(users))
	for i, u := range users {
		visitors[i] = Visitor{
			UserID:   u.UserID,
			UserName: sql.NullString{String: u.UserName, Valid: u.UserName != ""},
			Nickname: u.Nickname, // ë‹‰ë„¤ì„ ì¶”ê°€ í•„ë“œ
			LastSeen: u.LastSeen,
		}
	}
	return visitors
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func showVisitorListPageByDate(uid, chatID int64, messageID int, date time.Time, page int) {
	const pageSize = 10

	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)

	var visitors []Visitor
	var total int64

	err := db.Where("last_seen BETWEEN ? AND ?", start, end).
		Order("last_seen DESC").
		Limit(pageSize).
		Offset((page - 1) * pageSize).
		Find(&visitors).Error
	if err != nil {
		sendTelegram(uid, "âŒ ë°©ë¬¸ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	db.Model(&Visitor{}).Where("last_seen BETWEEN ? AND ?", start, end).Count(&total)

	var sb strings.Builder
	msgText := fmt.Sprintf("<b>ğŸ‘¥ ë°©ë¬¸ì (%s, %dëª… ì¤‘ %d~%d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n",
		start.Format("2006-01-02"),
		total,
		(page-1)*pageSize+1,
		min(page*pageSize, int(total)),
	)
	sb.WriteString(msgText)

	for i, v := range visitors {
		// username
		usernameStr := "ì—†ìŒ"
		if v.UserName.Valid && v.UserName.String != "" {
			usernameStr = "@" + v.UserName.String
		}

		// last seen
		lastSeen := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !v.LastSeen.IsZero() {
			lastSeen = v.LastSeen.Format("15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <i>%s</i>\n  ìµœê·¼: %s\n\n",
			(page-1)*pageSize+i+1, v.UserID, usernameStr, lastSeen,
		))
	}

	// í•˜ë‹¨ ì´ë™ ë²„íŠ¼ ë“± í•„ìš”ì‹œ ì¶”ê°€
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ë©”ì¸ìœ¼ë¡œ", "admin_visitor_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func showAdminMemberMenu(chatID int64, msgID int) {
	var members []User
	err := db.Limit(20).Order("created_at desc").Find(&members).Error
	if err != nil {
		sendTelegram(chatID, "âŒ íšŒì› ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		return
	}
	if len(members) == 0 {
		sendTelegram(chatID, "íšŒì›ì´ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>íšŒì› ëª©ë¡ (ìµœëŒ€ 20ëª…)</b>\n\n")
	for _, m := range members {
		userDisplay := html.EscapeString(m.UserName)
		if userDisplay == "" {
			userDisplay = "ì´ë¦„ì—†ìŒ"
		}
		sb.WriteString(fmt.Sprintf("â€¢ %s (ID: %d)\n", userDisplay, m.UserID))
	}

	// ê° íšŒì›ë³„ ë“±ê¸‰ ë³€ê²½ ë²„íŠ¼ ìƒì„±
	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, m := range members {
		userIDStr := fmt.Sprintf("%d", m.UserID)
		row := tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‰", "admin_set_grade_bronze_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥ˆ", "admin_set_grade_silver_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‡", "admin_set_grade_gold_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’", "admin_set_grade_diamond_"+userIDStr),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘", "admin_set_grade_vip_"+userIDStr),
		)
		keyboardRows = append(keyboardRows, row)
	}

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼
	backRow := tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
	)
	keyboardRows = append(keyboardRows, backRow)

	kb := tgbotapi.NewInlineKeyboardMarkup(keyboardRows...)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminSettingsMenu(chatID int64, messageID int) {
	text := "<b>âš™ï¸ ê´€ë¦¬ì ì„¤ì •</b>\n\nê¸°ëŠ¥ ì„¤ì •ì„ ê´€ë¦¬í•©ë‹ˆë‹¤."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì„¤ì • ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func showAdvancedAdminMenu(uid int64, chatID int64, msgID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("DB ìƒíƒœ í™•ì¸", "admin_db_status"),
			tgbotapi.NewInlineKeyboardButtonData("ì„œë²„ ìƒíƒœ", "admin_server_status"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
		),
	)

	msgText := "<b>ê³ ê¸‰ ê´€ë¦¬ì ë©”ë‰´</b>\n\ní•„ìš”í•œ ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”."

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, int(msgID), msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminInventoryMenu(chatID int64, msgID int) {
	type StockSummary struct {
		Category string
		Count    int64
	}
	var results []StockSummary

	err := db.Model(&StockCard{}).
		Select("category, COUNT(*) as count").
		Where("used = ?", false).
		Group("category").
		Scan(&results).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ì¬ê³  í˜„í™©ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ì¬ê³  í˜„í™©</b>\n\n")
	for _, r := range results {
		sb.WriteString(fmt.Sprintf("â€¢ %s: %dê°œ\n", html.EscapeString(r.Category), r.Count))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³  ì¶”ê°€", "admin_add_stock"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ§¹ ì¬ê³  ì •ë¦¬", "admin_cleanup_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ MEMBERSHIP ìƒì„¸", "admin_cat_MEMBERSHIP"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ESIM ìƒì„¸", "admin_cat_ESIM"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ CARD ìƒì„¸", "admin_cat_CARD"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ACCOUNT ìƒì„¸", "admin_cat_ACCOUNT"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showStockListByCategory(chatID int64, msgID int, category string) {
	var stocks []StockCard
	err := db.Where("category = ? AND used = ?", category, false).Find(&stocks).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ì¬ê³  ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		return
	}

	if len(stocks) == 0 {
		sendTelegram(chatID, "âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ì‚¬ìš© ê°€ëŠ¥í•œ ì¬ê³ ê°€ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>%s ì¹´í…Œê³ ë¦¬ ì¬ê³  ëª©ë¡</b>\n\n", html.EscapeString(category)))
	for i, stock := range stocks {
		content := html.EscapeString(stock.Content)
		sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, content))
		if i >= 29 { // ìµœëŒ€ 30ê°œ í‘œì‹œ ì œí•œ
			sb.WriteString("...\n")
			break
		}
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¬ê³  í˜„í™©ìœ¼ë¡œ", "admin_stock"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

// ê´€ë¦¬ì ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ ë©”ë‰´
func showAdminOrdersMenu(chatID int64, msgID int) {
	var orders []Order
	err := db.Order("created_at desc").Limit(10).Find(&orders).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ì£¼ë¬¸ ë‚´ì—­ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		return
	}

	if len(orders) == 0 {
		sendTelegram(chatID, "ì£¼ë¬¸ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ (ìµœëŒ€ 10ê±´)</b>\n\n")
	for _, o := range orders {
		sb.WriteString(fmt.Sprintf("â€¢ ì£¼ë¬¸ë²ˆí˜¸: %d\n  ìƒí’ˆëª…: %s\n  ê¸ˆì•¡: %.2f USDT\n  ìƒíƒœ: %s\n\n",
			o.ID, html.EscapeString(o.Product), o.Amount, o.Status))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func formatVisitorListMessage(visitors []Visitor, page, totalPages int) string {
	if len(visitors) == 0 {
		return "<b>ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	for i, v := range visitors {
		username := "(ì—†ìŒ)"
		if v.UserName.Valid {
			username = "@" + v.UserName.String
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}
		lastSeen := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !v.LastSeen.IsZero() {
			lastSeen = v.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\nìµœê·¼ ì ‘ì†: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			(i+1)+(page-1)*10, v.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

func handleAdminCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì´ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	switch {
	// ë°©ë¬¸ì í˜ì´ì§€ë³„ ì¡°íšŒ: visitors_page_ìˆ«ì
	case strings.HasPrefix(data, "visitors_page_"):
		pageStr := strings.TrimPrefix(data, "visitors_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			sendTelegram(uid, "âŒ ì˜¬ë°”ë¥´ì§€ ì•Šì€ í˜ì´ì§€ ë²ˆí˜¸ì…ë‹ˆë‹¤.")
			return
		}

		// DBì—ì„œ ëª¨ë“  UserActivityLog ì¡°íšŒ
		var activities []UserActivityLog
		if err := db.Order("last_active DESC").Find(&activities).Error; err != nil {
			sendTelegram(uid, "âŒ ë°©ë¬¸ì ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
			return
		}

		pageSize := 10
		msgText := formatUserActivitiesMessagePaged(activities, page, pageSize)

		kb := createUserActivityKeyboard(page, (len(activities)+pageSize-1)/pageSize)

		edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("í˜ì´ì§€ %d ë¡œ ì´ë™", page)))
		return

	// ì „ì²´ ê³µì§€ ë©”ë‰´ í˜¸ì¶œ
	case data == "admin_broadcast_menu":
		showAdminBroadcastMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì „ì²´ ê³µì§€ ë©”ë‰´ í‘œì‹œ"))
		return

	// ê·¸ ì™¸ ê¸°ë³¸ ê´€ë¦¬ì ë©”ë‰´
	case data == "admin_menu":
		showAdminMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ë©”ë‰´ í‘œì‹œ"))
		return

	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´"))
	}
}

// ì¬ê³ ê´€ë¦¬ ì½œë°± ì²˜ë¦¬ í•¨ìˆ˜
func handleAdminStockCallbacks(cb *tgbotapi.CallbackQuery) {
	if cb == nil || cb.Data == "" {
		return
	}

	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	data := cb.Data

	// ì¬ê³  ì¶”ê°€
	if strings.HasPrefix(data, "admin_add_stock_") {
		idStr := strings.TrimPrefix(data, "admin_add_stock_")
		productID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ìƒí’ˆ IDì…ë‹ˆë‹¤.")
			return
		}
		pendingStockInput[uid] = strconv.Itoa(productID)

		cancelKb := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("ì·¨ì†Œ"),
				tgbotapi.NewKeyboardButton("ë‚˜ê°€ê¸°"),
			),
		)
		msg := tgbotapi.NewMessage(uid, "ì¶”ê°€í•  <b>ì¬ê³  ì½”ë“œ</b>ë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥í•˜ì„¸ìš”.\nì…ë ¥ ì™„ë£Œ ì‹œ 'ì™„ë£Œ' ì…ë ¥!")
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = cancelKb
		bot.Send(msg)

		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì¶”ê°€ ëŒ€ê¸°ì¤‘"))
		return
	}

	// ìƒí’ˆ ìƒì„¸ë³´ê¸°
	if strings.HasPrefix(data, "admin_stock_detail_") {
		idStr := strings.TrimPrefix(data, "admin_stock_detail_")
		productID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ìƒí’ˆ IDì…ë‹ˆë‹¤.")
			return
		}
		showAdminStockDetail(chatID, msgID, productID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ìƒì„¸ í‘œì‹œ"))
		return
	}

	// ì¬ê³  ìˆ˜ì •
	if strings.HasPrefix(data, "admin_edit_stock_") {
		idStr := strings.TrimPrefix(data, "admin_edit_stock_")
		stockID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ì¬ê³  IDì…ë‹ˆë‹¤.")
			return
		}
		showAdminEditStock(chatID, msgID, stockID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ìˆ˜ì • í™”ë©´ í‘œì‹œ"))
		return
	}

	// ì¬ê³  ì‚­ì œ
	if strings.HasPrefix(data, "admin_del_stock_") {
		idStr := strings.TrimPrefix(data, "admin_del_stock_")
		stockID, err := strconv.Atoi(idStr)
		if err != nil {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ì¬ê³  IDì…ë‹ˆë‹¤.")
			return
		}
		promptConfirmDeleteStock(uid, chatID, msgID, stockID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ í™•ì¸ ëŒ€ê¸°"))
		return
	}
}

func visitorsToUsers(visitors []Visitor) []User {
	users := visitorsToUsers(visitors)
	for _, v := range visitors {
		username := ""
		if v.UserName.Valid {
			username = v.UserName.String
		}
		users = append(users, User{
			UserID:   v.UserID,
			UserName: username,
			Nickname: v.Nickname,
			LastSeen: v.LastSeen,
		})
	}
	return users
}

// ìœ ì €IDë¡œ ë“±ë¡ëœ íŠ¸ë¡ (USDT) ì§€ê°‘ ì£¼ì†Œ ì¡°íšŒ
func getWalletAddress(uid int64) (string, error) {
	var walletMap WalletMap
	err := db.Where("user_id = ?", uid).First(&walletMap).Error
	if err != nil || walletMap.Wallet == "" {
		return "", fmt.Errorf("ë“±ë¡ëœ ì§€ê°‘ ì—†ìŒ")
	}
	return walletMap.Wallet, nil
}

func handleAdminMonthlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "ğŸ“Š ì›”ê°„ ë¦¬í¬íŠ¸\n\n" +
		"â€¢ ì´ ë§¤ì¶œ: 1,000,000 USDT\n" +
		"â€¢ ì´ ì£¼ë¬¸ ìˆ˜: 1500ê±´\n" +
		"â€¢ ì¸ê¸° ìƒí’ˆ: VPS 1ê°œì›”\n" +
		"â€¢ ì‹ ê·œ ê°€ì…ì: 200ëª…\n\n" +
		"ğŸ“… í•´ë‹¹ ë‹¬ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì›”ê°„ ë¦¬í¬íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "ì›”ê°„ ë¦¬í¬íŠ¸ í‘œì‹œ"))
}

func handleAdminYearlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "ğŸ“Š ì—°ê°„ ë¦¬í¬íŠ¸\n\n" +
		"â€¢ ì´ ë§¤ì¶œ: 12,000,000 USDT\n" +
		"â€¢ ì´ ì£¼ë¬¸ ìˆ˜: 18,000ê±´\n" +
		"â€¢ ì¸ê¸° ìƒí’ˆ: VPS 1ë…„\n" +
		"â€¢ ì‹ ê·œ ê°€ì…ì: 2,500ëª…\n\n" +
		"ğŸ“… í•´ë‹¹ ì—°ë„ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì—°ê°„ ë¦¬í¬íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "ì—°ê°„ ë¦¬í¬íŠ¸ í‘œì‹œ"))
}

func promptEditProduct(uid, chatID int64, msgID int, productID int) {
	// DBì—ì„œ ìƒí’ˆ ì •ë³´ ì¡°íšŒ
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		log.Printf("âŒ ìƒí’ˆ ì¡°íšŒ ì‹¤íŒ¨: ID=%d, UID=%d, ì˜¤ë¥˜=%v", productID, uid, err)
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	// uidë³„ ìˆ˜ì • ëŒ€ê¸°ìƒíƒœ ì €ì¥
	pendingEditProduct[uid] = productID

	// ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡
	msg := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf(
		"ğŸ”§ <b>ìƒí’ˆ ì •ë³´ ìˆ˜ì •</b>\n\n"+
			"â€¢ í˜„ì¬ ì´ë¦„: <code>%s</code>\nâ€¢ í˜„ì¬ ê°€ê²©: <b>%.2f USDT</b>\n\n"+
			"âœï¸ ìˆ˜ì •í•  <b>ì´ë¦„:ê°€ê²©</b>ì„ ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”.\n"+
			"ì˜ˆ: <code>%s:%.2f</code>",
		prod.Name, prod.Price, prod.Name, prod.Price,
	))
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ğŸ”§ promptEditProduct ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func sendCaptchaChallenge(chatID int64, a, b, correctAnswer int) {
	// ì˜µì…˜ ë¦¬ìŠ¤íŠ¸ ìƒì„± ë° ëœë¤ ì„ê¸°
	options := []int{correctAnswer, correctAnswer + 1, correctAnswer - 1}
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	text := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ”’<b>PRIVATE ACCESS ONLY</b>\n"+
			"ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\n"+
			"ì•„ë˜ ë¬¸ì œë¥¼ í’€ì–´ í•´ì œ í•˜ì„¸ìš”.\n\n"+
			"<b>%d + %d = ?</b>\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>",
		a, b,
	)

	var btns []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		btns = append(btns,
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), fmt.Sprintf("verify_%d", opt)),
		)
	}

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(btns...),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = markup
	bot.Send(msg)
}

// ìƒë‹´ì› ì—¬ë¶€ ì²´í¬ í—¬í¼ í•¨ìˆ˜
func isSupporter(userID int64) bool {
	for _, adminID := range activeSupportSessions {
		if adminID == userID {
			return true
		}
	}
	return false
}

func handleMessage(msg *tgbotapi.Message) {
	if msg == nil {
		return
	}

	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	text := strings.TrimSpace(msg.Text)

	username := ""
	if msg.From != nil {
		username = msg.From.UserName
	}
	isAdminUser := isAdmin(uid)

	// ì‚¬ì§„ ë©”ì‹œì§€ ì²˜ë¦¬
	if len(msg.Photo) > 0 {
		handlePhotoMessage(msg)
		return
	}

	// ë¯¸ì¸ì¦ ì‚¬ìš©ì ìº¡ì±  ì²˜ë¦¬
	if !verifiedUsers[uid] {
		a, b, ans := generateCaptcha()
		verificationAnswers[uid] = ans
		sendCaptchaChallenge(chatID, a, b, ans)
		return
	}

	// --- ì§€ê°‘ ë“±ë¡ ì…ë ¥ ëŒ€ê¸° ìƒíƒœ ì²˜ë¦¬ ---
	if pendingWalletInput[uid] {
		if text == "/cancel" {
			pendingWalletInput[uid] = false
			sendTelegram(chatID, "ì§€ê°‘ ë“±ë¡ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			return
		}

		if isValidTronAddress(text) {
			err := saveUserWallet(uid, text, username)
			if err != nil {
				sendTelegram(chatID, "âŒ ì§€ê°‘ ë“±ë¡ ì‹¤íŒ¨: "+err.Error())
			} else {
				sendTelegram(chatID, "âœ… ì§€ê°‘ì´ ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.")
				log.Printf("[ì§€ê°‘ë“±ë¡] uid:%d, ì£¼ì†Œ: %s", uid, text)
			}
		} else {
			sendTelegram(chatID, "âŒ ìœ íš¨í•˜ì§€ ì•Šì€ TRON ì£¼ì†Œì…ë‹ˆë‹¤. ë‹¤ì‹œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
		}
		pendingWalletInput[uid] = false
		return
	}
	// ì „ì²´ ê³µì§€ ì…ë ¥ ì¤‘
	if pendingBroadcastInput[uid] {
		if text == "/cancel" {
			pendingBroadcastInput[uid] = false
			sendTelegram(uid, "ì „ì²´ ê³µì§€ ì…ë ¥ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			return
		}
		var users []User
		err := db.Select("chat_id").Find(&users).Error
		if err != nil {
			sendTelegram(uid, "âŒ ì „ì²´ ìœ ì € ì¡°íšŒ ì‹¤íŒ¨")
			pendingBroadcastInput[uid] = false
			return
		}
		successCount := 0
		for _, user := range users {
			if user.ChatID == 0 {
				continue
			}
			_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "ğŸ“¢ [ê³µì§€]\n\n"+text))
			if err == nil {
				successCount++
			}
			time.Sleep(30 * time.Millisecond)
		}
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, fmt.Sprintf("âœ… ì´ %dëª…ì—ê²Œ ê³µì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤.", successCount))
		return
	}

	// ìƒí’ˆ ì¶”ê°€ ëŒ€ê¸° ìƒíƒœ
	if pid, ok := pendingEditProduct[uid]; ok {
		if text == "ì·¨ì†Œ" || text == "ë‚˜ê°€ê¸°" || text == "/cancel" {
			delete(pendingEditProduct, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "âŒ ìƒí’ˆ ì¶”ê°€ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			sendTelegram(uid, "ì¹´í…Œê³ ë¦¬ ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.")
			// showCategoryMenu(uid, chatID, 0)
			return
		}
		if pid == 0 {
			delete(pendingEditProduct, uid)
			cat, ok := selectedCategory[uid]
			if !ok || cat == "" {
				sendTelegram(uid, "âŒ ë¨¼ì € ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”!")
				return
			}
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.\nì˜ˆì‹œ: ìƒˆìƒí’ˆëª…:9.99")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price <= 0 {
				sendTelegram(uid, "âŒ ê°€ê²©ì€ ìˆ«ì(1 ì´ìƒ)ë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
				return
			}
			categoryID, ok := categoryMap[cat]
			if !ok {
				sendTelegram(uid, "âŒ ì˜ëª»ëœ ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤.")
				return
			}
			code := uuid.New().String()
			prod := Product{
				Code:       code,
				Name:       name,
				Price:      price,
				Active:     true,
				CategoryID: categoryID,
			}
			if err := db.Create(&prod).Error; err != nil {
				sendTelegram(uid, fmt.Sprintf("âŒ ìƒí’ˆ ì¶”ê°€ ì‹¤íŒ¨: %v", err))
				return
			}
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("âœ… ìƒˆ ìƒí’ˆ '%s' (%.2f USDT) ì¶”ê°€ ì™„ë£Œ! [ì¹´í…Œê³ ë¦¬: %s]", name, price, cat))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}

		if pid != 0 {
			delete(pendingEditProduct, uid)
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "âŒ ì…ë ¥ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.\n(ì˜ˆì‹œ: ìƒí’ˆëª…:9.99)")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price < 0.01 {
				sendTelegram(uid, "âŒ ê°€ê²©ì€ 0.01 ì´ìƒ ìˆ«ìë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
				return
			}
			var prod Product
			if err := db.First(&prod, pid).Error; err != nil {
				sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
				return
			}
			cat := ""
			for k, v := range categoryMap {
				if v == prod.CategoryID {
					cat = k
					break
				}
			}
			if err := db.Model(&Product{}).Where("id = ?", pid).
				Updates(map[string]interface{}{"name": name, "price": price}).Error; err != nil {
				sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ ìˆ˜ì • ì‹¤íŒ¨! ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.")
			} else {
				sendTelegram(uid, fmt.Sprintf("âœ… ìƒí’ˆì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¦„: %s\nê°€ê²©: %.2f", name, price))
			}
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}
	}

	// ì¬ê³  ì¶”ê°€ ëŒ€ê¸° ìƒíƒœ
	if pidStr, ok := pendingStockInput[uid]; ok {
		productID, _ := strconv.Atoi(pidStr)
		var prod Product
		if err := db.First(&prod, productID).Error; err != nil {
			sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
			return
		}
		if !pendingStockInputNotified[uid] {
			sendTelegram(uid, fmt.Sprintf("ğŸ”¹ [%s] ìƒí’ˆì— ì¬ê³  ì½”ë“œë¥¼ ë¶™ì—¬ë„£ê±°ë‚˜ ì…ë ¥í•˜ì„¸ìš”.\nì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", prod.Name))
			pendingStockInputNotified[uid] = true
		}

		if text == "ì·¨ì†Œ" || text == "ë‚˜ê°€ê¸°" || text == "/cancel" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "âŒ ì¬ê³  ì¶”ê°€ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			return
		}

		lines := strings.Split(text, "\n")
		var added int
		for _, line := range lines {
			code := strings.TrimSpace(line)
			if code == "" || code == "ì™„ë£Œ" {
				continue
			}
			stock := StockCard{
				Name:    prod.Name,
				Content: code,
				Used:    false,
			}
			if err := db.Create(&stock).Error; err == nil {
				added++
			}
		}
		if strings.Contains(text, "ì™„ë£Œ") || text == "ì™„ë£Œ" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("âœ… %dê°œì˜ ì½”ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤! (ìƒí’ˆëª…: %s)", added, prod.Name))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
		} else {
			bot.Send(tgbotapi.NewMessage(uid, fmt.Sprintf("ì„ì‹œì €ì¥: [%dê°œ] ì½”ë“œê°€ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤. ê³„ì† ë¶™ì—¬ë„£ê±°ë‚˜ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", added)))
		}
		return
	}
	if _, ok := activeSupportSessions[uid]; ok || isSupporter(uid) {
		relaySupportMessage(uid, text)
		return
	}
	// ì…ê¸ˆ ê¸ˆì•¡ ì§ì ‘ ì…ë ¥ ì²˜ë¦¬
	if pendingDepositInput[uid] {
		amount, err := strconv.ParseFloat(text, 64)
		if err != nil || amount < 1 {
			sendTelegram(uid, "âŒ 1 USDT ì´ìƒ, ì˜¬ë°”ë¥¸ ìˆ«ìë§Œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
			return
		}
		delete(pendingDepositInput, uid)

		prodName := "USDT ì¶©ì „"
		price := amount

		order := Order{
			UserID:      uid,
			Product:     prodName,
			Amount:      price,
			Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
		}

		if err := db.Create(&order).Error; err != nil {
			sendTelegram(uid, "âŒ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨! ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
			return
		}

		addr := os.Getenv("COIN_PAYMENT_ADDR")
		qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
		_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

		msgText := fmt.Sprintf(
			"ğŸ’¸ <b>ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</b>\n\n"+
				"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•íˆ <code>%.3f USDT</code></b>ë¥¼ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n\n"+
				"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\n"+
				"â€¢ ì…ê¸ˆì£¼ì†Œ: <code>%s</code>\n"+
				"â€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
				"(QRì½”ë“œë¡œ ì†¡ê¸ˆ ê°€ëŠ¥, ì†Œìˆ˜ì ê¹Œì§€ ì •í™•íˆ!)",
			amount, order.ID, addr, amount,
		)
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		bot.Send(msg)

		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photo.Caption = "QRì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê¸ˆì•¡ì´ ìë™ ì§€ì •ë©ë‹ˆë‹¤."
		photo.ParseMode = "HTML"
		bot.Send(photo)
		return
	}

	// ëª…ë ¹ì–´ ì²˜ë¦¬
	if strings.HasPrefix(text, "/") {
		switch text {
		case "/start":
			handleStart(msg)
		case "/menu":
			showMenu(uid, username, chatID)
		case "/ê³µì§€":
			if isAdminUser {
				pendingBroadcastInput[uid] = true
				sendTelegram(uid, "ì „ì²´ ê³µì§€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”. ì·¨ì†Œí•˜ë ¤ë©´ /cancel ì…ë ¥")
			} else {
				sendTelegram(uid, "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")
			}
		case "/balance":
			handleBalanceCommand(msg)
		case "/addstock":
			handleAddStockCommand(msg)
		case "/ë‚´ì§€ê°‘":
			wallet := getUserWallet(uid)
			if wallet == "" {
				sendTelegram(chatID, "âŒ ë“±ë¡ëœ ì§€ê°‘ì´ ì—†ìŠµë‹ˆë‹¤. /ì§€ê°‘ë“±ë¡ ëª…ë ¹ì–´ë¡œ ì§€ê°‘ì„ ë¨¼ì € ë“±ë¡í•´ ì£¼ì„¸ìš”.")
			} else {
				sendTelegram(chatID, fmt.Sprintf("âœ… ë“±ë¡ëœ TRC20 ì§€ê°‘ ì£¼ì†Œ:\n<code>%s</code>", wallet))
			}
		case "/ì§€ê°‘ë“±ë¡":
			if !isAdminUser {
				sendTelegram(chatID, "âŒ ê´€ë¦¬ìë§Œ ì§€ê°‘ ë“±ë¡ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
				return
			}
			pendingWalletInput[uid] = true
			sendTelegram(chatID, "ê´€ë¦¬ì ì§€ê°‘ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš” (TRON ì£¼ì†Œ í˜•ì‹). ì·¨ì†ŒëŠ” /cancel")
		default:
			log.Printf("[handleMessage] ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: %s", text)
		}
		return
	}

	// ì¼ë°˜ í…ìŠ¤íŠ¸ ì²˜ë¦¬
	switch text {
	case "ì—ë„ˆì§€":
		showEnergyMenu(uid, chatID, msg.MessageID)
		return
	case "ë‚´ ì •ë³´":
		showBalanceMenu(uid, chatID, 0)
		return
	case "ê³ ê°ì„¼í„°":
		showSupportMenu(chatID)
		return
	case "ì£¼ë¬¸ë‚´ì—­":
		showOrderHistoryMenu(uid, chatID, msg.MessageID)
		return
	}
	if !isAdminUser {
		log.Printf("[handleMessage] uid=%d, text=%q (ê´€ë¦¬ì ì•„ë‹˜, ë¬´ì‹œ)", uid, text)
		return
	}

	if strings.Contains(text, ":") && len(strings.Split(text, ":")) >= 3 {
		if err := saveStockWithImage(text, ""); err != nil {
			sendTelegram(uid, fmt.Sprintf("âŒ ì¬ê³  ì¶”ê°€ ì‹¤íŒ¨: %v", err))
		} else {
			sendTelegram(uid, "âœ… ì¬ê³ ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!")
		}
		return
	}

	if text == "ë“±ë¡" {
		sendTelegram(uid, "âŒ ë“±ë¡í•  ì¬ê³  ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì¬ê³  ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
		return
	}

	log.Printf("[handleMessage] uid=%d, text=%q (ì²˜ë¦¬í•  ë‚´ìš© ì—†ìŒ)", uid, text)
}

func handleWalletRegistration(uid int64, walletAddress string) error {
	// ì§€ê°‘ ì£¼ì†Œ ìœ íš¨ì„± ê²€ì‚¬
	if !isValidTronAddress(walletAddress) {
		return fmt.Errorf("ìœ íš¨í•˜ì§€ ì•Šì€ ì§€ê°‘ ì£¼ì†Œì…ë‹ˆë‹¤")
	}

	// ì‚¬ìš©ì ì¡°íšŒ
	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return fmt.Errorf("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
		}
		return err
	}

	// ì§€ê°‘ ì£¼ì†Œ ì €ì¥
	user.DepositWallet = walletAddress
	if err := db.Save(&user).Error; err != nil {
		return fmt.Errorf("ì§€ê°‘ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: %w", err)
	}

	return nil
}

func handlePhotoMessage(msg *tgbotapi.Message) {
	panic("unimplemented")
}

func showBalanceMenu(uid, chatID int64, msgID int) {
	var balance UserBalance
	err := db.Where("user_id = ?", uid).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance.Balance = 0
		} else {
			sendTelegram(uid, "âŒ ì”ì•¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
			return
		}
	}

	text := fmt.Sprintf("ğŸ’° <b>ë‚´ ì •ë³´</b>\n\nâ€¢ ì”ì•¡: <b>%.3f USDT</b>", balance.Balance)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë©”ì¸ ë©”ë‰´", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("ì”ì•¡ ë©”ë‰´ í¸ì§‘ ì‹¤íŒ¨: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("ì”ì•¡ ë©”ë‰´ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func showOrderHistoryMenu(uid int64, chatID int64, msgID int) {
	// ìµœê·¼ ì£¼ë¬¸ 10ê°œ ì¡°íšŒ
	var orders []Order
	err := db.
		Where("user_id = ?", uid).
		Order("created_at DESC").
		Limit(10).
		Find(&orders).Error
	if err != nil {
		msg := tgbotapi.NewMessage(chatID, "âŒ ì£¼ë¬¸ ë‚´ì—­ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	if len(orders) == 0 {
		msg := tgbotapi.NewMessage(chatID, "ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("ğŸ§¾ <b>ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ (ìµœëŒ€ 10ê°œ)</b>\n\n")

	for _, order := range orders {
		var txid string
		switch v := any(order.TxID).(type) {
		case sql.NullString:
			if v.Valid {
				txid = v.String
			} else {
				txid = "-"
			}
		case *string:
			if v != nil && *v != "" {
				txid = *v
			} else {
				txid = "-"
			}
		case string:
			if v != "" {
				txid = v
			} else {
				txid = "-"
			}
		default:
			txid = "-"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ <b>ì£¼ë¬¸ë²ˆí˜¸:</b> <code>%d</code>\n"+
				"  <b>ìƒí’ˆëª…:</b> %s\n"+
				"  <b>ê¸ˆì•¡:</b> %.3f USDT\n"+
				"  <b>ìƒíƒœ:</b> %s\n"+
				"  <b>TXID:</b> %s\n"+
				"  <b>ì¼ì‹œ:</b> %s\n\n",
			order.ID,
			html.EscapeString(order.Product),
			order.Amount,
			order.Status,
			txid,
			order.CreatedAt.Format("2006-01-02 15:04"),
		))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

// ì¬ê³  ì¶”ê°€ ë©”ë‰´ ì˜ˆì‹œ
func showAdminAddStockMenu(uid, chatID int64, msgID int) {
	text := "ğŸ›  ì¬ê³  ì¶”ê°€ ë©”ë‰´ì…ë‹ˆë‹¤.\nì•„ë˜ ìƒí’ˆ IDë¥¼ ì„ íƒí•˜ê±°ë‚˜, 'ì·¨ì†Œ'ë¥¼ ì…ë ¥í•˜ì—¬ ë©”ë‰´ë¥¼ ì¢…ë£Œí•˜ì„¸ìš”."

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range productCategories {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(cat, "admin_cat_"+cat),
		))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("âŒ ì·¨ì†Œ", "go_admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	bot.Send(msg)
}

// íŠ¹ì • ì¹´í…Œê³ ë¦¬ë³„ ì¬ê³  ë³´ê¸°
func showAdminCategoryStock(uid, chatID int64, msgID int, category string) {
	var stockList []Stock

	err := db.Where("category = ?", category).Find(&stockList).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ì¬ê³  ì¡°íšŒ ì‹¤íŒ¨: "+err.Error())
		return
	}

	if len(stockList) == 0 {
		sendTelegram(chatID, "ğŸ“‚ '"+category+"' ì¹´í…Œê³ ë¦¬ì— ì¬ê³ ê°€ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	text := fmt.Sprintf("ğŸ“‚ <b>%s</b> ì¹´í…Œê³ ë¦¬ ì¬ê³  ëª©ë¡:\n\n", category)
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, stock := range stockList {
		text += fmt.Sprintf("- %s (ID: %d)\n", stock.Code, stock.ID)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœï¸ ìˆ˜ì •", fmt.Sprintf("admin_edit_stock_%d", stock.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ ì‚­ì œ", fmt.Sprintf("admin_del_stock_%d", stock.ID)),
		))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë’¤ë¡œ", "admin_inventory"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	bot.Send(msg)
}

// ì¬ê³  ì •ë¦¬ ì˜ˆì‹œ
func cleanupStock(uid, chatID int64, msgID int) {
	// ì˜ˆ: DBì—ì„œ ì˜¤ë˜ëœ ì¬ê³  ìë™ ì‚­ì œ, ì¤‘ë³µ ì œê±° ë“± ë¡œì§ êµ¬í˜„
	err := db.Exec("DELETE FROM stocks WHERE created_at < ?", time.Now().AddDate(0, -6, 0)).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ì¬ê³  ì •ë¦¬ ì‹¤íŒ¨: "+err.Error())
		return
	}

	sendTelegram(chatID, "ğŸ§¹ 6ê°œì›” ì´ìƒëœ ì¬ê³ ë¥¼ ì •ë¦¬ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.")
	showAdminAddStockMenu(uid, chatID, msgID)
}

func showAdminStockDetail(chatID int64, msgID int, productID int) {
	// DBì—ì„œ productIDì— í•´ë‹¹í•˜ëŠ” ìƒí’ˆ ì¬ê³  ìƒì„¸ ì¡°íšŒ í›„ ë©”ì‹œì§€ í¸ì§‘ ë˜ëŠ” ìƒˆ ë©”ì‹œì§€ ì „ì†¡
	// ì˜ˆì‹œ: ì¬ê³  ëª©ë¡, ì‚¬ìš© ì—¬ë¶€, ì½”ë“œ ë“± í‘œì‹œ
	var stocks []Stock
	err := db.Where("product_id = ?", productID).Find(&stocks).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ìƒí’ˆ ì¬ê³  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}
	text := fmt.Sprintf("ğŸ“¦ ìƒí’ˆ ID %d ì¬ê³  ìƒì„¸\n\n", productID)
	for i, stock := range stocks {
		text += fmt.Sprintf("%d. ì½”ë“œ: <code>%s</code>, ì‚¬ìš© ì—¬ë¶€: %v\n", i+1, stock.Code, stock.Used)
		if i >= 20 {
			text += "...\n(ë” ë§ì€ ì¬ê³ ê°€ ìˆìŠµë‹ˆë‹¤)\n"
			break
		}
	}
	msg := tgbotapi.NewEditMessageText(chatID, msgID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showAdminStockDetail] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì¬ê³  ìˆ˜ì • UI ë³´ì—¬ì£¼ê¸°
func showAdminEditStock(chatID int64, msgID int, stockID int) {
	// ì¬ê³  ìˆ˜ì • UI ì˜ˆì‹œ: ì¬ê³  ìƒíƒœ ë³€ê²½, ì½”ë“œ ìˆ˜ì • ë“±
	// ì‹¤ì œ êµ¬í˜„ ì‹œ ë©”ì‹œì§€ í¸ì§‘ ë“± UI ì²˜ë¦¬ í•„ìš”
	msgText := fmt.Sprintf("âœï¸ ì¬ê³  ID %d ìˆ˜ì • í™”ë©´ (êµ¬í˜„ í•„ìš”)", stockID)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("[showAdminEditStock] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì¬ê³  ì‚­ì œ í™•ì¸ ë° ì‚­ì œ ì²˜ë¦¬ UI ë³´ì—¬ì£¼ê¸°
func promptConfirmDeleteStock(uid, chatID int64, msgID int, stockID int) {
	// ì‚­ì œ í™•ì¸ ë²„íŠ¼ í‘œì‹œ
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœ… ì‚­ì œ", fmt.Sprintf("confirm_del_stock_%d", stockID)),
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì·¨ì†Œ", "cancel"),
		),
	)
	text := fmt.Sprintf("â—ï¸ ì¬ê³  ID %d ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?", stockID)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("[promptConfirmDeleteStock] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func showAdminEditProduct(chatID int64, msgID int, productID int) {
	var prod Product
	err := db.First(&prod, productID).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	text := fmt.Sprintf(
		"<b>ìƒí’ˆ ìˆ˜ì •</b>\n\n"+
			"ìƒí’ˆëª…: %s\nê°€ê²©: %.2f USDT\n\n"+
			"ìƒˆ ì´ë¦„ê³¼ ê°€ê²©ì„ 'ì´ë¦„:ê°€ê²©' í˜•íƒœë¡œ ì…ë ¥í•˜ì„¸ìš”.\n"+
			"ì˜ˆì‹œ) ìƒˆë¡œìš´ìƒí’ˆëª…:9.99",
		prod.Name, prod.Price,
	)

	cancelKb := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ì·¨ì†Œ"),
			tgbotapi.NewKeyboardButton("ë‚˜ê°€ê¸°"),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = cancelKb
	bot.Send(msg)
}

func showAdminAddStock(uid, chatID int64, msgID int, productID int) {
	var prod Product
	err := db.First(&prod, productID).Error
	if err != nil {
		sendTelegram(chatID, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	text := fmt.Sprintf(
		"<b>ì¬ê³  ì¶”ê°€ - %s</b>\n\n"+
			"í•œ ì¤„ì— í•˜ë‚˜ì”© ì¬ê³  ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n"+
			"ì…ë ¥ ì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.\n\n"+
			"ì˜ˆì‹œ:\n<code>ABC123\nDEF456\nGHI789</code>",
		prod.Name,
	)

	cancelKb := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ì·¨ì†Œ"),
			tgbotapi.NewKeyboardButton("ë‚˜ê°€ê¸°"),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = cancelKb

	bot.Send(msg)

	// ì‚¬ìš©ìë³„ ëŒ€ê¸° ìƒíƒœ ì €ì¥
	pendingStockInput[uid] = strconv.Itoa(productID)
}

func isValidTronAddress(addr string) bool {
	return strings.HasPrefix(addr, "T") && len(addr) == 34
}

func showAddStockProductMenu(uid, chatID int64, msgID int, category string) {
	var products []Product
	db.Where("active = true").Joins("JOIN card_categories ON products.category_id = card_categories.id").
		Where("card_categories.name = ?", category).
		Find(&products)

	if len(products) == 0 {
		sendTelegram(chatID, "âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ë“±ë¡ëœ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, prod := range products {
		cb := fmt.Sprintf("admin_stock_prod_%s_%d", category, prod.ID)
		btn := tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s (%.2f)", prod.Name, prod.Price), cb)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¹´í…Œê³ ë¦¬ ì„ íƒ", "admin_add_stock"),
	))
	msg := tgbotapi.NewEditMessageText(chatID, msgID, "ğŸ“¦ ìƒí’ˆì„ ì„ íƒí•˜ì„¸ìš”.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func showAddStockCategoryMenu(uid, chatID int64, msgID int) {
	// DBì—ì„œ í™œì„±í™”ëœ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ
	var categories []CardCategory
	if err := db.Where("is_active = ?", true).Find(&categories).Error; err != nil {
		sendTelegram(chatID, "âŒ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range categories {
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("ğŸ“‚ %s", cat.DisplayName),
			fmt.Sprintf("add_product_%s", cat.Name),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, msgID, "ğŸ“‚ ì¬ê³  ì¶”ê°€ - ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func promptAddStock(uid, chatID int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	pendingStockInput[uid] = strconv.Itoa(productID)

	text := fmt.Sprintf(
		"<b>[%s]</b> ìƒí’ˆì— ì¶”ê°€í•  ì¬ê³  ì½”ë“œë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥í•˜ì„¸ìš”.\nì…ë ¥ ì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.\n\n"+
			"ì˜ˆì‹œ:\n<code>1234-5678-ABCD\nQWER-8888-ZXCV\nA1B2C3D4E5F6</code>\n\n(ëë‚˜ë©´ 'ì™„ë£Œ' ì…ë ¥)",
		prod.Name,
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	if _, err := bot.Send(msg); err != nil {
		log.Printf("[promptAddStock] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func isAdmin(uid int64) bool {
	adminIDs := strings.Split(os.Getenv("TELEGRAM_ADMIN_ID"), ",")
	for _, idStr := range adminIDs {
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err == nil && id == uid {
			return true
		}
	}
	return false
}

func completeStockInput(uid, chatID int64) {
	// ì…ë ¥ ëŒ€ê¸° ìƒíƒœ ì¢…ë£Œ
	delete(pendingStockInput, uid)

	// ë©”ì‹œì§€ ì‚­ì œ
	if msgID, ok := pendingStockInputMessageID[uid]; ok {
		err := deleteMessage(chatID, msgID)
		if err == nil {
			delete(pendingStockInputMessageID, uid)
		}
	}

	sendTelegram(uid, "âœ… ì¬ê³  ì…ë ¥ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
}

func deleteMessage(chatID int64, messageID int) error {
	delMsg := tgbotapi.NewDeleteMessage(chatID, messageID)
	_, err := bot.Request(delMsg)
	if err != nil {
		log.Printf("[deleteMessage] ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
	}
	return err
}

func showProductListMenuByCategory(chatID int64, messageID int, category string) {
	var products []Product
	err := db.Where("category_id = ?", categoryMap[category]).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_stock_detail_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_inventory"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("ğŸ“‹ [%s] ìƒí’ˆ ëª©ë¡", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showAdminProductList(chatID int64, messageID int) {
	var products []Product
	if err := db.Find(&products).Error; err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ìƒí’ˆ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Send(msg)
		return
	}
	if len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "â—ï¸ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	rows := buildProductButtons(products)

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ“¦ ìƒí’ˆ ëª©ë¡ (ê´€ë¦¬ì)")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showUserGradeChangeMenu(chatID int64, msgID int, userID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‰", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥ˆ", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‡", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_user_list"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, "ë³€ê²½í•  ë“±ê¸‰ì„ ì„ íƒí•˜ì„¸ìš”.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"
	bot.Send(edit)
}

func promptAddStockInput(uid int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	msgText := fmt.Sprintf("â• ì¬ê³  ì¶”ê°€ - ìƒí’ˆ: <b>%s</b>\n\nì¬ê³  ì½”ë“œë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥í•´ ì£¼ì„¸ìš”.\nì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ê±°ë‚˜ /cancel ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.", prod.Name)
	sendTelegram(uid, msgText) // ìˆ˜ì •ëœ ë¶€ë¶„

	pendingStockInput[uid] = strconv.Itoa(productID)
}

func showCleanupStockMenu(chatID int64, msgID int) {
	msgText := "ğŸ§¹ ì¬ê³  ì •ë¦¬ ê¸°ëŠ¥ì…ë‹ˆë‹¤.\ní•„ìš”í•œ ì‘ì—…ì„ ì„ íƒí•˜ì„¸ìš”."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì‚¬ìš©ëœ ì¬ê³  ì •ë¦¬", "cleanup_used_stock"),
			tgbotapi.NewInlineKeyboardButtonData("ì˜¤ë˜ëœ ì¬ê³  ì •ë¦¬", "cleanup_old_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_stock"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	bot.Send(edit)
}

func handleCallback(cb *tgbotapi.CallbackQuery) {
	if cb == nil {
		return
	}
	uid := int64(cb.From.ID)

	var chatID int64
	var msgID int
	if cb.Message != nil {
		chatID = cb.Message.Chat.ID
		msgID = cb.Message.MessageID
	} else {
		// cb.Messageê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ 0ìœ¼ë¡œ ë‘ê³  ë¡œê·¸ ì¶œë ¥
		log.Printf("[handleCallback] cb.Messageê°€ nilì…ë‹ˆë‹¤. cb.Data=%s", cb.Data)
		chatID = 0
		msgID = 0
	}

	data := cb.Data

	// ê´€ë¦¬ì ê¶Œí•œ í•„ìš” ì½œë°± ì²˜ë¦¬
	if isAdminRequired(data) && !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	switch {
	case data == "admin_menu":
		showAdminMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ë©”ë‰´ í‘œì‹œ"))
		return

	case data == "admin_list_visitors_today":
		visitors, err := getVisitorsByDate(time.Now())
		if err != nil {
			sendTelegram(uid, "ë°©ë¬¸ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
			return
		}
		users := make([]User, len(visitors))
		for i, v := range visitors {
			userName := ""
			if v.UserName.Valid {
				userName = v.UserName.String
			}
			users[i] = User{
				UserID:   v.UserID,
				UserName: userName,
				Nickname: v.Nickname,
				LastSeen: v.LastSeen,
			}
		}
		msgText := formatUserListMessage(users, 1, 1)
		edit := tgbotapi.NewEditMessageText(chatID, msgID, msgText)
		edit.ParseMode = "HTML"
		bot.Send(edit)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë‹¹ì¼ ë°©ë¬¸ì ëª©ë¡ í‘œì‹œ"))
		return

	case strings.HasPrefix(data, "admin_all_users_page_"):
		pageStr := strings.TrimPrefix(data, "admin_all_users_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showAdminAllUsersMenu(chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("ì „ì²´ ìœ ì € ëª©ë¡ í˜ì´ì§€ %d", page)))
		return

	case data == "admin_all_users":
		showAdminAllUsersMenu(chatID, msgID, 1)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì „ì²´ ìœ ì € ëª©ë¡ í‘œì‹œ"))
		return

	case strings.HasPrefix(data, "admin_stock_"):
		handleAdminStockMenuCallbacks(cb)
		return

	case data == "admin_orders":
		showAdminOrdersMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì£¼ë¬¸ ë‚´ì—­ í‘œì‹œ"))
		return

	case data == "tron_wallet_register":
		sendTelegram(uid, "TRON ì§€ê°‘ ì£¼ì†Œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”. ì˜ˆ: TXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
		pendingWalletInput[uid] = true
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì§€ê°‘ ì£¼ì†Œ ì…ë ¥ ëŒ€ê¸° ì¤‘"))
		return

	case data == "admin_member_menu":
		showAdminMemberMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì íšŒì› ëª©ë¡ í‘œì‹œ"))
		return

	case data == "admin_add_stock_category":
		showAddStockCategoryMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì¶”ê°€ ì¹´í…Œê³ ë¦¬ ë©”ë‰´ í‘œì‹œ"))
		return

	case data == "admin_inventory":
		showAdminInventoryMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ë©”ë‰´ í‘œì‹œ"))
		return

	case data == "admin_visitor_menu":
		showAdminVisitorMenu(chatID, msgID, cb.ID)
		return

	case data == "weekly_stats":
		showAdminStatsMenu(uid, chatID, msgID, "daily")
		bot.Request(tgbotapi.NewCallback(cb.ID, "í†µê³„ í‘œì‹œ"))
		return

	case data == "handle_show_orders":
		showOrderHistoryMenu(uid, chatID, msgID)
		return

	case data == "admin_list_visitors":
		handleAdminListVisitors(uid)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë°©ë¬¸ì ëª©ë¡ í‘œì‹œ"))
		return

	case data == "menu_help":
		kb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" ğŸª« ENERGY ", "help_energy"),
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ†” ACCOUNT ", "help_account"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ‘¥ MEMBERS ", "help_membership"),
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ“± ESIM ", "help_esim"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ–¥ï¸ VPS ", "help_vps"),
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ’³ CARD ", "help_card"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ”„ SWAP ", "help_swap"),
				tgbotapi.NewInlineKeyboardButtonData(" ğŸ”™ ", "go_main"),
			),
		)
		msg := tgbotapi.NewEditMessageText(chatID, msgID, "â„¹ï¸ ì‚¬ìš©ë°©ë²• ì•ˆë‚´\në„ì›€ì´ í•„ìš”í•œ í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”.")
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = &kb
		bot.Send(msg)
		return

	case data == "go_main":
		// ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
			}
		}
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
		return

	case data == "show_balance":
		showBalanceMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë‚´ ì •ë³´ ë©”ë‰´ í‘œì‹œ"))
		return

	case data == "go_catmenu":
		if msgID != 0 {
			delMsg := tgbotapi.NewDeleteMessage(chatID, msgID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("ì´ì „ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
			}
		}
		showCategoryMenu(uid, chatID, 0)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¹´í…Œê³ ë¦¬ ë©”ë‰´ë¡œ ì´ë™"))
		return

	case data == "menu_vps":
		showVPSMenu(uid, chatID, msgID)
		return

	case data == "admin_stock":
		showAdminStockMenuSimple(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ë©”ë‰´ë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤"))
		return

	case data == "cancel_pending_add":
		delete(pendingEditProduct, uid)
		delete(pendingStockInput, uid)
		sendTelegram(uid, "âŒ ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
		showCategoryMenu(uid, chatID, 0)
		return

	case data == "admin_add_stock":
		showAdminAddStockMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì¶”ê°€ ë©”ë‰´ ì—´ê¸°"))
		return

	case strings.HasPrefix(data, "admin_cat_"):
		category := strings.TrimPrefix(data, "admin_cat_")
		showAdminCategoryStock(uid, chatID, msgID, category)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¹´í…Œê³ ë¦¬ ì¬ê³  ë³´ê¸°"))
		return

	case data == "admin_cleanup_stock":
		cleanupStock(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ì •ë¦¬ ì‹œì‘"))
		return

	case data == "check_wallet":
		wallet := getUserWallet(uid)
		if wallet == "" {
			sendTelegram(uid, "âŒ ë“±ë¡ëœ ì§€ê°‘ì´ ì—†ìŠµë‹ˆë‹¤.")
			return
		}
		sendTelegram(uid, fmt.Sprintf("ì§€ê°‘ ì£¼ì†Œ: <code>%s</code>", wallet))
		return

	case data == "admin_today_visitors":
		showTodayVisitorsMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì˜¤ëŠ˜ ë°©ë¬¸ì í‘œì‹œ"))
		return

	case data == "admin_stock_menu":
		showAdminStockMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ê´€ë¦¬"))
		return

	case data == "admin_all_visitors":
		showAllVisitorsMenu(chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì „ì²´ ë°©ë¬¸ì í‘œì‹œ"))
		return

	case data == "admin_all_users":
		showAdminAllUsersMenu(chatID, msgID, 1)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì „ì²´ ìœ ì € í‘œì‹œ"))
		return

	case data == "admin_advanced":
		showAdvancedAdminMenu(uid, chatID, int64(msgID))
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê³ ê¸‰ ê´€ë¦¬ì ë©”ë‰´"))
		return

	case data == "admin_system_health":
		showSystemHealthMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ"))
		return

	case data == "deposit_custom":
		pendingDepositInput[uid] = true
		sendTelegram(uid, "ì›í•˜ëŠ” USDT ê¸ˆì•¡ì„ ìˆ«ìë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš” (ì˜ˆ: 23.5)")
		bot.Send(tgbotapi.NewCallback(cb.ID, "ì§ì ‘ì…ë ¥ ëŒ€ê¸°ì¤‘"))
		return

	case strings.HasPrefix(data, "visitor_page_"):
		pageStr := strings.TrimPrefix(data, "visitor_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil || page < 1 {
			page = 1
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, "í˜ì´ì§€ ì´ë™"))
		return

	case strings.HasPrefix(data, "deposit_amount_"):
		amountStr := strings.TrimPrefix(data, "deposit_amount_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(chatID, "âŒ ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨")
			return
		}
		pendingDepositInput[uid] = false
		err = createDepositOrder(uid, amount)
		if err != nil {
			sendTelegram(chatID, "âŒ ì¶©ì „ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨")
			return
		}
		sendTelegram(chatID, fmt.Sprintf("âœ… %.2f USDT ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", amount))
		return

	case strings.HasPrefix(data, "deposit_"):
		amountStr := strings.TrimPrefix(data, "deposit_")
		amount, err := strconv.ParseFloat(amountStr, 64)
		if err != nil {
			sendTelegram(chatID, "âŒ ì˜ëª»ëœ ì…ê¸ˆ ê¸ˆì•¡ì…ë‹ˆë‹¤.")
			return
		}
		showDepositAddress(uid, chatID, msgID, amount)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì…ê¸ˆ ì•ˆë‚´ í‘œì‹œ"))
		return

	case strings.HasPrefix(data, "admin_set_grade_"):
		parts := strings.Split(data, "_")
		if len(parts) < 5 {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ë“±ê¸‰ ë³€ê²½ ì½œë°±")
			return
		}
		userID, err := strconv.ParseInt(parts[3], 10, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ì˜ëª»ëœ ìœ ì € ID")
			return
		}
		grade := parts[4]

		if err := updateUserGrade(userID, grade); err != nil {
			sendTelegram(uid, "âŒ ë“±ê¸‰ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
			return
		}

		sendTelegram(userID, fmt.Sprintf("ë“±ê¸‰ì´ '%s'ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.", grade))
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë“±ê¸‰ ë³€ê²½ ì™„ë£Œ"))
		return

	case strings.HasPrefix(data, "verify_"):
		handleVerificationResponse(cb)
		return

	case data == "menu_products":
		log.Printf("[handleCallback] menu_products ì½œë°± ì²˜ë¦¬ ì‹œì‘")
		showCategoryMenu(uid, chatID, msgID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ëª©ë¡ í‘œì‹œ"))
		log.Printf("[handleCallback] menu_products ì½œë°± ì²˜ë¦¬ ì™„ë£Œ")
		return

	case data == "admin_user_list":
		showAdminUserListMenu(chatID, msgID)
		return

	case strings.HasPrefix(data, "support_accept_"):
		targetUIDStr := strings.TrimPrefix(data, "support_accept_")
		targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ìƒë‹´ ëŒ€ìƒì ID íŒŒì‹± ì‹¤íŒ¨")
			return
		}

		// ìƒë‹´ì›ê³¼ ìœ ì € ì—°ê²° ì„¸ì…˜ ì €ì¥
		activeSupportSessions[targetUID] = uid

		// ìƒë‹´ ì¢…ë£Œ ë²„íŠ¼ í‚¤ë³´ë“œ (ìœ ì €ìš©)
		userCloseKb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”š ìƒë‹´ì¢…ë£Œ", fmt.Sprintf("support_close_%d", uid)),
			),
		)
		// ìƒë‹´ ì¢…ë£Œ ë²„íŠ¼ í‚¤ë³´ë“œ (ìƒë‹´ì›ìš©)
		adminCloseKb := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”š ìƒë‹´ì¢…ë£Œ", fmt.Sprintf("support_close_%d", targetUID)),
			),
		)

		// ìœ ì €ì—ê²Œ ìƒë‹´ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡
		userMsg := tgbotapi.NewMessage(targetUID,
			"âœ… ìƒë‹´ì›ì´ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤! ê¶ê¸ˆí•œ ë‚´ìš©ì„ ë©”ì‹œì§€ë¡œ ë³´ë‚´ì£¼ì„¸ìš”.\n\nìƒë‹´ì´ ëë‚˜ë©´ í•˜ë‹¨ì˜ [ìƒë‹´ì¢…ë£Œ] ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
		userMsg.ReplyMarkup = userCloseKb
		bot.Send(userMsg)
		// ìƒë‹´ì›ì—ê²Œ ìƒë‹´ ì‹œì‘ ë©”ì‹œì§€ ì „ì†¡
		adminMsg := tgbotapi.NewMessage(uid,
			"ğŸ™‹â€â™‚ï¸ ìƒë‹´ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ ì €ì—ê²Œ ë‹µë³€í•´ ì£¼ì„¸ìš”.\n\nìƒë‹´ì´ ëë‚˜ë©´ [ìƒë‹´ì¢…ë£Œ]ë¥¼ ê¼­ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
		adminMsg.ReplyMarkup = adminCloseKb
		bot.Send(adminMsg)

		// ì½œë°± ì‘ë‹µ
		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒë‹´ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."))
		return

	case strings.HasPrefix(data, "del_stock_"):
		handleDeleteStockCategory(cb)
		return

	case strings.HasPrefix(data, "confirm_del_"):
		handleConfirmDeleteStock(cb)
		return

	case strings.HasPrefix(data, "confirm_deposit_"), strings.HasPrefix(data, "deposit_"):
		handleDepositCallbacks(cb)
		return

	case strings.HasPrefix(data, "userlist_page_"):
		pageStr := strings.TrimPrefix(data, "userlist_page_")
		page, err := strconv.Atoi(pageStr)
		if err != nil {
			return
		}
		showUserListPage(uid, chatID, msgID, page)
		bot.Request(tgbotapi.NewCallback(cb.ID, "í˜ì´ì§€ ì´ë™"))
		return

	case strings.HasPrefix(data, "lang_"):
		handleLanguageSelection(cb)
		return

	case strings.HasPrefix(data, "prod_"):
		productCode := strings.TrimPrefix(data, "prod_")
		parts := strings.SplitN(data, "_", 3)
		category := ""
		if len(parts) >= 3 {
			category = parts[1]
			productCode = parts[2]
		}
		handleProductSelection(uid, chatID, msgID, productCode, category)
		return

	case strings.HasPrefix(data, "help_"):
		showHelpMessage(uid, data)
		return

	case strings.HasPrefix(data, "cardcat_"):
		category := strings.TrimPrefix(data, "cardcat_")
		log.Printf("cardcat ì½œë°± category: %s", category)
		category = strings.ToUpper(category) // ë˜ëŠ” í•„ìš”ì‹œ ì†Œë¬¸ìí™”

		productsSlice, err := getProductsByCategory(db, category)
		if err != nil || len(productsSlice) == 0 {
			log.Printf("ì¹´í…Œê³ ë¦¬ %s ìƒí’ˆ ì—†ìŒ ë˜ëŠ” ì¡°íšŒ ì˜¤ë¥˜: %v", category, err)
			sendTelegram(chatID, "âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
			return
		}

		productsMap := make(map[string]Product)
		for _, p := range productsSlice {
			productsMap[p.Name] = p
		}

		showProductMenu(category, chatID, msgID, productsMap)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ëª©ë¡ í‘œì‹œ"))
		return

	case strings.HasPrefix(data, "pay_balance_"):
		orderIDStr := strings.TrimPrefix(data, "pay_balance_")
		orderID64, err := strconv.ParseUint(orderIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ì£¼ë¬¸ë²ˆí˜¸ íŒŒì‹± ì‹¤íŒ¨")
			return
		}
		orderID := uint(orderID64)
		err = handleBalancePayment(orderID, uid)
		if err != nil {
			sendTelegram(uid, "âŒ ì”ì•¡ ê²°ì œ ì‹¤íŒ¨: "+err.Error())
		} else {
			sendTelegram(uid, "âœ… ì”ì•¡ ê²°ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
		}
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì”ì•¡ ê²°ì œ ì²˜ë¦¬ ì¤‘"))
		return

	case strings.HasPrefix(data, "support_close_"):
		targetUIDStr := strings.TrimPrefix(data, "support_close_")
		targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
		if err != nil {
			sendTelegram(uid, "âŒ ìƒë‹´ ëŒ€ìƒì ID íŒŒì‹± ì‹¤íŒ¨")
			return
		}

		// ìƒë‹´ ì„¸ì…˜ ì‚­ì œ: ìœ ì €ì™€ ìƒë‹´ì› ëª¨ë‘ ì œê±°
		delete(activeSupportSessions, targetUID)
		for userID, adminID := range activeSupportSessions {
			if adminID == targetUID {
				delete(activeSupportSessions, userID)
			}
		}

		// ì¢…ë£Œ ë©”ì‹œì§€ ì „ì†¡ (ìœ ì € ë° ìƒë‹´ì›)
		sendTelegram(targetUID, "ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì–¸ì œë“  ë‹¤ì‹œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
		sendTelegram(uid, "ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

		// ê´€ë¦¬ì(ì „ì²´)ì—ê²Œë„ ì•Œë¦¼ ë³´ë‚´ê¸° (í•„ìš” ì‹œ)
		for _, adminID := range adminIDs {
			sendTelegram(int64(adminID), fmt.Sprintf("ìœ ì € %dì˜ ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", targetUID))
		}

		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."))
		return

	default:
		log.Printf("[handleCallback] ì•Œ ìˆ˜ ì—†ëŠ” ì½œë°± ë°ì´í„°: %s", data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "â“ ì•Œ ìˆ˜ ì—†ëŠ” ë™ì‘ì…ë‹ˆë‹¤."))
	}
}

func isAdminRequired(data string) bool {
	adminCallbacks := []string{
		"admin_menu",
		"admin_list_visitors",
		"admin_list_stock",
		"admin_add_admin",
		"admin_cancel_order",
		"admin_cat_",
		"admin_product_",
		"admin_edit_product_",
		"admin_add_stock_",
		"admin_user_detail_",
		"admin_today_visitors",
		"admin_stock_menu",
		"admin_all_visitors",
		"admin_all_users",
		"admin_advanced",
		"admin_system_health",
		"admin_set_grade_",
		"admin_user_list",
	}

	for _, prefix := range adminCallbacks {
		if strings.HasPrefix(data, prefix) {
			return true
		}
	}
	return false
}

func handleAddStockCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
		return
	}

	// ê´€ë¦¬ìì—ê²Œ ì¹´í…Œê³ ë¦¬ ì„ íƒ ë©”ë‰´ ë„ìš°ê¸° ë“± ì¬ê³  ì¶”ê°€ ì•ˆë‚´ ë©”ì‹œì§€
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("MEMBERSHIP", "admin_add_stock_category_membership"),
			tgbotapi.NewInlineKeyboardButtonData("ESIM", "admin_add_stock_category_esim"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("CARD", "admin_add_stock_category_card"),
			tgbotapi.NewInlineKeyboardButtonData("ACCOUNT", "admin_add_stock_category_account"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì·¨ì†Œ", "cancel_pending_add"),
		),
	)

	msgText := "âœ… ì¬ê³ ë¥¼ ì¶”ê°€í•  ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”."
	message := tgbotapi.NewMessage(uid, msgText)
	message.ReplyMarkup = kb
	bot.Send(message)
}

// ì´ í˜ì´ì§€ ìˆ˜ ê³„ì‚° í•¨ìˆ˜ (10ëª… ë‹¨ìœ„)
func getTotalVisitorPages() int {
	var total int64
	err := db.Model(&User{}).Count(&total).Error
	if err != nil || total == 0 {
		return 1
	}
	return int((total + 9) / 10) // ì˜¬ë¦¼
}

// ë°©ë¬¸ì ëª©ë¡ ì¡°íšŒ í•¨ìˆ˜ (í˜ì´ì§• í¬í•¨)
func getVisitors(page, pageSize int) ([]User, int64, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	err := db.Order("last_seen DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&users).Error
	return users, total, err
}

func initCardCategoriesMap() error {
	var categories []CardCategory
	if err := db.Where("is_active = ?", true).Find(&categories).Error; err != nil {
		return err
	}

	for _, cat := range categories {
		var products []Product
		if err := db.Where("category_id = ? AND active = ?", cat.ID, true).Find(&products).Error; err != nil {
			log.Printf("âŒ [%s] ìƒí’ˆ ë¡œë”© ì‹¤íŒ¨: %v", cat.Name, err)
			continue
		}
		tmp := map[string]Product{}
		for _, p := range products {
			tmp[p.Name] = p
		}
		cardCategories[cat.Name] = tmp
	}
	return nil
}

func formatVisitorListNoNickname(visitors []Visitor) string {
	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, v := range visitors {
		username := "ì—†ìŒ"
		if v.UserName.Valid && v.UserName.String != "" {
			username = "@" + v.UserName.String
		}
		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <i>%s</i>\n\n",
			i+1, v.UserID, username,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	sb.WriteString("ğŸ” ëˆ„êµ°ì§€ ë°”ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ ì•„ì´ë”” í‘œì‹œ\n")

	return sb.String()
}

func createOrderAndPromptPayment(uid int64, chatID int64, productCode string) error {
	// 1. ìƒí’ˆëª…ê³¼ ê°€ê²© ì¡°íšŒ
	var prodName string
	var basePrice float64
	found := false
	for _, cats := range cardCategories {
		for name, prod := range cats {
			if prod.Code == productCode {
				prodName = name
				basePrice = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}
	if !found {
		sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return fmt.Errorf("ìƒí’ˆ ì—†ìŒ")
	}

	// 2. ì£¼ë¬¸ ìƒì„± (ì´ˆê¸° ìƒíƒœ: ì…ê¸ˆëŒ€ê¸°ì¤‘)
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      basePrice,
		ExpectedAmt: basePrice,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: %v", err)
		return err
	}

	// 3. ì£¼ë¬¸ ID ê¸°ë°˜ ê³ ìœ  ê²°ì œê¸ˆì•¡ ê³„ì‚° (ì†Œìˆ˜ì  3ìë¦¬)
	uniqueAmt := toFixed3(basePrice + float64(order.ID)/1000.0)
	order.Amount = uniqueAmt
	order.ExpectedAmt = uniqueAmt
	if err := db.Save(&order).Error; err != nil {
		log.Printf("ì£¼ë¬¸ ê¸ˆì•¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
		return err
	}

	// 4. ê²°ì œ ì•ˆë‚´ ë° QR ì½”ë“œ ìƒì„± ë“±ì„ handleCoinPaymentUnifiedë¡œ ì²˜ë¦¬
	handleCoinPaymentUnified(nil, uid, chatID, uint64(order.ID))

	return nil
}

func showCategoryMenu(uid, chatID int64, messageID int) {
	if messageID > 0 {
		delMsg := tgbotapi.NewDeleteMessage(chatID, messageID)
		if _, err := bot.Send(delMsg); err != nil {
			log.Printf("[showCategoryMenu] ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
		}
	}

	categories, err := getCardCategoriesFromDB()
	if err != nil || len(categories) == 0 {
		sendTelegram(chatID, "âŒ ì¹´í…Œê³ ë¦¬ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨")
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	for _, cat := range categories {
		display := cat.DisplayName
		if display == "" {
			display = cat.Name
		}
		btn := tgbotapi.NewInlineKeyboardButtonData("ğŸ“‚ "+display, "cardcat_"+cat.Name)
		currentRow = append(currentRow, btn)
		count++
		if count%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
	))

	msg := tgbotapi.NewMessage(chatID, "ğŸ“¦ <b>ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</b>\n(ì›í•˜ì‹œëŠ” ìƒí’ˆ ë¶„ë¥˜ë¥¼ ê³¨ë¼ì£¼ì„¸ìš”)")
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showCategoryMenu] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func checkDepositMatch(senderAddress string, amount float64) (*Order, error) {
	var order Order
	err := db.Where("sender_address = ? AND status = ?", senderAddress, "pending").First(&order).Error
	if err != nil {
		return nil, err
	}
	return &order, nil
}

func formatVisitorList(users []User) string {
	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}

		nickname := u.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n\n",
			i+1, u.UserID, nickname, username,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	sb.WriteString("ğŸ” ëˆ„êµ°ì§€ ë°”ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ ë‹‰ë„¤ì„ê³¼ ì•„ì´ë”” í‘œì‹œ\n")

	return sb.String()
}

// showHelpMessage í•¨ìˆ˜ (ìˆ˜ì •ë³¸)
func showHelpMessage(uid int64, data string) {
	switch data {
	case "help_account":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ†” <b>(ACCOUNT) ìƒí’ˆ ì•ˆë‚´</b>\n\n"+
				"ê²°ì œ í™•ì¸ í›„, <b>ìë™</b> ë©”ì„¸ì§€ë¡œ ì§€ê¸‰ë©ë‹ˆë‹¤.\n"+
				"<b>ë²ˆí˜¸ | link</b> í˜•ì‹ìœ¼ë¡œ ë°œì†¡ë˜ë©° ë¡œê·¸ì¸ ğŸ”œ link ğŸ”œ 2FA í™•ì¸\n"+
				"ãƒ»<i>EX: <a href=\"https://t.me/EX_TGID\">ì§§ì€ë²ˆí˜¸</a> í¬ì»¤ë¬¸ì˜</i>\n"+
				"<i>PC ë° ëª¨ë°”ì¼ ëª¨ë‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_account ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_membership":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ‘¥ <b>(MEMBERSHIP) ì•ˆë‚´</b>\n\n"+
				"ãƒ» ê²°ì œ í›„ ë³„ë„ ë“±ë¡ ì—†ì´ <b>ì¦‰ì‹œ ì„ ë¬¼</b>ë¡œ ì „ì†¡ë©ë‹ˆë‹¤.\n"+
				"ãƒ» ê° í”Œë«í¼ ì‚¬ìš©ë²•ì€ ë©”ì„¸ì§€ì™€ í•¨ê»˜ ì•ˆë‚´ë©ë‹ˆë‹¤.\n"+
				"ãƒ» <i>ë¬¸ì˜ ì‚¬í•­ì€ ê³ ê°ì„¼í„°ë¡œ ì—°ë½ ì£¼ì„¸ìš”.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_membership ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_esim":
		photoFile := "/home/minho/epusdt/images/esim_usage.jpeg" // ì ˆëŒ€ê²½ë¡œ
		photoMsg := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(photoFile))
		photoMsg.Caption = "ğŸ“± <b>(E-SIM) ì•ˆë‚´</b>\n\n" +
			"ãƒ» DATA ONLY, 5G/4G ê±±ì •X\n" +
			"ãƒ» ê²°ì œ í›„ QRì½”ë“œ ì •ë³´ê°€ ìë™ ì§€ê¸‰ë©ë‹ˆë‹¤.\n" +
			"ãƒ» ìœ„ì¹˜ ì¡°íšŒì‹œ í™ì½© í™ì½©ë²ˆí˜¸ ë¶€ì—¬.\n"
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("help_esim ì‚¬ì§„ ì „ì†¡ ì‹¤íŒ¨: %v", err)
			sendTelegram(uid, "âŒ eSIM ì•ˆë‚´ ì´ë¯¸ì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
		}

	case "help_energy":
		msgText := `<b>ğŸª« USDT ì†¡ê¸ˆ ìˆ˜ìˆ˜ë£Œ 80% ì ˆê° ğŸª«</b>
	
	ğŸ’¸ ì „ì†¡ 1íšŒë‹¹ ìˆ˜ìˆ˜ë£Œ ìµœëŒ€ ë§Œì› ì ˆê°
	
	ğŸ“Š í‰ê·  í…Œë” 100íšŒ ì†¡ê¸ˆ ì‹œ íŠ¸ë¡  ì†Œë¹„ëŸ‰ ë¹„êµ
	
	ğŸ”¹ ì¼ë°˜ ì†¡ê¸ˆ: ìµœì†Œ 1,800 ~ 2,800 TRX   
	ğŸ”¹ ì—ë„ˆì§€ ì†¡ê¸ˆ: ìµœì†Œ 250 ~ 500 TRX
	
	<b>KRW ê¸°ì¤€</b>
	ì¼ë°˜ì†¡ê¸ˆ : 670,000 ~ 1,036,000
	ì—ë„ˆì§€ì†¡ê¸ˆ : 92,500 ~ 185,000
	
	1íšŒ ì „ì†¡ì— í•„ìš”í•œ ì—ë„ˆì§€ = 65K ì—ë„ˆì§€
	
	65K ì—ë„ˆì§€ = 2.5 TRX (ì „ì†¡ 1íšŒ)  
	ì˜ˆ: 10 TRX = 260K ì—ë„ˆì§€ (3~4íšŒ)
	
	â± ì „ì†¡í•œ ì£¼ì†Œë¡œ 5ì´ˆ ì´ë‚´ ì—ë„ˆì§€ í• ë‹¹ ì™„ë£Œ
	
	â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
	
	â¬‡ï¸ <b>ê²°ì œ ì£¼ì†Œ</b> â¬‡ï¸
	
	<b><code>TDFfEdkdkdkdososlsksospzkPn</code></b>
	
	â¬†ï¸ ì£¼ì†Œ í´ë¦­ ì‹œ ìë™ ë³µì‚¬ â¬†ï¸
	
	â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
	
	â³ ì—ë„ˆì§€ëŠ” 1ì‹œê°„ í›„ ìë™ ì†Œë©¸  
	âš ï¸ USDTê°€ ì—†ëŠ” ìƒˆ ì§€ê°‘ìœ¼ë¡œ ì†¡ê¸ˆ ì‹œ  
	130K ì—ë„ˆì§€(5 TRX) ë°œìƒ ê°€ëŠ¥  
	ì†¡ê¸ˆ ì „ ìˆ˜ìˆ˜ë£Œ ê¼­ í™•ì¸`

		msg := tgbotapi.NewMessage(uid, msgText)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_energy ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_card":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ’³ <b>(CARD) ê²°ì œ ì•ˆë‚´</b>\n\n"+
				"ãƒ» ëŒ€ë¦¬ ë° VPN ê²°ì œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"+
				"ãƒ» êµ¬ë§¤ í›„ 'ê³ ê°ì„¼í„°' ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_card ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_swap":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ”„ <b>ìŠ¤ì™‘ ì•ˆë‚´</b>\n\n"+
				"ì½”ì¸ ìŠ¤ì™‘ ì ì‹œ ì ê²€ ì¤‘ì…ë‹ˆë‹¤.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_swap ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_vps":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ–¥ï¸ <b>VPS/KVM ì•ˆë‚´</b>\n\n"+
				"ì—¬ëŸ¬ ê°€ì§€ VPS ë° KVM ì„œë²„ ì˜µì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.\n"+
				"ë” ìì„¸í•œ ë‚´ìš©ì€ ì œí’ˆ ëª©ë¡ì—ì„œ í™•ì¸í•˜ì„¸ìš”.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_vps ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	default:
		msg := tgbotapi.NewMessage(uid,
			"â“ í•´ë‹¹ ë„ì›€ë§ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_default ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func handleBalancePayment(orderID uint, userID int64) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	if order.Status != "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
		return fmt.Errorf("ì˜ëª»ëœ ì£¼ë¬¸ ìƒíƒœ: %s", order.Status)
	}

	balance, err := getUserBalance(userID)
	if err != nil {
		return fmt.Errorf("ì”ì•¡ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}
	if balance < order.Amount {
		return fmt.Errorf("ì”ì•¡ ë¶€ì¡± (ë³´ìœ : %.2f, í•„ìš”: %.2f)", balance, order.Amount)
	}

	// íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ê¶Œì¥ (ì•„ë˜ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ)
	if err := deductBalance(userID, order.Amount); err != nil {
		return fmt.Errorf("ì”ì•¡ ì°¨ê° ì‹¤íŒ¨: %w", err)
	}

	order.Status = "ì™„ë£Œ"
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
	}

	// ê´€ë¦¬ì ì•Œë¦¼
	adminChatID := getAdminChatID()
	adminMsg := fmt.Sprintf(
		"ğŸ’³ ì”ì•¡ ê²°ì œ ì™„ë£Œ\nì£¼ë¬¸ë²ˆí˜¸: %d\nì‚¬ìš©ìID: %d\nê¸ˆì•¡: %.2f USDT",
		order.ID, userID, order.Amount)
	if _, err := bot.Send(tgbotapi.NewMessage(adminChatID, adminMsg)); err != nil {
		log.Printf("ê´€ë¦¬ì ì•Œë¦¼ ì‹¤íŒ¨: %v", err)
	}

	// ìœ ì € ì•Œë¦¼
	sendTelegram(userID, fmt.Sprintf(
		"âœ… ì”ì•¡ ê²°ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\nì£¼ë¬¸ë²ˆí˜¸: %d\nê¸ˆì•¡: %.2f USDT",
		order.ID, order.Amount,
	))

	return nil
}

func handleMenuCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleMenuCallback] cb.Data: %s", cb.Data)
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	switch cb.Data {
	case "menu_products":
		showCategoryMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸ›’ ìƒí’ˆ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤"))
		return

	case "menu_swap":
		showSwapMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸ”„ ì½”ì¸ êµí™˜"))
		return

	case "admin_monthly_report":
		handleAdminMonthlyReport(uid, chatID, messageID, cb.ID)
		return

	case "admin_yearly_report":
		handleAdminYearlyReport(uid, chatID, messageID, cb.ID)
		return

	case "go_main":
		// ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ
		if cb.Message != nil {
			delMsg := tgbotapi.NewDeleteMessage(cb.Message.Chat.ID, cb.Message.MessageID)
			if _, err := bot.Request(delMsg); err != nil {
				log.Printf("[go_main] ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
			}
		}

		// ìƒˆ ë©”ë‰´ ì¶œë ¥
		showMenu(uid, cb.From.UserName, cb.Message.Chat.ID)

		bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
		return

	default:
		log.Printf("[handleMenuCallback] ì•Œ ìˆ˜ ì—†ëŠ” ë©”ë‰´: %s", cb.Data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "â“ ì•Œ ìˆ˜ ì—†ëŠ” ë©”ë‰´ì…ë‹ˆë‹¤"))
		return
	}
}

func getStockCount(productName string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).
		Where("name = ? AND used = ?", productName, false).
		Count(&count).Error
	if err != nil {
		return 0, err
	}
	return count, nil
}

func showSwapMenu(uid, chatID int64, messageID int) {
	swapPairs := []struct {
		display string
		data    string
	}{
		{"USDT â†’ TRX", "swap_usdt_trx"},
		{"TRX â†’ USDT", "swap_trx_usdt"},
		{"USDT â†’ ETH", "swap_usdt_eth"},
		{"ETH â†’ USDT", "swap_eth_usdt"},
		{"USDT â†’ SOL", "swap_usdt_sol"},
		{"SOL â†’ USDT", "swap_sol_usdt"},
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(swapPairs); i += 2 {
		var row []tgbotapi.InlineKeyboardButton
		row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i].display, swapPairs[i].data))
		if i+1 < len(swapPairs) {
			row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i+1].display, swapPairs[i+1].data))
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// ë§ˆì§€ë§‰ í•œ ì¤„ì€ ë©”ë‰´ë¡œ ê°€ê¸° ë²„íŠ¼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ”„ ì½”ì¸ ìŠ¤ì™‘ ë©”ë‰´\n ë³€ê²½í•  ì½”ì¸ì„ ì„ íƒí•˜ì„¸ìš”.[ì ê²€]")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showSwapMenu ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ìƒí’ˆ ì½œë°± ì²˜ë¦¬
func handleProductCallback(cb *tgbotapi.CallbackQuery) {
	data := cb.Data // ì˜ˆ: "prod_vps1"
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID

	code := strings.TrimPrefix(data, "prod_")

	for _, category := range cardCategories {
		for name, prod := range category {
			if prod.Code == code {
				text := fmt.Sprintf("<b>%s</b>\n\n%s\n\nğŸ’° ê°€ê²©: %.2f USDT", name, prod.Description, prod.Price)
				edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
				edit.ParseMode = "HTML"
				bot.Send(edit)

				// í™•ì¸ ë²„íŠ¼ ë³´ì—¬ì£¼ê¸°
				showOrderConfirmButtons(cb, code)
				return
			}
		}
	}

	bot.Send(tgbotapi.NewMessage(chatID, "âŒ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."))
}

func showOrderConfirmButtons(cb *tgbotapi.CallbackQuery, productCode string) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	var prodName string
	var price float64
	found := false

	// VPS ìƒí’ˆì¸ì§€ ë¨¼ì € ì²´í¬
	if vpsProd, ok := vpsProductMap[productCode]; ok {
		prodName = vpsProd.Name
		price = vpsProd.Price
		found = true
	} else {
		// ì¼ë°˜ ì¹´ë“œ ìƒí’ˆì—ì„œ ì°¾ê¸°
		for _, products := range cardCategories {
			for _, prod := range products {
				if prod.Code == productCode {
					prodName = prod.Name
					price = prod.Price
					found = true
					break
				}
			}
			if found {
				break
			}
		}
	}

	if !found {
		sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		callback := tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ì •ë³´ ì—†ìŒ")
		bot.Request(callback)
		return
	}

	// ì£¼ë¬¸ ìƒì„±
	order, err := createOrder(uid, prodName, price)
	if err != nil {
		sendTelegram(uid, "âŒ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: "+err.Error())
		return
	}

	// ë©”ì‹œì§€ í…ìŠ¤íŠ¸ êµ¬ì„±
	msgText := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ›’ <b>%s</b>\n"+
			"ğŸ’° ê°€ê²©: <b>%.3f USDT</b>\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"<b>ê²°ì œìˆ˜ë‹¨ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.</b>\n",
		prodName, price,
	)

	// ì¸ë¼ì¸ ë²„íŠ¼ êµ¬ì„±
	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’¸ ì½”ì¸ ê²°ì œ", fmt.Sprintf("pay_coin_%d", order.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¦ ì”ì•¡ ê²°ì œ", fmt.Sprintf("pay_balance_%d", order.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	// ë©”ì‹œì§€ ìˆ˜ì • ë° ì „ì†¡
	edt := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, markup)
	edt.ParseMode = "HTML"
	if _, err := bot.Send(edt); err != nil {
		log.Printf("âŒ ì£¼ë¬¸ í™•ì¸ ë²„íŠ¼ í‘œì‹œ ì‹¤íŒ¨: %v", err)
	}
}

func main() {
	var err error
	db, err = initDB()
	if err != nil {
		log.Fatalf("ì´ˆê¸°í™” ì‹¤íŒ¨: %v", err)
	}

	if err := migrateDB(db); err != nil {
		log.Fatalf("ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %v", err)
	}

	err = addProductsByCategory(db, map[string][]Product{
		"VPS": {
			{Code: "vps1", Name: "KVM - E1", Description: "CPU: 4ì½”ì–´, RAM: 4GB, ì €ì¥ê³µê°„: 100GB NVMe", Price: 70, Active: true},
			{Code: "vps2", Name: "KVM - E2", Description: "CPU: 4ì½”ì–´, RAM: 6GB, ì €ì¥ê³µê°„: 140GB NVMe", Price: 90, Active: true},
			{Code: "vps3", Name: "KVM - T1", Description: "CPU: 8ì½”ì–´, RAM: 16GB, ì €ì¥ê³µê°„: 160GB NVMe", Price: 120, Active: true},
			{Code: "vps4", Name: "KVM - T2", Description: "CPU: 12ì½”ì–´, RAM: 24GB, ì €ì¥ê³µê°„: 256GB NVMe", Price: 150, Active: true},
			{Code: "vps5", Name: "ë§ì¶¤ ì œì‘", Description: "ë§ì¶¤í˜• ì‚¬ì–‘ ì œê³µ, ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´", Price: 1, Active: true},
		},
		"ACCOUNT": {
			{Code: "tgid1", Name: "TG 1ë…„", Price: 8, Active: true},
			{Code: "tgid2", Name: "TG 2ë…„", Price: 20, Active: true},
			{Code: "tgid3", Name: "ì§§ì€ ë²ˆí˜¸", Price: 60, Active: true},
		},
		"MEMBERSHIP": {
			{Code: "tp3", Name: "TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”", Price: 17, Active: true},
			{Code: "tp12", Name: "TG í”„ë¦¬ë¯¸ì—„ 1ë…„", Price: 45, Active: true},
			{Code: "yp12", Name: "YT í”„ë¦¬ë¯¸ì—„ 1ë…„", Price: 60, Active: true},
		},
		"ESIM": {
			{Code: "es1", Name: "DATA 30 DAY", Price: 70, Active: true},
			{Code: "es2", Name: "KOREA|HK", Price: 999, Active: true},
			{Code: "es3", Name: "NO KYC", Price: 999, Active: true},
		},
		"CARD": {
			{Code: "card1", Name: "êµ­ë‚´ê²°ì œ", Price: 10, Active: true},
			{Code: "card2", Name: "êµ­ì™¸ê²°ì œ", Price: 10, Active: true},
			{Code: "card3", Name: "í•­ê³µê¶Œ", Price: 10, Active: true},
		},
	})
	if err != nil {
		log.Fatalf("ìƒí’ˆ ë“±ë¡ ì‹¤íŒ¨: %v", err)
	} else {
		log.Println("âœ… ì „ì²´ ìƒí’ˆ ë“±ë¡ ì™„ë£Œ")
	}

	log.Println("âœ… ì´ˆê¸°í™” ì™„ë£Œ")
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	rand.Seed(time.Now().UnixNano())
	log.Println("ğŸš€ EPUSDT ë´‡ ì‹œì‘ ì¤‘...")

	startTime := time.Now()

	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		log.Fatal("âŒ TELEGRAM_BOT_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	log.Printf("ğŸ” ë¡œë“œëœ í† í°: %s", token)

	startDepositMonitoring()

	bot, err = initBotWithWebhook()
	if err != nil {
		log.Fatalf("âŒ ë´‡ ì´ˆê¸°í™” ì‹¤íŒ¨: %v", err)
	}
	log.Println("âœ… ë´‡ ì´ˆê¸°í™” ì™„ë£Œ")

	router := gin.Default()
	router.SetTrustedProxies(nil)
	router.POST("/webhook", handleWebhook)
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok", "uptime": time.Since(startTime).String()})
	})

	log.Println("ğŸŒ ì„œë²„ë¥¼ 9020 í¬íŠ¸ì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤...")
	if err := router.Run(":9020"); err != nil {
		log.Fatalf("âŒ ì„œë²„ ì‹¤í–‰ ì‹¤íŒ¨: %v", err)
	}
}

// ë¬¸ìì—´ í¬ì¸í„° ìƒì„± í•¨ìˆ˜
func ptr(s string) *string {
	sCopy := s
	return &sCopy
}

func createOrder(uid int64, prodName string, price float64) (*Order, error) {
	emptyTxID := "" // ë¹ˆ ë¬¸ìì—´ ë³€ìˆ˜ ì„ ì–¸
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        &emptyTxID, // ë¹ˆ ë¬¸ìì—´ í¬ì¸í„° ì „ë‹¬
	}
	if err := db.Create(&order).Error; err != nil {
		return nil, err
	}
	return &order, nil
}

func confirmDeposit(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return err
	}

	// ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
	order.Status = "ì…ê¸ˆí™•ì¸"
	txIDCopy := txID
	order.TxID = &txIDCopy

	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// ì¹´ë“œ ìë™ ì§€ê¸‰ ë¶€ë¶„ ì œê±°ë¨
	// ì¹´ë“œ ì •ë³´ ì—…ë°ì´íŠ¸ëŠ” í•„ìš”ì— ë”°ë¼ ì§ì ‘ ì²˜ë¦¬í•˜ì„¸ìš”
	// ì˜ˆë¥¼ ë“¤ì–´, ì¹´ë“œ ì •ë³´ ì—†ì´ ìƒíƒœë§Œ ì™„ë£Œ ì²˜ë¦¬í•  ê²½ìš°:

	order.Status = "ì™„ë£Œ"
	if err := db.Save(&order).Error; err != nil {
		return err
	}
	if err := addVPSProducts(); err != nil {
		log.Fatalf("VPS ìƒí’ˆ ë“±ë¡ ì‹¤íŒ¨: %v", err)
	}
	// ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì—ëŸ¬ ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ë¦¬í„´ì€ ì•ˆí•¨)
	if err := sendTelegram(order.UserID, fmt.Sprintf("âœ… ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\nìƒí’ˆ: %s\n", order.Product)); err != nil {
		log.Printf("ì‚¬ìš©ì ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	return nil
}

// ì”ì•¡ í™•ì¸
func getUserBalance(userID int64) (float64, error) {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// ì”ì•¡ì´ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™”
			balance = UserBalance{UserID: userID, Balance: 0}
			db.Create(&balance)
			return 0, nil
		}
		return 0, err
	}
	return balance.Balance, nil
}

// ì”ì•¡ ì°¨ê°
func deductBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		return err
	}

	if balance.Balance < amount {
		return fmt.Errorf("ì”ì•¡ ë¶€ì¡±")
	}

	balance.Balance -= amount
	return db.Save(&balance).Error
}

// ì”ì•¡ ì¶”ê°€
func addBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance = UserBalance{UserID: userID, Balance: amount}
			return db.Create(&balance).Error
		}
		return err
	}

	balance.Balance += amount
	return db.Save(&balance).Error
}

// ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ
func getUserOrders(userID int64) ([]Order, error) {
	var orders []Order
	err := db.Where("user_id = ?", userID).Order("timestamp desc").Find(&orders).Error
	return orders, err
}

// ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
func updateOrderStatus(orderID uint, status string) error {
	return db.Model(&Order{}).Where("id = ?", orderID).Update("status", status).Error
}

// ì¹´ë“œ ì¬ê³  í™•ì¸
func getCardStock(category string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).Where("category = ? AND used = ?", category, false).Count(&count).Error
	return count, err
}

// ì‚¬ìš©ëœ ì¹´ë“œ ì¡°íšŒ
func getUsedCards(userID int64) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("used_by = ?", userID).Find(&cards).Error
	return cards, err
}

// í†µê³„ ë°ì´í„° ì¡°íšŒ
func updateDailyStats(amount float64) error {
	today := time.Now().Format("2006-01-02")

	var stats SalesStats
	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: amount, TotalCount: 1, Count: 1, SalesCount: 1}
			return db.Create(&stats).Error
		}
		return err
	}

	stats.TotalSales += amount
	stats.TotalCount++
	stats.Count++
	stats.SalesCount++

	return db.Save(&stats).Error
}

func handleCreateTransaction(c *gin.Context) {
	var req struct {
		UserID      int64   `json:"user_id"`
		ProductCode string  `json:"product_code"`
		Amount      float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "ì˜ëª»ëœ ìš”ì²­"})
		return
	}

	// ì£¼ë¬¸ ìƒì„±
	order, err := createOrder(req.UserID, req.ProductCode, req.Amount)
	if err != nil {
		c.JSON(500, gin.H{"error": "ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨"})
		return
	}

	// ì§€ê°‘ ì£¼ì†Œ ìƒì„±
	walletAddress, err := generateWalletAddress()
	if err != nil {
		c.JSON(500, gin.H{"error": "ì§€ê°‘ ìƒì„± ì‹¤íŒ¨"})
		return
	}

	c.JSON(200, gin.H{
		"order_id": order.ID,
		"address":  walletAddress,
		"amount":   req.Amount,
	})
}

func showAdminStockMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	text := "ğŸ“¦ ì¬ê³  í˜„í™©\n\n"
	totalStock := int64(0)

	for _, category := range categories {
		count, err := getCardStock(category)
		if err != nil {
			text += fmt.Sprintf("âŒ %s: ì¡°íšŒ ì‹¤íŒ¨\n", category)
		} else {
			text += fmt.Sprintf("âœ… %s: %dê°œ\n", category, count)
			totalStock += count
		}
	}

	text += fmt.Sprintf("\nğŸ“Š ì´ ì¬ê³ : %dê°œ", totalStock)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ìƒì„¸ë³´ê¸°", "admin_stock_detail"),
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", "admin_add_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì¬ê³ ì‚­ì œ", "admin_del_stock"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š ë¶„ì„", "admin_stock_analytics"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func createProductManagementKeyboard(productID int, productName string, price float64) tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s %.2fUSDT", productName, price), fmt.Sprintf("product_detail_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ ìˆ˜ì •", fmt.Sprintf("product_edit_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì‚­ì œ", fmt.Sprintf("product_delete_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“¦ ì¬ê³ ", fmt.Sprintf("product_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", fmt.Sprintf("product_add_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ìë©”ë‰´ë¡œ", "admin_menu"),
		),
	)
}

func showProductListForCategory(uid, chatID int64, messageID int, category string) {
	products, err := getProductsByCategory(db, category)
	if err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		return
	}

	text := fmt.Sprintf("ğŸ“‹ %s ìƒí’ˆ ëª©ë¡\n\n", category)
	for i, p := range products {
		text += fmt.Sprintf("%d. %s - %.2f USDT\n", i+1, p.Name, p.Price)
	}

	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		kb := createProductManagementKeyboard(int(p.ID), p.Name, p.Price)
		keyboardRows = append(keyboardRows, kb.InlineKeyboard...)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: keyboardRows}
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ìƒí’ˆ ë¦¬ìŠ¤íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func getProductsByCategory(db *gorm.DB, categoryName string) ([]Product, error) {
	var category Category
	if err := db.Where("name = ?", categoryName).First(&category).Error; err != nil {
		return nil, err
	}

	var products []Product
	if err := db.Where("category_id = ? AND active = ?", category.ID, true).Find(&products).Error; err != nil {
		return nil, err
	}

	return products, nil
}

func showAdminStatsMenu(uid int64, chatID int64, msgID int, period string) {
	var text string
	var kb tgbotapi.InlineKeyboardMarkup

	switch period {
	case "daily":
		stats, err := getDailyStatsNew()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"ğŸ“Š ì¼ì¼ í†µê³„ (%s)\n\nì´ ë§¤ì¶œ: %.4f USDT\nì´ ì£¼ë¬¸: %dê±´\nì™„ë£Œ ì£¼ë¬¸: %dê±´",
			stats.Date, stats.TotalSales, stats.TotalCount, stats.SalesCount,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì£¼ê°„ í†µê³„", "admin_stats_weekly"),
				tgbotapi.NewInlineKeyboardButtonData("ì›”ê°„ í†µê³„", "admin_stats_monthly"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ í†µê³„", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
			),
		)

	case "weekly":
		stats, err := getWeeklyStats()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "âŒ ì£¼ê°„ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"ğŸ“… ì£¼ê°„ í†µê³„\nê¸°ê°„: %s ~ %s\n\nì´ ë§¤ì¶œ: %.2f USDT\nì´ ì£¼ë¬¸ ìˆ˜: %dê±´",
			stats.StartDate, stats.EndDate, stats.TotalSales, stats.TotalOrders,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì›”ê°„ í†µê³„", "admin_stats_monthly"),
				tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ í†µê³„", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
			),
		)

	case "monthly":
		stats, err := getMonthlyStats()
		if err != nil {
			msg := tgbotapi.NewEditMessageText(chatID, msgID, "âŒ ì›”ê°„ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨")
			bot.Send(msg)
			return
		}
		text = fmt.Sprintf(
			"ğŸ“… ì›”ê°„ í†µê³„\nê¸°ê°„: %s\n\nì´ ë§¤ì¶œ: %.2f USDT\nì´ ì£¼ë¬¸ ìˆ˜: %dê±´",
			stats.Date, stats.TotalSales, stats.TotalCount,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ í†µê³„", "admin_stats_all"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
			),
		)

	case "all":
		var totalSales float64
		var totalOrders int64
		db.Model(&Order{}).Select("SUM(amount)").Row().Scan(&totalSales)
		db.Model(&Order{}).Count(&totalOrders)

		text = fmt.Sprintf(
			"<b>ì „ì²´ í†µê³„</b>\n\nì´ ë§¤ì¶œ: %.2f USDT\nì´ ì£¼ë¬¸ ìˆ˜: %dê±´",
			totalSales, totalOrders,
		)
		kb = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
			),
		)

	default:
		showAdminStatsMenu(uid, chatID, msgID, "daily")
		return
	}

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func showAdminUserListMenu(chatID int64, messageID int) {
	// ìœ ì € ëª©ë¡ ì¡°íšŒ (ìµœê·¼ 10ëª…)
	users, err := getRecentUsers(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ìœ ì € ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ‘¥ ìµœê·¼ ê°€ì… ìœ ì € (10ëª…)\n\n"
	var rows [][]tgbotapi.InlineKeyboardButton

	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(ë‹‰ë„¤ì„ì—†ìŒ)"
		}
		userName := user.UserName
		if userName == "" {
			userName = "ì—†ìŒ"
		}
		text += fmt.Sprintf(
			"%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1, nickname, user.UserID, userName, user.LastSeen.Format("01-02 15:04"),
		)
		// ë²„íŠ¼ì—ë„ ë‹‰ë„¤ì„ í‘œì‹œ
		btn := tgbotapi.NewInlineKeyboardButtonData(
			nickname,
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// í•˜ë‹¨ ê³ ì • ë²„íŠ¼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ ìœ ì €", "admin_all_users"),
	))
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Request(msg)
}

func getUserByUserID(userID int64) (*User, error) {
	var user User
	result := db.Where("user_id = ?", userID).First(&user)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

func showAdminUserDetailMenu(chatID int64, messageID int, userID int64) {
	user, err := getUserByUserID(userID)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ìœ ì € ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Send(msg)
		return
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := func() string {
		if user.UserName == "" {
			return "(ì—†ìŒ)"
		}
		return "@" + user.UserName
	}()

	fullMsg := fmt.Sprintf(
		`<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b> : %d
ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b> : %s
â° <b>ìµœê·¼ ì ‘ì†</b> : %s
ë“±ê¸‰ : %s %s
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>`,
		user.UserID,
		displayName,
		user.LastSeen.Format("2006-01-02 15:04:05"),
		emoji,
		user.Grade,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‰", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥ˆ", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‡", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘", fmt.Sprintf("admin_set_grade_vip_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_user_list"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, fullMsg)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ìœ ì € ìƒì„¸ ì •ë³´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func showAdminOrderListMenu(uid, chatID int64, messageID int) {
	// ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ
	orders, err := getRecentOrders(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ“‹ ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ (10ê±´)\n\n"
	for i, order := range orders {
		text += fmt.Sprintf("%d. %s - %.4f USDT - %s\n",
			i+1, order.Product, order.Amount, order.Status)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ì „ì²´ ì£¼ë¬¸", CallbackData: ptr("admin_all_orders")}},
			{{Text: "ë¯¸ì²˜ë¦¬ ì£¼ë¬¸", CallbackData: ptr("admin_pending_orders")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
func getRecentUsers(limit int) ([]User, error) {
	var users []User
	err := db.Order("last_seen desc").Limit(limit).Find(&users).Error
	return users, err
}

func getRecentOrders(limit int) ([]Order, error) {
	var orders []Order
	err := db.Order("timestamp desc").Limit(limit).Find(&orders).Error
	return orders, err
}

func getPendingOrders() ([]Order, error) {
	var orders []Order
	err := db.Where("status = ?", "ì…ê¸ˆëŒ€ê¸°ì¤‘").Find(&orders).Error
	return orders, err
}

func getSumAmountBetweenDatesAndCategory(start, end, categoryLike string) (float64, error) {
	var total sql.NullFloat64
	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		start, end, categoryLike+"%",
	).Scan(&total).Error
	if err != nil {
		return 0, err
	}
	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULLì¸ ê²½ìš° 0 ë°˜í™˜
}

// ì£¼ê°„/ì›”ê°„ í†µê³„
func getWeeklyStats() (WeeklyStats, error) {
	var stats WeeklyStats

	now := time.Now()
	weekday := int(now.Weekday())
	if weekday == 0 {
		weekday = 7
	}
	startOfWeek := now.AddDate(0, 0, -(weekday - 1))
	endOfWeek := startOfWeek.AddDate(0, 0, 6)

	stats.StartDate = startOfWeek.Format("2006-01-02")
	stats.EndDate = endOfWeek.Format("2006-01-02")

	err := db.Model(&Order{}).
		Select("IFNULL(SUM(amount),0)").
		Where("created_at BETWEEN ? AND ?", stats.StartDate+" 00:00:00", stats.EndDate+" 23:59:59").
		Scan(&stats.TotalSales).Error
	if err != nil {
		return stats, err
	}

	err = db.Model(&Order{}).
		Where("created_at BETWEEN ? AND ?", stats.StartDate+" 00:00:00", stats.EndDate+" 23:59:59").
		Count(&stats.TotalOrders).Error
	if err != nil {
		return stats, err
	}

	return stats, nil
}

func showWeeklyStatsMenu(chatID int64, msgID int) {
	stats, err := getWeeklyStats()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, msgID, "âŒ ì£¼ê°„ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Send(msg)
		return
	}

	text := fmt.Sprintf(
		"ğŸ“… ì£¼ê°„ í†µê³„\nê¸°ê°„: %s ~ %s\n\nì´ ë§¤ì¶œ: %.2f USDT\nì´ ì£¼ë¬¸ ìˆ˜: %dê±´",
		stats.StartDate, stats.EndDate, stats.TotalSales, stats.TotalOrders,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì›”ê°„ í†µê³„", "admin_monthly_report"),
			tgbotapi.NewInlineKeyboardButtonData("ì—°ê°„ í†µê³„", "admin_yearly_report"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func getMonthlyStats() (SalesStats, error) {
	var stats SalesStats

	now := time.Now()
	year, month, _ := now.Date()
	location := now.Location()

	// ì›” ì‹œì‘: ì´ë²ˆ ë‹¬ 1ì¼ 00:00:00
	monthStart := time.Date(year, month, 1, 0, 0, 0, 0, location)
	// ë‹¤ìŒ ë‹¬ ì‹œì‘ (ì›” ì¢…ë£Œ)
	nextMonthStart := monthStart.AddDate(0, 1, 0)

	// ì›”ê°„ ì´ ë§¤ì¶œê³¼ ì£¼ë¬¸ ê±´ìˆ˜ í•©ì‚°
	err := db.Model(&Order{}).
		Select("IFNULL(SUM(amount),0) as total_sales, COUNT(*) as total_orders").
		Where("created_at >= ? AND created_at < ?", monthStart, nextMonthStart).
		Scan(&stats).Error

	if err != nil {
		return stats, err
	}

	stats.Date = monthStart.Format("2006-01")

	return stats, nil
}

// ì¹´ë“œ ì¬ê³  ê´€ë¦¬
func addCardStock(category, name, content string) error {
	card := StockCard{
		Category:  category,
		Name:      name,
		Content:   content,
		Used:      false,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	return db.Create(&card).Error // â˜… ìˆ˜ì •!
}

func deleteCardStock(cardID uint) error {
	return db.Delete(&StockCard{}, cardID).Error
}

func getCardStockByCategory(category string) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("category = ?", category).Find(&cards).Error
	return cards, err
}

// ì‚¬ìš©ì í™œë™ ë¡œê·¸
func logUserActivity(userID int64, action string) error {
	log := UserActivityLog{
		UserID:     userID,
		LastActive: time.Now(),
	}
	return db.Create(&log).Error
}

// ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
func checkSystemHealth() map[string]interface{} {
	health := make(map[string]interface{})

	// DB ì—°ê²° ìƒíƒœ
	sqlDB, err := db.DB()
	if err != nil {
		health["database"] = "error"
	} else if err = sqlDB.Ping(); err != nil {
		health["database"] = "error"
	} else {
		health["database"] = "ok"
	}

	// ë´‡ ìƒíƒœ
	if bot != nil {
		health["bot"] = "ok"
	} else {
		health["bot"] = "error"
	}

	// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	health["memory_mb"] = float64(m.Alloc) / 1024 / 1024

	// ì—…íƒ€ì„
	health["uptime"] = time.Since(startTime).String()

	return health
}

func updateBotSettings(newSettings map[string]interface{}) error {
	for key, value := range newSettings {
		if err := db.Model(&BotSetting{}).
			Where("key = ?", key).
			Update("value", value).Error; err != nil {
			log.Printf("ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
			return err
		}
	}

	// í•„ìš”í•˜ë©´ ì „ì—­ë³€ìˆ˜, ìºì‹œ ë“±ë„ ì—¬ê¸°ì„œ ì—…ë°ì´íŠ¸

	log.Println("ë´‡ ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë˜ì—ˆìŠµë‹ˆë‹¤.")
	return nil
}

func getBotSettings() map[string]string {
	settings := make(map[string]string)
	settings["webhook_url"] = os.Getenv("WEBHOOK_URL")
	settings["tron_api_key"] = os.Getenv("TRON_API_KEY")
	settings["admin_user_id"] = os.Getenv("ADMIN_USER_ID")
	return settings
}

// ë¡œê·¸ ê´€ë¦¬
func getSystemLogs(limit int) ([]string, error) {
	// ì‹œìŠ¤í…œ ë¡œê·¸ ì¡°íšŒ ë¡œì§
	logs := []string{
		"2025-06-29 21:14:15 [INFO] ë´‡ ì‹œì‘ë¨",
		"2025-06-29 21:14:16 [INFO] DB ì—°ê²° ì„±ê³µ",
		"2025-06-29 21:14:17 [INFO] ì›¹í›… ì„¤ì • ì™„ë£Œ",
	}
	return logs, nil
}

func clearSystemLogs() error {
	// ì‹œìŠ¤í…œ ë¡œê·¸ ì •ë¦¬ ë¡œì§
	log.Println("ì‹œìŠ¤í…œ ë¡œê·¸ ì •ë¦¬ ì™„ë£Œ")
	return nil
}

// ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ë©”ë‰´
func showSystemHealthMenu(uid, chatID int64, messageID int) {
	health := checkSystemHealth()

	text := "ğŸ” ì‹œìŠ¤í…œ ìƒíƒœ\n\n"
	text += fmt.Sprintf("ë°ì´í„°ë² ì´ìŠ¤: %s\n", health["database"])
	text += fmt.Sprintf("ë´‡ ìƒíƒœ: %s\n", health["bot"])
	text += fmt.Sprintf("ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: %.2f MB\n", health["memory_mb"])
	text += fmt.Sprintf("ì—…íƒ€ì„: %s\n", health["uptime"])

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ìƒˆë¡œê³ ì¹¨", CallbackData: ptr("admin_refresh_health")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ë¡œê·¸ ê´€ë¦¬ ë©”ë‰´
func showLogsMenu(uid, chatID int64, messageID int) {
	logs, err := getSystemLogs(5)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ“‹ ìµœê·¼ ì‹œìŠ¤í…œ ë¡œê·¸ (5ê±´)\n\n"
	for _, log := range logs {
		text += log + "\n"
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ë¡œê·¸ ì •ë¦¬", CallbackData: ptr("admin_clear_logs")}},
			{{Text: "ì „ì²´ ë¡œê·¸", CallbackData: ptr("admin_all_logs")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ì¬ê³  ì¡°íšŒ ë° ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ ë‚´ìš© ë°˜í™˜ í•¨ìˆ˜
func getCardStockAndContent(productName string) (int64, string, error) {
	var card StockCard
	count, err := getStockCount(productName)
	if err != nil {
		return 0, "", err
	}
	if count == 0 {
		return 0, "", nil
	}

	// ì¬ê³  ì¤‘ í•˜ë‚˜ì˜ ì¹´ë“œ ë‚´ìš©ì„ ê°€ì ¸ì˜´
	err = db.Where("name = ? AND used = ?", productName, false).First(&card).Error
	if err != nil {
		return count, "", err
	}

	return count, card.Content, nil
}

func addUserBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", userID).Error
	if err != nil { // ì”ì•¡ ê¸°ë¡ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
		balance = UserBalance{
			UserID:  userID,
			Balance: amount,
		}
		return db.Create(&balance).Error
	}
	// ê¸°ì¡´ ì”ì•¡ì— ì¶”ê°€
	balance.Balance += amount
	return db.Save(&balance).Error
}

func processOrderWithValidation(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	if order.Status != "ì…ê¸ˆëŒ€ê¸°ì¤‘" && order.Status != "ê²°ì œì™„ë£Œ" {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: %s", order.Status)
	}

	stock, cardContent, err := getCardStockAndContent(order.Product)
	if err != nil {
		return fmt.Errorf("ì¬ê³  ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}
	if stock <= 0 {
		order.Status = "ì¬ê³ ì—†ìŒ"
		if err := db.Save(&order).Error; err != nil {
			return fmt.Errorf("ì¬ê³  ë¶€ì¡± ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
		}
		sendTelegram(order.UserID, "âŒ ì£¼ë¬¸í•˜ì‹  ìƒí’ˆì˜ ì¬ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
		return fmt.Errorf("ìƒí’ˆ ì¬ê³  ë¶€ì¡±: %s", order.Product)
	}

	err = db.Model(&StockCard{}).
		Where("name = ? AND used = 0", order.Product).
		Limit(1).
		Updates(map[string]interface{}{
			"used":     true,
			"used_by":  order.UserID,
			"order_id": order.ID,
		}).Error
	if err != nil {
		return fmt.Errorf("ì¬ê³  ì¹´ë“œ ì‚¬ìš© ì²˜ë¦¬ ì‹¤íŒ¨: %w", err)
	}

	txIDCopy := txID
	order.CardInfo = cardContent
	order.Status = "ì™„ë£Œ"
	order.TxID = &txIDCopy
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
	}

	if err := updateDailyStats(order.Amount); err != nil {
		log.Printf("í†µê³„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
	}

	notifyMsg := fmt.Sprintf(
		"ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤\n\nìƒí’ˆëª…: %s\nìƒí’ˆ ì •ë³´:\n%s\n\nì˜¤ë¥˜ ì‹œ ë¬¸ì˜ ì£¼ì„¸ìš”.",
		order.Product, cardContent,
	)
	sendTelegram(order.UserID, notifyMsg)

	return nil
}

func sendOrderCompletionNotification(userID int64, product, cardContent string) {
	text := fmt.Sprintf(
		"ğŸ *ìƒí’ˆ ì§€ê¸‰ ì™„ë£Œ!*\n\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"+
			"ğŸ“¦ **ìƒí’ˆëª…**: %s\n"+
			"ğŸ« **ì¹´ë“œì •ë³´**:\n`%s`\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"+
			"âœ… ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n"+
			"ğŸ™ ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.\n\n"+
			"ğŸ’¡ ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ ê³ ê°ì„¼í„°ë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.",
		product, cardContent,
	)
	sendTelegram(userID, text)
}

func validateAdminAccess(userID int64) bool {
	adminUserIDStr := os.Getenv("ADMIN_USER_ID")
	if adminUserIDStr == "" {
		return false
	}

	adminUserID, err := strconv.ParseInt(adminUserIDStr, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID ë³€í™˜ ì‹¤íŒ¨: %v", err)
		return false
	}

	return userID == adminUserID
}

func logAdminAction(userID int64, action string) {
	log.Printf("[ADMIN] User %d performed action: %s", userID, action)
}

func getAllValidProductCodes() []string {
	var codes []string
	for _, products := range cardCategories {
		for _, p := range products {
			codes = append(codes, p.Code)
		}
	}
	return codes
}

// ì•Œë¦¼ ë° ëª¨ë‹ˆí„°ë§ ê¸°ëŠ¥ë“¤
func sendSystemAlert(message string) {
	adminUserID := os.Getenv("ADMIN_USER_ID")
	if adminUserID == "" {
		return
	}

	adminID, err := strconv.ParseInt(adminUserID, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID ë³€í™˜ ì‹¤íŒ¨: %v", err)
		return
	}

	if err := sendTelegram(adminID, "ğŸš¨ ì‹œìŠ¤í…œ ì•Œë¦¼: "+message); err != nil {
		log.Printf("ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ê³ ê¸‰ ì‚¬ìš©ì ê´€ë¦¬ ê¸°ëŠ¥ë“¤
func getUserDetailedInfo(userID int64) (map[string]interface{}, error) {
	info := make(map[string]interface{})

	// ì‚¬ìš©ì ê¸°ë³¸ ì •ë³´
	var user User
	err := db.Where("user_id = ?", userID).First(&user).Error
	if err != nil {
		return nil, err
	}

	// ì£¼ë¬¸ ë‚´ì—­
	orders, err := getUserOrders(userID)
	if err != nil {
		return nil, err
	}

	// ì”ì•¡ ì •ë³´
	balance, err := getUserBalance(userID)
	if err != nil {
		return nil, err
	}

	// ì‚¬ìš©ëœ ì¹´ë“œ
	cards, err := getUsedCards(userID)
	if err != nil {
		return nil, err
	}

	info["user"] = user
	info["orders"] = orders
	info["balance"] = balance
	info["used_cards"] = cards
	info["total_spent"] = calculateTotalSpent(orders)
	info["order_count"] = len(orders)

	return info, nil
}

func calculateTotalSpent(orders []Order) float64 {
	total := 0.0
	for _, order := range orders {
		if order.Status == "ì™„ë£Œ" {
			total += order.Amount
		}
	}
	return total
}

// ê³ ê¸‰ ì¬ê³  ê´€ë¦¬ ê¸°ëŠ¥ë“¤
func getStockAnalytics() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}

	for _, category := range categories {
		var total int64
		var used int64
		var available int64

		// ì´ ì¬ê³ 
		db.Model(&StockCard{}).Where("category = ?", category).Count(&total)
		// ì‚¬ìš©ëœ ì¬ê³ 
		db.Model(&StockCard{}).Where("category = ? AND used = true", category).Count(&used)
		available = total - used

		usageRate := 0.0
		if total > 0 {
			usageRate = float64(used) / float64(total) * 100
		}

		result[category] = map[string]interface{}{
			"total":      total,
			"used":       used,
			"available":  available,
			"usage_rate": usageRate,
		}
	}
	return result, nil
}

func showStockAnalyticsMenu(_ /*uid*/, chatID int64, messageID int) {
	analytics, err := getStockAnalytics()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì¬ê³  ë¶„ì„ ì‹¤íŒ¨")
		bot.Send(msg)
		return
	}

	text := "ğŸ“Š ì¬ê³  ë¶„ì„\n\n"

	categories := []string{"VPS", "MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	for _, category := range categories {
		raw, ok := analytics[category]
		if !ok || raw == nil {
			continue
		}
		data, ok := raw.(map[string]interface{})
		if !ok {
			continue
		}

		text += fmt.Sprintf("%s:\n", category)
		if total, ok := data["total"].(int64); ok {
			text += fmt.Sprintf("  ì´ ì¬ê³ : %dê°œ\n", total)
		}
		if used, ok := data["used"].(int64); ok {
			text += fmt.Sprintf("  ì‚¬ìš©ë¨: %dê°œ\n", used)
		}
		if available, ok := data["available"].(int64); ok {
			text += fmt.Sprintf("  ì‚¬ìš©ê°€ëŠ¥: %dê°œ\n", available)
		}
		if usage, ok := data["usage_rate"].(float64); ok {
			text += fmt.Sprintf("  ì‚¬ìš©ë¥ : %.1f%%\n\n", usage)
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{
				tgbotapi.NewInlineKeyboardButtonData("ì¬ê³  ì¶”ê°€", "admin_add_stock"),
				tgbotapi.NewInlineKeyboardButtonData("ì¬ê³  ì •ë¦¬", "admin_cleanup_stock"),
			},
			{
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
			},
		},
	}

	bot.Send(msg)
}

// ê´€ë¦¬ì ì¬ê³  ì‚­ì œ ë©”ë‰´
func showAdminStockDeleteMenu(uid, chatID int64, msgID int, productID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "ACCOUNT"}

	text := "ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ\n\nì‚­ì œí•  ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n\n"

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	btnCount := 0

	for _, category := range categories {
		stockCount, err := getCardStock(category)
		if err != nil {
			continue
		}

		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s (%dê°œ)", category, stockCount),
			fmt.Sprintf("del_stock_%s", category),
		)
		currentRow = append(currentRow, btn)
		btnCount++

		if btnCount%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}

	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_inventory"),
	))

	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

// ì¹´í…Œê³ ë¦¬ë³„ ì¬ê³  ì‚­ì œ ì²˜ë¦¬
func handleDeleteStockCategory(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "del_stock_")

	// ì‚­ì œ ì „ í™•ì¸ ë©”ì‹œì§€
	stockCount, err := getCardStock(category)
	if err != nil {
		sendTelegram(uid, "âŒ ì¬ê³  ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¡°íšŒ ì‹¤íŒ¨"))
		return
	}

	text := fmt.Sprintf("âš ï¸ ì •ë§ë¡œ %s ì¹´í…Œê³ ë¦¬ì˜ ëª¨ë“  ì¬ê³ (%dê°œ)ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!", category, stockCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœ… ì‚­ì œ í™•ì¸", fmt.Sprintf("confirm_del_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì·¨ì†Œ", "admin_del_stock"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì‚­ì œ í™•ì¸ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ í™•ì¸"))
}

// ì¬ê³  ì‚­ì œ í™•ì¸ ì²˜ë¦¬
func handleConfirmDeleteStock(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "confirm_del_")

	// ì‹¤ì œ ì‚­ì œ ì‹¤í–‰
	var deletedCount int64
	result := db.Where("category = ?", category).Delete(&StockCard{})
	if result.Error != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ì‹¤íŒ¨: %v", result.Error)
		sendTelegram(uid, "âŒ ì¬ê³  ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ ì‹¤íŒ¨"))
		return
	}

	deletedCount = result.RowsAffected

	// ì„±ê³µ ë©”ì‹œì§€
	text := fmt.Sprintf("âœ… %s ì¹´í…Œê³ ë¦¬ì˜ ì¬ê³  %dê°œê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.", category, deletedCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¬ê³ ë©”ë‰´", "admin_inventory"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì‚­ì œ ì™„ë£Œ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ ì™„ë£Œ"))
}
