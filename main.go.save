package main

import (
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/google/uuid"
	"github.com/skip2/go-qrcode"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	db       *gorm.DB
	mu       sync.Mutex
	adminIDs = []int64{6647879650}
	//processedOrders           = map[uint]bool{}
	// processedOrdersMu         sync.Mutex
	mySuperAdminID        int64 = 6647879650
	waitingForImage       map[int64]bool
	verificationAnswers   = make(map[int64]int)
	verifiedUsers         = make(map[int64]bool)
	lastAlertedCategories = make(map[string]time.Time)
	//lastReplyMsgID                  int
	userMessageIDs        = map[int64][]int{}
	pendingSupportQueue   = make(map[int64]time.Time)
	activeSupportSessions = make(map[int64]int64)
	userSelectedProduct   = map[int64]string{}
	//pendingStockImageID             = make(map[int64]string)
	pendingWalletInput              = make(map[int64]bool)
	userLanguages                   = make(map[int64]string)
	pendingStockInput               = make(map[int64]string)
	pendingStockInputBuffer         = make(map[int64]string)
	startTime                       = time.Now()
	selectedCategory                = make(map[int64]string)
	tronGridAPIKey                  = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract               = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
	walletReceiveAddress            = os.Getenv("WALLET_RECEIVE_ADDRESS")
	unmatchedAdminChatID      int64 = 6647879650
	pendingAddProductCategory       = make(map[int64]string)
	processedTxsMu            sync.RWMutex
	adminChatID               int64 = 6647879650
	userReplyKeyboardMsgID          = make(map[int64]int)
	processedTxs                    = make(map[string]bool)
	pendingEditProduct              = map[int64]int{}
	pendingAdminInput               = make(map[int64]bool)
	pendingStockInputNotified       = make(map[int64]bool)
	pendingBroadcastInput           = make(map[int64]bool)
	pendingDepositInput             = make(map[int64]bool)
	pendingDepositAmount            = make(map[int64]float64)
)

var vpsProductMap = map[string]struct {
	Name  string
	Price float64
}{
	"vps1": {"KVM - E1", 70.0},
	"vps2": {"KVM - E2", 90.0},
	"vps3": {"KVM - T1", 120.0},
	"vps4": {"KVM - T2", 150.0},
	"vps5": {"맞춤 제작", 1}, // 가격은 0이거나 별도 처리
}

var productCategories = []string{
	"VPS", "ACCOUNT", "멤버십", "ESIM", "CARD",
}

type UserWallet struct {
	UserID  int64  `gorm:"primaryKey"`
	Address string `gorm:"type:varchar(64);not null;uniqueIndex"`
}

var validGrades = map[string]bool{
	"bronze":  true,
	"silver":  true, // 수정: silvedb.Where("categoryr" → "silver"
	"gold":    true,
	"diamond": true,
	"vip":     true,
}

var bot *tgbotapi.BotAPI

// categoryMap에 VPS 포함 및 ID 맞춤
var categoryMap = map[string]uint{
	"VPS":     1,
	"ESIM":    2,
	"ACCOUNT": 3, // 이 부분이 3이어야 합니다
	"멤버십":     4,
	"CARD":    5,
}

var categoryOrder = []string{
	"VPS",
	"ACCOUNT",
	"멤버십",
	"ESIM",
	"CARD",
}

var productOrder = map[string][]string{
	"VPS":     {"KVM - E1", "KVM - E2", "KVM - T1", "KVM - T2", "맞춤 제작"},
	"ACCOUNT": {"TG 1년", "TG 2년", "짧은 번호"},
	"멤버십":     {"TG 프리미엄 3개월", "TG 프리미엄 1년", "YT 프리미엄 1년"},
	"ESIM":    {"5G DATA", "KOREA|HK", "NO KYC"},
	"CARD":    {"국내결제(HK)", "국외결제", "항공권"},
}

// cardCategories 맵에 VPS 추가
var cardCategories = map[string]map[string]Product{
	"VPS": {
		"KVM - E1": {Code: "vps1", Price: 70, Description: "CPU: 4코어, RAM: 4GB, 저장공간: 100GB NVMe, 가격: 70 USDT"},
		"KVM - E2": {Code: "vps2", Price: 90, Description: "CPU: 4코어, RAM: 6GB, 저장공간: 140GB NVMe, 가격: 90 USDT"},
		"KVM - T1": {Code: "vps3", Price: 120, Description: "CPU: 8코어, RAM: 16GB, 저장공간: 160GB NVMe, 가격: 120 USDT"},
		"KVM - T2": {Code: "vps4", Price: 150, Description: "CPU: 12코어, RAM: 24GB, 저장공간: 256GB NVMe, 가격: 150 USDT"},
		"맞춤 제작":    {Code: "vps5", Price: 1, Description: "맞춤형은 최소 3개월 부터, 문의 후 견적 안내, 원하는 옵션에 맞춰 제작"},
	},
	"ACCOUNT": {
		"TG 1년": {Code: "tgid1", Price: 8},
		"TG 2년": {Code: "tgid2", Price: 20},
		"짧은 번호": {Code: "tgid3", Price: 60},
	},
	"멤버십": {
		"TG 프리미엄 3개월": {Code: "tp3", Price: 17},
		"TG 프리미엄 1년":  {Code: "tp12", Price: 45},
		"YT 프리미엄 1년":  {Code: "yp12", Price: 45},
	},
	"ESIM": {
		"5G DATA":  {Code: "es1", Price: 70},
		"KOREA|HK": {Code: "es2", Price: 999},
		"NO KYC":   {Code: "es3", Price: 999},
	},
	"CARD": {
		"국내결제(HK)": {Code: "card1", Price: 10},
		"국외결제":     {Code: "card2", Price: 10},
		"항공권":      {Code: "card3", Price: 10},
	},
}

// ===== 모델(중복 제거, 모든 테이블/구조체) =====
type StockCard struct {
	ID          uint64 `gorm:"primaryKey"`
	Category    string `gorm:"type:varchar(100);index:idx_category"`
	Name        string `gorm:"type:text"`
	Content     string `gorm:"type:text"`
	Used        bool
	UsedBy      int64
	OrderID     int64
	PhotoFileID string `gorm:"type:text"` // 없으면 추가
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type ProductCategory struct {
	ID           uint `gorm:"primaryKey"`
	Name        string `gorm:"unique"`
	DisplayOrder int
}

type MonitoringWallet struct {
	UserID  int64
	Address string
	// 필요하면 더 추가
}

type dummyDB struct{}

type Category struct {
	ID   uint   `gorm:"primaryKey"`
	Name string `gorm:"unique;not null"` // 카테고리명(예: "계정", "에너지" 등)
}

type Quiz struct {
	Question string
	Answer   int
	Options  []int
}

type TronDeposit struct {
	Amount float64
	TxID   string
	// ... 필요시 추가
}

type ChatConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Result struct {
	Error        error
	RowsAffected int64
}

type User struct {
	ID            uint      `gorm:"primaryKey;autoIncrement"`
	UserID        int64     `gorm:"uniqueIndex"`
	UserName      string    `gorm:"column:user_name"`
	Nickname      string    `gorm:"column:nickname"`
	ChatID        int64     `gorm:"column:chat_id"`
	LastSeen      time.Time `gorm:"column:last_seen"`
	JoinedAt      time.Time `gorm:"column:joined_at"`
	Grade         string    `gorm:"type:varchar(20)"`
	DepositWallet string
}

type Transaction struct {
	TransactionID  string `json:"transaction_id"`
	From           string `json:"from"`
	To             string `json:"to"`
	Value          string `json:"value"`
	BlockTimestamp int64  `json:"block_timestamp"`
	Confirmations  int    `json:"confirmations"`
}

type TronGridResponse struct {
	Data  []Transaction `json:"data"`
	Total int           `json:"total"`
}

type TronTransaction struct {
	TxID      string `json:"transaction_id"`
	From      string `json:"from"`
	To        string `json:"to"`
	AmountStr string `json:"value"` // 소수점 고려 필요 (string 타입으로 받음)
	Timestamp int64  `json:"block_timestamp"`
}

type Deposit struct {
	TxID   string
	Amount float64
	Time   time.Time
}

type ChatInfoConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Order struct {
	ID          uint `gorm:"primaryKey"`
	UserID      int64
	Product     string
	Amount      float64
	Status      string `gorm:"type:varchar(255);index"`
	ExpectedAmt float64
	CardInfo    string  `gorm:"type:text"`
	TxID        *string `gorm:"type:varchar(255);index"`
	Timestamp   time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserBalance struct {
	UserID  int64 `gorm:"primaryKey"`
	Balance float64
}

type Visitor struct {
	UserID   int64          `gorm:"column:user_id"`
	UserName sql.NullString `gorm:"column:user_name"`
	LastSeen time.Time      `gorm:"column:last_seen"`
}

type WalletMap struct {
	ID          uint   `gorm:"primaryKey"`
	UserID      int64  `gorm:"uniqueIndex"`
	Wallet      string `gorm:"size:100"`
	Username    string `gorm:"size:100"`
	ProductName string
	Product     string // 예: Product
	UpdatedAt   time.Time
}

type Wallet struct {
	ID        uint   `gorm:"primaryKey"`
	UserID    int64  `gorm:"index"`
	Address   string `gorm:"size:100;uniqueIndex"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserActivityLog struct {
	UserID     int64     `gorm:"column:user_id"`
	Username   string    `gorm:"column:username"`
	Nickname   string    `gorm:"column:nickname"`
	LastActive time.Time `gorm:"column:last_active"`
}

type Inventory struct {
	ID          uint `gorm:"primaryKey"`
	Category    string
	ProductName string
	Stock       int64
	UpdatedAt   time.Time
}

type SalesStats struct {
	Date       string `gorm:"primaryKey"`
	TotalSales float64
	TotalCount int64
	Count      int64 // 추가
	SalesCount int64 // 추가
}

type Admin struct {
	ID     uint  `gorm:"primaryKey"`
	UserID int64 `gorm:"uniqueIndex"`
}

type Product struct {
	ID          uint    `gorm:"primaryKey"`
	Code        string  `gorm:"unique;not null"`
	Name        string  `gorm:"not null"`
	Price       float64 `gorm:"not null"`
	Description string
	ImageURL    string
	Stock       int
	Active      bool
	Category    string `gorm:"type:varchar(64);index"`
	CategoryID  uint
}

type SimpleProduct struct {
	Code  string
	Price float64
}

type NgrokTunnel struct {
	PublicURL string `json:"public_url"`
}

type NgrokAPIResponse struct {
	Tunnels []struct {
		Name      string `json:"name"`
		PublicURL string `json:"public_url"`
		Proto     string `json:"proto"`
	} `json:"tunnels"`
}

const timeFormat = "2006-01-02 15:04:05"

func init() {
	tronGridAPIKey = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract = os.Getenv("USDT_TRC20_CONTRACT")
	walletReceiveAddress = os.Getenv("WALLET_RECEIVE_ADDRESS")
	if tronGridAPIKey == "" {
		log.Fatal("❌ TRONGRID_API_KEY 환경변수가 설정되지 않았습니다.")
	}
	if usdtTRC20Contract == "" {
		log.Fatal("❌ USDT_TRC20_CONTRACT 환경변수가 설정되지 않았습니다.")
	}
	if walletReceiveAddress == "" {
		log.Fatal("❌ WALLET_RECEIVE_ADDRESS 환경변수가 설정되지 않았습니다.")
	}
}

func getNgrokPublicURL(apiEndpoint string) (string, error) {
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(apiEndpoint)
	if err != nil {
		return "", fmt.Errorf("ngrok API 요청 실패: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("ngrok API 응답 코드 %d", resp.StatusCode)
	}

	var data NgrokAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", fmt.Errorf("ngrok API JSON 디코딩 실패: %w", err)
	}

	for _, tunnel := range data.Tunnels {
		if strings.HasPrefix(tunnel.PublicURL, "https") {
			return tunnel.PublicURL, nil
		}
	}

	return "", fmt.Errorf("ngrok https 터널을 찾을 수 없음")
}

func addVPSProducts() error {
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		return fmt.Errorf("VPS 카테고리 조회 실패: %w", err)
	}

	products := []Product{
		{Code: "vps1", Name: "KVM - E1", Description: "CPU: 4코어, RAM: 4GB, 저장공간: 100GB NVMe, 가격: 70 USDT", Price: 70, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps2", Name: "KVM - E2", Description: "CPU: 4코어, RAM: 6GB, 저장공간: 140GB NVMe, 가격: 90 USDT", Price: 90, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps3", Name: "KVM - T1", Description: "CPU: 8코어, RAM: 16GB, 저장공간: 160GB NVMe, 가격: 120 USDT", Price: 120, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps4", Name: "KVM - T2", Description: "CPU: 12코어, RAM: 24GB, 저장공간: 256GB NVMe, 가격: 150 USDT", Price: 150, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps5", Name: "맞춤 제작", Description: "맞춤형 사양 제공, 문의 후 견적 안내, 안정성과 성능 우선", Price: 0, CategoryID: vpsCategoryID, Active: true},
	}

	// DB에 각 상품 추가
	for _, p := range products {
		var existing Product
		err := db.Where("code = ?", p.Code).First(&existing).Error
		if errors.Is(err, gorm.ErrRecordNotFound) {
			if err := db.Create(&p).Error; err != nil {
				return fmt.Errorf("상품 %s 추가 실패: %w", p.Name, err)
			}
		} else if err != nil {
			return fmt.Errorf("상품 조회 실패: %w", err)
		}
	}

	return nil
}

func initBotWithWebhook() (*tgbotapi.BotAPI, error) {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		return nil, fmt.Errorf("텔레그램 봇 토큰이 설정되지 않았습니다")
	}

	var err error

	bot, err := tgbotapi.NewBotAPI(token)
	if err != nil {
		return nil, fmt.Errorf("텔레그램 봇 생성 실패: %w", err)
	}

	ngrokAPI := "http://127.0.0.1:4040/api/tunnels"
	publicURL, err := getNgrokPublicURL(ngrokAPI)
	if err != nil {
		log.Printf("ngrok URL 조회 실패: %v", err)
		publicURL = os.Getenv("WEBHOOK_URL")
		if publicURL == "" {
			return nil, fmt.Errorf("웹훅 URL을 가져오지 못했습니다")
		}
	}

	webhookURL := fmt.Sprintf("%s/webhook", publicURL)
	log.Printf("웹훅 URL 설정: %s", webhookURL)

	webhook, err := tgbotapi.NewWebhook(webhookURL)
	if err != nil {
		return nil, fmt.Errorf("웹훅 생성 실패: %w", err)
	}

	_, err = bot.Request(webhook)
	if err != nil {
		return nil, fmt.Errorf("웹훅 등록 실패: %w", err)
	}

	log.Println("웹훅 등록 완료")

	return bot, nil
}

func generateAdditionQuiz() Quiz {
	rand.Seed(time.Now().UnixNano())
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b

	options := []int{answer}
	// 오답 2개 생성 (정답과 중복 안되게)
	for len(options) < 3 {
		opt := rand.Intn(19) + 2 // 가능한 합 범위 2~20
		if opt != answer && !contains(options, opt) {
			options = append(options, opt)
		}
	}

	// 옵션 섞기
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	question := fmt.Sprintf("%d + %d = ?", a, b)
	return Quiz{
		Question: question,
		Answer:   answer,
		Options:  options,
	}
}

func contains(arr []int, val int) bool {
	for _, v := range arr {
		if v == val {
			return true
		}
	}
	return false
}

func generateCaptcha() (int, int, int) {
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b
	return a, b, answer
}

func getVPSProductInfo(key string) (string, float64, bool) {
	product, exists := vpsProductMap[key]
	if !exists {
		return "", 0, false
	}
	return product.Name, product.Price, true
}

func sendVerificationChallenge(uid int64, chatID int64) {
	// 문제 생성 (예: 간단한 덧셈)
	a := rand.Intn(10) + 1
	b := rand.Intn(10) + 1
	answer := a + b

	// 유저별 정답 저장 (전역맵 또는 DB에 저장해야 함)
	verificationAnswers[uid] = answer

	msgText := "<b>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</b>\n" +
		"🔒 <b>PRIVATE ACCESS ONLY</b>\n\n" +
		"접근 권한이 없습니다.\n" +
		"아래 문제를 풀어 인증을 하세요.\n\n" +
		fmt.Sprintf("문제: <b>%d + %d = ?</b>\n\n", a, b) +
		"<b>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</b>"

	// 답변 버튼 3개 (정답 포함 랜덤 배치)
	options := generateAnswerOptions(answer)
	var buttons []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		data := fmt.Sprintf("verify_%d", opt)
		buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), data))
	}
	kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(buttons...))

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

func generateAnswerOptions(answer int) []int {
	var options []int
	options = append(options, answer)

	// 정답과 겹치지 않게 두 개의 오답 생성
	for len(options) < 3 {
		delta := rand.Intn(5) + 1 // 1~5 범위
		wrong := answer + delta
		if rand.Intn(2) == 0 {
			wrong = answer - delta
		}
		// 중복 방지
		exists := false
		for _, opt := range options {
			if opt == wrong {
				exists = true
				break
			}
		}
		if !exists && wrong >= 0 {
			options = append(options, wrong)
		}
	}

	// 랜덤 순서로 섞기
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	return options
}

// 인증 콜백 처리 함수
func handleVerificationResponse(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	data := cb.Data

	if !strings.HasPrefix(data, "verify_") {
		return
	}

	// 선택한 답 추출
	selectedStr := strings.TrimPrefix(data, "verify_")
	selected, err := strconv.Atoi(selectedStr)
	if err != nil {
		sendTelegram(uid, "❌ 잘못된 입력입니다.")
		return
	}

	correctAnswer, ok := verificationAnswers[uid]
	if !ok {
		sendTelegram(uid, "❌ 인증 세션이 만료되었거나 존재하지 않습니다. 다시 시도해주세요.")
		return
	}

	if selected == correctAnswer {
		accessMsg := "<b>━━━━━━━━━━━━━━━━</b>\n" +
			"✅ <b>Access Granted</b> ✅\n\n" +
			"🔓 <b>Verification was successful</b>\n" +
			"접근 권한이 허용되었습니다.\n" +
			"<b>━━━━━━━━━━━━━━━━</b>\n"
		sendTelegram(uid, accessMsg)
		markUserVerified(uid)            // 인증 상태 저장
		delete(verificationAnswers, uid) // 인증 문제 삭제

		// 인증 성공 후 메뉴 자동 호출
		showMenu(uid, "", chatID)
	} else {
		failMsg := "<b>━━━━━━━━━━━━━━━━</b>\n" +
			"❌ <b>Verification Failed</b> ❌\n\n" +
			"선택한 답변이 올바르지 않습니다.\n" +
			"아래 문제를 다시 풀어 주세요.\n\n" +
			"지속될 경우 차단 될 수 있습니다.\n" +
			"<b>━━━━━━━━━━━━━━━━</b>\n"
		sendTelegram(uid, failMsg)
		delete(verificationAnswers, uid)
		sendVerificationChallenge(uid, chatID) // 문제 재출제
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "답변 처리됨"))
}

func sendCategoryAlert(category string) {
	now := time.Now()
	lastAlertedCategories[category] = now
	// 알림 처리 코드...
}

func handleProductSelection(uid int64, productCode string) {
	userSelectedProduct[uid] = productCode
	// 이후 주문 확인 메시지 보내기 등 작업 수행
}

func saveStockWithImage(uid int64, inputText, photoFileID string) error {
	lines := strings.Split(strings.TrimSpace(inputText), "\n")
	for _, line := range lines {
		parts := strings.SplitN(line, ":", 3)
		if len(parts) != 3 {
			return fmt.Errorf("잘못된 입력 형식: %s", line)
		}
		category := strings.TrimSpace(parts[0])
		name := strings.TrimSpace(parts[1])
		codes := strings.Split(parts[2], ",")
		for _, code := range codes {
			code = strings.TrimSpace(code)

			// StockCard 구조체로 저장
			stockCard := StockCard{
				Category:    category,
				Name:        name,
				Content:     code,
				Used:        false,
				PhotoFileID: photoFileID,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}

			// StockCard를 DB에 저장
			if err := db.Create(&stockCard).Error; err != nil {
				return err
			}
		}
	}
	return nil
}

func checkTronUSDTDeposits(address string) ([]Transaction, error) {
	apiKey := tronGridAPIKey // 전역변수 또는 환경변수에서 받아오세요
	if apiKey == "" {
		return nil, fmt.Errorf("트론그리드 API 키가 설정되지 않음")
	}

	usdtTRC20Contract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 메인넷 주소

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=20&contract_address=%s", address, usdtTRC20Contract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	client := &http.Client{Timeout: 10 * time.Second}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result TronGridResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

func processDeposits() {
	// 감시할 지갑 주소 (보통 서비스 지갑)
	address := walletReceiveAddress

	txs, err := checkTronUSDTDeposits(address)
	if err != nil {
		log.Printf("트론그리드 입금 내역 조회 실패: %v", err)
		return
	}

	for _, tx := range txs {
		log.Printf("입금 트랜잭션: ID=%s, From=%s, To=%s, Value=%s, Confirmations=%d", tx.TransactionID, tx.From, tx.To, tx.Value, tx.Confirmations)
		// 중복 처리 여부 검사, DB 업데이트 등 추가 구현 필요
	}
}

func (d *dummyDB) Create(value interface{}) *Result {
	log.Printf("[DB] 주문 저장됨: %+v", value) // value를 직접 사용
	return &Result{Error: nil}
}

type dummyResult struct {
	Error error
}

func isValidGrade(grade string) bool {
	return validGrades[strings.ToLower(grade)]
}

func getCardCategoriesFromDB() ([]ProductCategory, error) {
	var categories []ProductCategory
	err := db.Find(&categories).Error
	return categories, err
}

func showCategoryMenu(uid, chatID int64, messageID int) {
	log.Printf("[showCategoryMenu] uid: %d, chatID: %d, messageID: %d", uid, chatID, messageID)

	categories, err := getCardCategoriesFromDB()
	if err != nil || len(categories) == 0 {
		sendTelegram(chatID, "❌ 카테고리 로딩 실패 또는 카테고리 없음")
		log.Printf("[showCategoryMenu] 카테고리 로딩 오류: %v", err)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range categories {
		callbackData := "cardcat_" + cat.Name
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(cat.Name, callbackData),
		))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, "🛒 구매 가능한 상품 카테고리를 선택하세요:")
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showCategoryMenu] 메시지 전송 실패: %v", err)
	}
}

func markUserVerified(uid int64) {
	verifiedUsers[uid] = true
}

func isUserVerified(uid int64) bool {
	return verifiedUsers[uid]
}

func getAllMonitoringWallets() ([]MonitoringWallet, error) {
	// 구현
	return nil, nil
}

func doSomething() error {
	num := 10
	if num > 5 {
		return nil
	}
	return errors.New("처리 안됨")
}

func showAdminMenu(uid, chatID int64, messageID int) {
	// 시스템 상태 정보 가져오기
	status := getStatusReport()

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자 권한이 필요합니다.")
		return
	}

	text := "👑 관리자 님 환영합니다. 👑\n\n" + status

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 상품관리", "admin_inventory"),
			tgbotapi.NewInlineKeyboardButtonData("📆 주간통계", "weekly_stats"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🪪 회원목록", "admin_member_menu"),
			tgbotapi.NewInlineKeyboardButtonData("👥 방문자조회", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📊 통계보기", "admin_stats"),
			tgbotapi.NewInlineKeyboardButtonData("📋 주문내역", "admin_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⚙️ 설정", "showAdminSettings"),
			tgbotapi.NewInlineKeyboardButtonData("🔧 고급관리", "admin_advanced"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 메뉴 수정 실패: %v", err)
	}
}

func getStatusReport() string {
	now := time.Now().Format("2006-01-02 15:04:05")

	// DB 상태는 항상 OK로 가정 (dummy)
	dbOK := true

	// 더미값: 필요시 전역 변수/슬라이스에서 갯수 구하기
	orderCount := int64(1) // 미처리 주문 예시
	cardStock := int64(10) // 남은 재고 예시
	userCount := int64(5)  // 가입자 수 예시

	uptime := time.Since(startTime).Truncate(time.Second).String()

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return fmt.Sprintf(
		"<b>📊 BOT STATUS</b>\n⏰ 서버시간: %s\n🟢 DB상태: %s\n🛒 미처리: %d\n💳 재고: %d\n🙋 가입자: %d\n⏱ 업타임: %s\n💾 메모리: %.2fMB",
		now,
		map[bool]string{true: "OK", false: "오류"}[dbOK],
		orderCount,
		cardStock,
		userCount,
		uptime,
		float64(m.Alloc)/1024/1024,
	)
}

func initDB() {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		os.Getenv("MYSQL_USER"),
		os.Getenv("MYSQL_PASSWORD"),
		os.Getenv("MYSQL_HOST"),
		os.Getenv("MYSQL_PORT"),
		os.Getenv("MYSQL_DB"),
	)

	var err error
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Error), // 에러만 출력
	})
	if err != nil {
		log.Fatalf("DB 연결 실패: %v", err)
	}
	log.Println("✅ DB 연결 성공")

	// 자동 마이그레이션
	if err := db.AutoMigrate(&UserBalance{}, &StockCard{}, &Order{}); err != nil {
		log.Fatalf("❌ DB 마이그레이션 실패: %v", err)
	}
	log.Println("✅ DB 마이그레이션 완료")
}

func getAdminChatID() int64 {
	return adminChatID
}

func handleWebhook(c *gin.Context) {
	var update tgbotapi.Update

	// 1. JSON 바인딩 시도
	if err := c.ShouldBindJSON(&update); err != nil {
		log.Printf("웹훅 JSON 바인딩 실패: %v", err)
		c.JSON(400, gin.H{"status": "bad request"})
		return
	}

	// 2. 바인딩 성공 시 로그 출력 및 처리
	log.Printf("[handleWebhook] update: %+v", update)
	processUpdate(update)

	// 3. 처리 완료 응답
	c.JSON(200, gin.H{"status": "ok"})
}

func handleWalletRegister(chatID, uid int64, addr string) {
	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		sendTelegram(chatID, "유저 정보를 찾을 수 없습니다.")
		return
	}
	user.DepositWallet = addr
	if err := db.Save(&user).Error; err != nil {
		sendTelegram(chatID, "지갑 등록에 실패했습니다.")
	} else {
		sendTelegram(chatID, "입금 지갑이 성공적으로 등록되었습니다!")
	}
}

func setWebhook(bot *tgbotapi.BotAPI, url string) error {
	webhookConfig, err := tgbotapi.NewWebhook(url)
	if err != nil {
		return err
	}
	_, err = bot.Request(webhookConfig)
	return err
}

// 예시: 특정 기간, 특정 카테고리 매출 합계 조회 함수
func getSalesSum(startDate, endDate, category string) (float64, error) {
	var total sql.NullFloat64

	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		startDate, endDate, category+"%",
	).Scan(&total).Error
	if err != nil {
		log.Printf("매출 합계 조회 실패: %v", err)
		return 0, err
	}

	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULL인 경우 0 반환
}

func initBot() {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	var err error
	bot, err = tgbotapi.NewBotAPI(token)
	if err != nil {
		log.Fatalf("❌ 텔레그램 봇 생성 실패: %v", err)
	}
	log.Printf("🤖 봇 시작됨: @%s", bot.Self.UserName)

	webhookURL := os.Getenv("WEBHOOK_URL")
	if webhookURL != "" {
		if err := setWebhook(bot, webhookURL); err != nil {
			log.Fatalf("❌ 웹훅 설정 실패: %v", err)
		}
		log.Printf("✅ 웹훅 설정 완료: %s", webhookURL)
	} else {
		log.Println("⚠️ WEBHOOK_URL 환경변수가 설정되지 않아 웹훅 설정하지 않음")
	}
}

func migrateDB() {
	err := db.AutoMigrate(&UserActivityLog{})
	if err != nil {
		log.Fatalf("DB 마이그레이션 실패: %v", err)
	}
	log.Println("DB 마이그레이션 성공")
}

func processUpdate(update tgbotapi.Update) {
	if update.CallbackQuery != nil {
		handleCallback(update.CallbackQuery) // 기존 handleCallbackQuery 대신 handleCallback 호출
	} else if update.Message != nil {
		handleMessage(update.Message)
	} else {
		log.Printf("처리하지 않는 업데이트 타입: %+v", update)
	}
}

func showProductMenu(category string, chatID int64, messageID int) {
	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	// 고정 상품 순서대로 버튼 생성
	for _, pname := range productOrder[category] {
		product, ok := cardCategories[category][pname]
		if !ok {
			continue // 상품명이 실제 데이터에 없으면 건너뜀
		}
		btn := tgbotapi.NewInlineKeyboardButtonData(
			pname,
			"prod_"+product.Code,
		)
		currentRow = append(currentRow, btn)
		count++
		if count%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_catmenu"),
	))

	msgText := "<b>상품을 선택하세요.</b>"

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
}

func addUserBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", userID).Error
	if err != nil { // 잔액 기록 없으면 신규 생성
		balance = UserBalance{
			UserID:  userID,
			Balance: amount,
		}
		return db.Create(&balance).Error
	}
	balance.Balance += amount
	return db.Save(&balance).Error
}

func sendReplyKeyboard(uid, chatID int64) error {
	// 이전 리플라이 키보드 메시지 삭제 (있으면)
	if msgID, ok := userReplyKeyboardMsgID[uid]; ok && msgID != 0 {
		delMsg := tgbotapi.DeleteMessageConfig{
			ChatID:    chatID,
			MessageID: msgID,
		}
		if _, err := bot.Request(delMsg); err != nil {
			log.Printf("리플라이 키보드 이전 메시지 삭제 실패: %v", err)
		}
	}

	// 새 리플라이 키보드 메시지 전송
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("내 정보"),
			tgbotapi.NewKeyboardButton("에너지"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("주문내역"),
			tgbotapi.NewKeyboardButton("고객센터"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	msg := tgbotapi.NewMessage(chatID, " ") // 빈 텍스트
	msg.ReplyMarkup = replyKeyboard

	sentMsg, err := bot.Send(msg)
	if err != nil {
		return err
	}

	userReplyKeyboardMsgID[uid] = sentMsg.MessageID
	return nil
}

func showMenu(uid int64, username string, chatID int64) {
	if username == "" {
		username = "unknown"
	}

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	isAdminUser := isAdmin(uid)

	introMsg := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🆔 <b>고유번호</b> : <code>%d</code>\n"+
			"👤 <b>유저네임</b> : %s\n"+
			"⏰  : <code>%s</code>\n"+
			"등급 : %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n",
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	if isAdminUser {
		introMsg += "\n<b>권한: 관리자</b>\n"
	}

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdminUser {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("👑 관리자메뉴", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("showMenu 인트로 메시지 전송 실패: %v", err)
	}

	if err := sendReplyKeyboard(uid, chatID); err != nil {
		log.Printf("showMenu 리플라이 키보드 전송 실패: %v", err)
	}
}

func handleCategorySelect(uid int64, cat string, chatID int64, msgID int) {
	selectedCategory[uid] = cat // 이 유저의 현재 카테고리 선택 저장

	// "카테고리별 상품목록" 메뉴 보여주기
	showProductListMenuByCategory(chatID, msgID, cat)
}

func handleStart(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	username := msg.From.UserName

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	introMsg := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🆔 <b>고유번호</b> : <code>%d</code>\n"+
			"👤 <b>유저네임</b> : %s\n"+
			"⏰  : <code>%s</code>\n"+
			"등급 : %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n",
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	isAdminUser := isAdmin(uid)

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdminUser {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("👑 관리자메뉴", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("상품목록", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("가상서버", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("코인스왑", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("❓ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("🌐 LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	// 1. 인트로 메시지 + 인라인 키보드 전송
	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("인트로 메시지 전송 실패: %v", err)
		return
	}

	// 2. 리플라이 키보드 전송 (빈 텍스트)
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("내 정보"),
			tgbotapi.NewKeyboardButton("에너지"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("주문내역"),
			tgbotapi.NewKeyboardButton("고객센터"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	replyMsg := tgbotapi.NewMessage(chatID, "PING 🛜") // 빈 문자열로 텍스트 없이 키보드만 표시
	replyMsg.ReplyMarkup = replyKeyboard
	if _, err := bot.Send(replyMsg); err != nil {
		log.Printf("리플라이 키보드 메시지 전송 실패: %v", err)
	}
}

// 잔액 조회 함수
func handleBalanceCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	var userBal UserBalance
	err := db.Where("user_id = ?", uid).First(&userBal).Error
	balance := 0.0
	if err == nil {
		balance = userBal.Balance
	}
	reply := fmt.Sprintf(
		"👤 : <code>%d</code>\n\n💰 잔액 : %.3f USDT\n\n입금은 /입금 안내 메뉴를 참고하세요.",
		uid, balance,
	)
	sendTelegram(uid, reply)
}

// 관리자 여부 판단 함수
func isAdmin(userID int64) bool {
	// 관리자 ID 목록
	adminIDs := []int64{
		mySuperAdminID, // 슈퍼 관리자
		// 다른 관리자 ID 추가 가능
	}

	// 관리자 ID 목록에 userID가 있는지 확인
	for _, id := range adminIDs {
		if userID == id {
			return true
		}
	}

	return false
}

func saveUserToDB(uid int64, username string, chatID int64) error {
	var user User
	result := db.Where("user_id = ?", uid).First(&user)
	if errors.Is(result.Error, gorm.ErrRecordNotFound) {
		user = User{
			UserID:   uid,
			UserName: username,
			ChatID:   chatID,
			Grade:    "bronze",
			JoinedAt: time.Now(),
			LastSeen: time.Now(),
		}
		return db.Create(&user).Error
	} else if result.Error != nil {
		return result.Error
	}
	user.UserName = username
	user.ChatID = chatID
	user.LastSeen = time.Now()
	return db.Save(&user).Error
}

func convertUsersToActivityLogs(users []User) []UserActivityLog {
	logs := make([]UserActivityLog, len(users))
	for i, u := range users {
		logs[i] = UserActivityLog{
			UserID:     u.UserID,
			Username:   u.UserName,
			Nickname:   u.Nickname,
			LastActive: u.LastSeen,
		}
	}
	return logs
}

// 상품 목록 (카테고리별, 예시)
func showProductList(chatID int64, messageID int, category string, callbackID string) {
	products, ok := cardCategories[category]
	if !ok {
		sendTelegram(chatID, "❌ 존재하지 않는 카테고리입니다.")
		return
	}
	rows := [][]tgbotapi.InlineKeyboardButton{}
	for _, prod := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s - %.3f USDT", prod.Name, prod.Price),
			"prod_"+prod.Code,
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙 ", "menu_products")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))
	edit := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("📦 %s 상품 목록", strings.Title(category)))
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
	bot.Request(tgbotapi.NewCallback(callbackID, "상품 목록 표시"))
}

func sendOrEditMessage(chatID int64, messageID int, text string, markup interface{}) {
	if messageID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		if kb, ok := markup.(tgbotapi.InlineKeyboardMarkup); ok {
			msg.ReplyMarkup = kb
		}
		bot.Send(msg)
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
		edit.ParseMode = "HTML"
		if kb, ok := markup.(tgbotapi.InlineKeyboardMarkup); ok {
			edit.ReplyMarkup = &kb
		} else {
			edit.ReplyMarkup = nil
		}
		bot.Send(edit)
	}
}

func RoundFloat(val float64, precision int) float64 {
	ratio := math.Pow(10, float64(precision))
	return math.Round(val*ratio) / ratio
}

func showVPSMenu(uid, chatID int64, messageID int) {
	// 1. 'VPS' 카테고리 ID 가져오기
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		sendTelegram(uid, "❌ VPS 카테고리를 찾을 수 없습니다.")
		return
	}

	// 2. 해당 카테고리의 활성 상품 리스트 조회
	var products []Product
	err = db.Where("category_id = ? AND active = 1", vpsCategoryID).Find(&products).Error
	if err != nil || len(products) == 0 {
		sendTelegram(uid, "❌ VPS 상품이 없습니다.")
		return
	}

	// 3. 버튼 행 배열 생성 (2개씩 배치)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(products); i += 2 {
		if i+1 < len(products) {
			row := tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(products[i].Name, fmt.Sprintf("prod_%d", products[i].ID)),
				tgbotapi.NewInlineKeyboardButtonData(products[i+1].Name, fmt.Sprintf("prod_%d", products[i+1].ID)),
			)
			rows = append(rows, row)
		} else {
			// 마지막에 홀수개인 경우 한 개만 버튼 생성
			row := tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(products[i].Name, fmt.Sprintf("prod_%d", products[i].ID)),
			)
			rows = append(rows, row)
		}
	}

	// 4. 뒤로가기 버튼 추가
	backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙 메뉴로 가기", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	// 5. 메시지 편집 및 전송
	edit := tgbotapi.NewEditMessageText(chatID, messageID, "🖥️ VPS|가상서버 목록\n\n원하는 사양을 선택하세요.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showVPSMenu 메시지 편집 실패: %v", err)
	}
}

func showLanguageMenu(uid, chatID, messageID int64) {
	text := "🌐 언어를 선택하세요 / Select Language"
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🇰🇷", "lang_ko"),
			tgbotapi.NewInlineKeyboardButtonData("🇺🇸", "lang_en"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🇨🇳", "lang_zh"),
			tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main"),
		),
	)

	if messageID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("showLanguageMenu 메시지 전송 실패: %v", err)
		}
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, int(messageID), text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showLanguageMenu 메시지 편집 실패: %v", err)
		}
	}
}

func handleLanguageSelection(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID

	var selectedLang string

	switch cb.Data {
	case "lang_ko":
		selectedLang = "ko"
	case "lang_en":
		selectedLang = "en"
	case "lang_zh":
		selectedLang = "zh"
	case "go_main":
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
		return
	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "알 수 없는 명령어입니다."))
		return
	}

	// 언어 저장 함수 호출
	setUserLanguage(uid, selectedLang)

	// 응답 및 메뉴 다시 표시
	bot.Request(tgbotapi.NewCallback(cb.ID, "🌐 언어가 설정되었습니다."))
	showMenu(uid, cb.From.UserName, chatID)
}

func setUserLanguage(userID int64, lang string) {
	userLanguages[userID] = lang
}

func someCallbackHandler(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "수정된 메시지 내용입니다.")
	if _, err := bot.Send(edit); err != nil {
		log.Printf("메시지 편집 실패: %v", err)
	}
}

func setUserLang(uid int64, lang string) error {
	// 예시: 유저 테이블이 있고 lang 필드가 있다면
	err := db.Model(&User{}).Where("id = ?", uid).Update("lang", lang).Error
	return err
}

func showSupportMenu(uid, chatID, messageID int64) {
	msgText := " 👤 고객센터 메뉴입니다.\n\n 문의 버튼을 누른후 대기 해주세요."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("실시간 문의", "support_request"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main"),
		),
	)

	photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.ch.jpeg"))
	photo.Caption = msgText
	photo.ReplyMarkup = kb

	if _, err := bot.Send(photo); err != nil {
		log.Printf("고객센터 메뉴(이미지) 전송 실패: %v", err)
	}
}

func getUserWallet(uid int64) string {
	var wallet UserWallet
	if err := db.Where("uid = ?", uid).First(&wallet).Error; err != nil {
		log.Printf("[지갑조회] uid: %d → 조회 실패: %v", uid, err)
		return ""
	}
	log.Printf("[지갑조회] uid: %d → 지갑주소: %s", uid, wallet.Address)
	return wallet.Address
}

func updateWalletUsername(uid int64, username string) {
	var wm WalletMap
	if err := db.Where("user_id = ?", uid).First(&wm).Error; err == nil {
		if wm.Username != username && username != "" {
			wm.Username = username
			db.Save(&wm)
		}
	}
}

func isDepositProcessed(txID string) bool {
	processedTxsMu.RLock()
	defer processedTxsMu.RUnlock()
	return processedTxs[txID]
}

func markDepositProcessed(txID string) {
	processedTxsMu.Lock()
	defer processedTxsMu.Unlock()
	processedTxs[txID] = true
}

func callTronGridAPI() {
	// 트론그리드 API 호출 함수 실제 구현 필요
}

func handleUserActivityCommand(uid, chatID int64, page int) {
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
		return
	}

	const pageSize = 10
	offset := (page - 1) * pageSize
	var logs []UserActivityLog
	if err := db.Order("timestamp DESC").Offset(offset).Limit(pageSize).Find(&logs).Error; err != nil {
		sendTelegram(uid, "방문자 목록 조회 중 오류가 발생했습니다.")
		return
	}
	if len(logs) == 0 {
		sendTelegram(uid, "방문자 목록이 없습니다.")
		return
	}

	var total int64
	if err := db.Model(&UserActivityLog{}).Count(&total).Error; err != nil {
		sendTelegram(uid, "총 방문자 수 조회 중 오류가 발생했습니다.")
		return
	}

	totalPages := int((total + pageSize - 1) / pageSize)
	msgText := formatUserActivitiesMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	if _, err := bot.Send(msg); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

// 방문자 기본 정보 리스트 조회 (User 타입)
func getUserListByPage(page int, pageSize int) ([]User, error) {
	offset := (page - 1) * pageSize
	var users []User
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

func formatUserListMessage(users []User, page, totalPages int) string {
	const pageSize = 10
	if len(users) == 0 {
		return "<b>조회 결과가 없습니다.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(없음)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}
		lastSeen := "(알 수 없음)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\n최근 접속: %s\n━━━━━━━━━━━━━━\n",
			(i+1)+(page-1)*pageSize, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

func showUserListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, err := getUserListByPage(page, 10)
	if err != nil {
		sendTelegram(uid, "❌ 방문자 목록을 불러오는 중 오류가 발생했습니다.")
		return
	}
	var total int64
	err = db.Model(&User{}).Count(&total).Error
	if err != nil {
		// 에러 처리
		return // 또는 적절한 반환
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

func formatUserActivityListMessage(logs []UserActivityLog, page, totalPages int) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 최근 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	if len(logs) == 0 {
		sb.WriteString("조회 결과가 없습니다.\n")
		return sb.String()
	}
	for _, act := range logs {
		lastActive := "(없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(없음)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}

		sb.WriteString(fmt.Sprintf(
			"• 사용자ID: %d / @%s / 닉네임: %s\n  최근활동: %s\n━━━━━━━━━━━━━━\n",
			act.UserID, username, nickname, lastActive,
		))
	}
	return sb.String()
}

func showUserActivityListPage(cb *tgbotapi.CallbackQuery, page int) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	const pageSize = 10

	logs, total, err := getUserActivityListByPage(page, pageSize)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "방문자 목록 조회 실패"))
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserActivityListMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("페이지 %d 로 이동", page)))
}

// 활동 로그 기반 방문자 리스트 조회 (UserActivityLog 타입)
func getUserActivityListByPage(page, pageSize int) ([]UserActivityLog, int64, error) {
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&UserActivityLog{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	var logs []UserActivityLog
	err := db.Order("timestamp DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&logs).Error

	return logs, total, err
}

// 방문자 페이지 전환 콜백 처리 함수
func handleVisitorPageCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	pageStr := strings.TrimPrefix(cb.Data, "visitors_page_")
	page, err := strconv.Atoi(pageStr)
	if err != nil || page < 1 {
		bot.Request(tgbotapi.NewCallback(cb.ID, "잘못된 페이지 번호입니다."))
		return
	}

	totalPages, err := getUserActivityTotalPages(10)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "페이지 계산 실패"))
		return
	}

	visitors, err := getUserActivities(page, 10)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "방문자 목록 조회 실패"))
		return
	}

	var logs []UserActivityLog
	for _, u := range visitors {
		logs = append(logs, UserActivityLog{
			UserID:     u.UserID,
			Username:   u.UserName,
			Nickname:   u.Nickname,
			LastActive: u.LastSeen,
		})
	}

	msgText := formatUserActivitiesMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("페이지 %d 로 이동", page)))
}

// 사용자 활동 로그 조회 및 페이징
func getUserActivities(page, pageSize int) ([]User, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

// 사용자 활동 총 페이지 수 계산
// 총 방문자 수 기반 총 페이지 계산
func getUserActivityTotalPages(pageSize int) (int, error) {
	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return 0, err
	}
	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	return totalPages, nil
}

func getCategoryIDByName(name string) (uint, error) {
	var cat Category
	err := db.Where("name = ?", name).First(&cat).Error
	if err != nil {
		return 0, err
	}
	return cat.ID, nil
}

func getGradeEmoji(grade string) string {
	switch grade {
	case "bronze":
		return "🥉"
	case "silver":
		return "🥈"
	case "gold":
		return "🥇"
	case "diamond":
		return "💎"
	case "vip":
		return "👑"
	case "":
		return "❔" // 등급이 빈 문자열인 경우
	default:
		return "🥉"
	}
}

func updateUserLastSeen(user *tgbotapi.User) {
	err := db.Exec(`
		INSERT INTO users (user_id, username, nickname, last_seen)
		VALUES (?, ?, ?, NOW())
		ON DUPLICATE KEY UPDATE
			username = VALUES(username),
			nickname = VALUES(nickname),
			last_seen = NOW()
	`, user.ID, user.UserName, user.FirstName).Error

	if err != nil {
		log.Printf("updateUserLastSeen 에러: %v", err)
	}
}

// showEnergyMenu 함수 수정본
func showEnergyMenu(uid int64, chatID int64, messageID int) {
	msgText := `<b>🪫 USDT 송금 수수료 80% 절감</b>

65K 에너지=<b>2.5TRX</b> (전송 1회) 
예:<b>10TRX</b> = 260K 에너지 (3~4회)

⏱ 전송후 10초 이내 에너지 할당

⬇️ <b>결제 주소</b> ⬇️
<b>━━━━━━━━━━━━━━━━</b>
<code>TDFfED6MK7hj6a9GXJMG3emXdd3b6XtHPn</code>
<b>━━━━━━━━━━━━━━━━</b>
⬆️<b> 주소 클릭 시 자동 복사</b> ⬆️

⏳ 에너지는 1시간 후 자동 소멸
⚠️ USDT 없는 새 지갑으로 송금 
130K 에너지 (5 TRX) 필요하니
송금 전 수수료 확인 필수

<b>주소 변경시 봇이 자동알람</b>

🚨 
판매자가 불분명한 시간짧은 
에너지는 사용X 10분 에너지는 시간이
촉박해 주소를 복사하여 전송하는 
코인 특성상 오송금이 자주일어나는데 
피해복구 불가 판매처 꼭 확인후 구매
해외에선 오송금 으로 마진을 봅니다.
지갑 주소록에 주소를 저장하세요.`

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageCaption(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showEnergyMenu 메시지 편집 실패: %v, 새 메시지로 대체 전송 시도", err)
			// 편집 실패 시 새 메시지 전송
			photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.trx.jpeg"))
			photoMsg.Caption = msgText
			photoMsg.ParseMode = "HTML"
			photoMsg.ReplyMarkup = kb
			if _, err := bot.Send(photoMsg); err != nil {
				log.Printf("showEnergyMenu 사진+메시지 전송 실패: %v", err)
			}
		}
	} else {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("/home/minho/epusdt/images/energy_image.jpeg"))
		photoMsg.Caption = msgText
		photoMsg.ParseMode = "HTML"
		photoMsg.ReplyMarkup = kb

		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("showEnergyMenu 사진+메시지 전송 실패: %v", err)
		}
	}
}

func getUserDisplayName(uid int64) string {
	var user User
	if err := db.First(&user, "user_id = ?", uid).Error; err == nil {
		if user.UserName != "" {
			return user.UserName
		}
		return user.Nickname
	}
	return "unknown"
}

func generateWalletAddress() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return fmt.Sprintf("T%x", bytes), nil
}

func showBalanceMenu(uid int64, chatID int64, messageID int) {
	username := getUserDisplayName(uid)
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", uid).Error
	if err != nil {
		log.Printf("사용자 잔액 조회 실패: %v", err)
		balance.Balance = 0.0
		balance.UserID = uid
	}

	// 👇 등급 이모지 불러오기 추가!
	gradeEmoji := "❔"
	var user User
	if err := db.Where("user_id = ?", uid).First(&user).Error; err == nil {
		gradeEmoji = getGradeEmoji(user.Grade)
	}

	msgText := fmt.Sprintf(
		"🪪내 정보\n"+
			"🆔 고유번호: <code>%d</code>\n"+
			"👤 유저네임: <b>%s</b>\n"+
			"🕒: <b>%s</b>\n"+
			"등급: %s\n\n"+
			"🏦: <b>%.3f USDT</b>",
		uid, username, time.Now().Format("2006-01-02 15:04"), gradeEmoji, balance.Balance,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("💲 잔액충전", "show_deposit_menu"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🧾 주문내역", "handle_show_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("잔액 메뉴 수정 실패: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("잔액 메뉴 전송 실패: %v", err)
		}
	}
}

func sendDepositMenuNewMessage(uid int64) {
	text := "<b>충전 금액을 선택하세요</b>\n\n" +
		"원하는 금액 버튼을 누르거나, 아래에 직접 USDT 금액을 입력해 주세요."

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("10 USDT", "deposit_amount_10"),
			tgbotapi.NewInlineKeyboardButtonData("50 USDT", "deposit_amount_50"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("100 USDT", "deposit_amount_100"),
			tgbotapi.NewInlineKeyboardButtonData("직접 입력", "deposit_custom"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "balance_menu"),
		),
	)

	msg := tgbotapi.NewMessage(uid, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

/*
	func handlePhotoMessage(msg *tgbotapi.Message) {
		uid := int64(msg.From.ID)

		mu.Lock()
		waiting := waitingForImage[uid]
		mu.Unlock()

		if !waiting {
			sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
			return
		}

		photos := msg.Photo
		if len(photos) == 0 {
			sendTelegram(uid, "❗️ 사진 정보가 없습니다. 다시 시도해 주세요.")
			return
		}
		photo := photos[len(photos)-1]

		mu.Lock()
		pendingStockImageID[uid] = photo.FileID
		waitingForImage[uid] = false
		mu.Unlock()

		mu.Lock()
		stockInput := pendingStockInputBuffer[uid]
		mu.Unlock()

		err := saveStockWithImage(uid, stockInput, photo.FileID)
		if err != nil {
			log.Printf("재고 저장 실패 uid=%d err=%v", uid, err)
			sendTelegram(uid, "❌ 재고 등록 중 오류가 발생했습니다.")
			return
		}

		sendTelegram(uid, "✅ 재고가 사진과 함께 성공적으로 등록되었습니다.")

		mu.Lock()
		delete(pendingStockInputBuffer, uid)
		delete(pendingStockImageID, uid)
		mu.Unlock()
	}
*/
func saveUserWallet(userID int64, wallet, username string) error {
	var wm WalletMap
	err := db.Where("user_id = ?", userID).First(&wm).Error
	if err == nil {
		wm.Wallet = wallet
		wm.Username = username
		if err := db.Save(&wm).Error; err != nil {
			log.Printf("saveUserWallet: DB 저장 실패 userID=%d, err=%v", userID, err)
			return err
		}
		return nil
	}
	if errors.Is(err, gorm.ErrRecordNotFound) {
		wm = WalletMap{
			UserID:   userID,
			Wallet:   wallet,
			Username: username,
		}
		if err := db.Create(&wm).Error; err != nil {
			log.Printf("saveUserWallet: DB 생성 실패 userID=%d, err=%v", userID, err)
			return err
		}
		return nil
	}
	log.Printf("saveUserWallet: DB 조회 실패 userID=%d, err=%v", userID, err)
	return err
}

func handleOrder(productCode string, uid, chatID, messageID int64) error {
	var prodName string
	var price float64
	found := false
	for _, prods := range cardCategories {
		for name, prod := range prods {
			if prod.Code == productCode {
				prodName = name
				price = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}

	if !found {
		sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
		return fmt.Errorf("상품 정보 없음")
	}

	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "입금대기중",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        nil, // NULL로 설정
	}
	if err := db.Create(&order).Error; err != nil {
		sendTelegram(uid, "❌ 주문 생성 중 오류가 발생했습니다.")
		log.Printf("handleOrder: 주문 생성 실패 userID=%d, err=%v", uid, err)
		return fmt.Errorf("주문 생성 실패: %w", err)
	}

	uniqueAmt := price + float64(order.ID)/1000.0 // newOrder → order
	uniqueAmt = math.Floor(uniqueAmt*1000) / 1000

	if err := db.Model(&order).Update("expected_amt", uniqueAmt).Error; err != nil { // newOrder → order
		log.Printf("handleOrder: ExpectedAmt 업데이트 실패 orderID=%d, err=%v", order.ID, err)
	}

	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		coinAddr = "TRON-USDT-입금주소"
	}
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID) // newOrder → order
	if err := generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", coinAddr, uniqueAmt), qrPath); err != nil {
		log.Printf("QR 코드 생성 실패: %v", err)
	}

	msgText := fmt.Sprintf(
		"🛒 <b>주문 접수 완료</b>\n\n"+
			"• 주문번호: <code>%d</code>\n 상품명: <b>%s</b>\n 결제금액: <b>%.3f USDT</b>\n\n"+
			"(소수점까지 정확하게, QR 코드 활용 권장)\n20분 내 미입금시 자동취소 됩니다.",
		order.ID, prodName, uniqueAmt, // newOrder → order
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("❌ 주문취소", fmt.Sprintf("cancel_order_%d", order.ID)), // newOrder → order
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("handleOrder: 결제 안내 메시지 전송 실패 userID=%d, err=%v", uid, err)
	} else {
		userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)
	}

	if qrPath != "" {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photoMsg.Caption = fmt.Sprintf(
			"아래 주소로 <b>정확한 금액</b>을 입금해 주세요.\n<b>━━━━━━━━━━━━━━━━</b>\n<code>%s</code>\n<b>━━━━━━━━━━━━━━━━</b>\n주소 클릭시 복사 됩니다.",
			coinAddr,
		)
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("handleOrder: QR 코드 이미지 전송 실패 userID=%d, err=%v", uid, err)
		}
	}

	go func(orderID uint, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "입금대기중" {
			ord.Status = "자동취소"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("handleOrder: 주문 자동취소 저장 실패 orderID=%d, err=%v", orderID, err)
				return
			}
			sendTelegram(userID, fmt.Sprintf("❌ 주문 #%d 20분 내 미입금으로 자동취소되었습니다.", orderID))
		}
	}(order.ID, uid) // newOrder → order

	return nil
}

func createOrderAndUpdateBalance(userID int64, prodName string, price float64, txID string) error {
	return db.Transaction(func(tx *gorm.DB) error {
		txIDPtr := &txID // string 포인터 생성

		order := Order{
			UserID:      userID,
			Product:     prodName,
			Amount:      price,
			Status:      "입금대기중",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
			TxID:        txIDPtr,
		}
		if err := tx.Create(&order).Error; err != nil {
			return err
		}

		if err := tx.Model(&UserBalance{}).Where("user_id = ?", userID).
			Update("balance", gorm.Expr("balance + ?", price)).Error; err != nil {
			return err
		}
		return nil
	})
}

func showDepositConfirm(uid, chatID int64, messageID int, amount float64) {
	amountStr := fmt.Sprintf("%.3f", amount)
	encodedAmount := base64.StdEncoding.EncodeToString([]byte(amountStr))
	callbackData := "confirm_deposit_" + encodedAmount

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✅ 확인", callbackData),
			tgbotapi.NewInlineKeyboardButtonData("🔙 ", "show_deposit_menu"),
		),
	)
	text := fmt.Sprintf("💸 <b>%.3f USDT</b> 충전하시겠습니까?", amount)
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("메시지 전송 실패: %v", err)
	}
}

// 입금 주소 및 QR코드 안내
func showDepositAddress(uid, chatID int64, messageID int, amount float64) {
	addr, err := getWalletAddress(uid)
	if err != nil || addr == "" {
		sendTelegram(chatID, "❗️ 입금 지갑이 등록되어 있지 않습니다.\n\n먼저 <b>/입금지갑등록 [지갑주소]</b> 명령어로 등록해 주세요.")
		return
	}

	var username string
	if err := db.Model(&User{}).Select("username").Where("user_id = ?", uid).Take(&username).Error; err != nil {
		username = "-"
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf(
			"🆔 <b>고유번호</b>: <code>%d</code>\n"+
				"👤 <b>유저네임</b>: %s\n\n"+
				"💲 <b>입금 안내</b>\n"+
				"입금 주소: <code>%s</code>\n"+
				"입금 금액: <b>%.3f USDT</b>\n\n"+
				"입금 완료 후, 자동으로 잔액이 충전됩니다.",
			uid, username, addr, amount,
		),
	)
	editMsg.ParseMode = "HTML"

	if _, err = bot.Send(editMsg); err != nil {
		log.Printf("메시지 편집 실패: %v", err)
	}

	qrFilename := fmt.Sprintf("./qrcodes/wallet_%d_%d.png", uid, time.Now().UnixNano())
	qrData := fmt.Sprintf("%s?amount=%.3f", addr, amount)

	if err := generateWalletQRCode(qrData, qrFilename); err == nil {
		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrFilename))
		photo.Caption = fmt.Sprintf(
			"💳 <b>입금주소 QR</b> (%.3f USDT)\n\n<code>%s</code>",
			amount, addr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("showDepositAddress: QR코드 이미지 전송 실패 chatID=%d err=%v", chatID, err)
		}
	} else {
		log.Printf("showDepositAddress: QR 생성 실패 err=%v", err)
	}
}

// 관리자 재고 상세 목록 표시 함수 예시
func showAdminStockList(chatID int64, messageID int) {
	// TODO: DB에서 재고 목록 조회 후 텔레그램 메시지 또는 메시지 편집으로 출력
	msgText := "📋 재고 상세 목록 (예시)\n- 상품A: 10개\n- 상품B: 5개\n- 상품C: 0개\n"
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("재고 상세 목록 출력 실패: %v", err)
	}
}

// 관리자 재고 삭제 안내 함수 예시
func promptStockDeletion(chatID int64) {
	msgText := "🗑️ 재고 삭제 기능을 사용합니다.\n삭제할 재고 항목 코드를 입력해 주세요."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("재고 삭제 안내 메시지 전송 실패: %v", err)
	}
}

// 관리자 재고 추가 안내 함수 예시
func promptStockAddition(chatID int64) {
	msgText := "➕ 재고 추가 기능을 사용합니다.\n추가할 재고 항목 정보를 입력해 주세요."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("재고 추가 안내 메시지 전송 실패: %v", err)
	}
}

// 관리자 메인 메뉴 함수 예시
func showAdminMainMenu(chatID int64, messageID int) {
	msgText := "👑 관리자 메인 메뉴입니다."
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 메인 메뉴 출력 실패: %v", err)
	}
}

// 관리자 재고 메뉴 표시
func showAdminStockMenuSimple(chatID int64, messageID int) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		{tgbotapi.NewInlineKeyboardButtonData("📋 상세 보기", "admin_stock_list")},
		{tgbotapi.NewInlineKeyboardButtonData("🗑️ 재고 삭제", "admin_stock_delete")},
		{tgbotapi.NewInlineKeyboardButtonData("➕ 재고 추가", "admin_stock")},
		{tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu")},
	}

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, "관리자님 환영합니다.")
		edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
		if _, err := bot.Send(edit); err != nil {
			log.Printf("관리자 재고 메뉴 수정 실패: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, "관리자님 환영합니다.")
		msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(rows...)
		if _, err := bot.Send(msg); err != nil {
			log.Printf("메시지 전송 실패: %v", err)
		}
	}
}

func showAdminSettings(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("관리자 추가", "admin_add"),
			tgbotapi.NewInlineKeyboardButtonData("전체공지", "admin_notice"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "환경설정 ⚙️")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 수정 메뉴 실패: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "메뉴 수정 실패")); callbackErr != nil {
			log.Printf("Callback 응답 실패: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback 응답 실패: %v", err)
	}
}

func showAdminVisitorMenu(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📅 당일 방문자", "admin_list_visitors_today"),
			tgbotapi.NewInlineKeyboardButtonData("📆 전체 방문자", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "👥 방문자 조회 메뉴")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 메뉴 수정 실패: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "메뉴 수정 실패")); callbackErr != nil {
			log.Printf("Callback 응답 실패: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback 응답 실패: %v", err)
	}
}

// 통계 데이터 조회 (새로운 버전)
func getDailyStatsNew() (SalesStats, error) {
	today := time.Now().Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func handleListStockCommand(msg *tgbotapi.Message) {
	// 관리자용 재고 목록 출력 (간단 예시)
	sendTelegram(int64(msg.From.ID), "📦 재고 목록을 조회합니다.")
}

func handleAddAdminCommand(msg *tgbotapi.Message) {
	// 관리자 추가 처리 (예시)
	sendTelegram(int64(msg.From.ID), "👤 관리자 추가 기능은 준비 중입니다.")
}

func handleCancelOrderCommand(msg *tgbotapi.Message) {
	// 주문 취소 처리 (예시)
	sendTelegram(int64(msg.From.ID), "❌ 주문 취소 기능은 준비 중입니다.")
}

func formatUserActivitiesMessage(activities []UserActivityLog, page, totalPages int) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 최근 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	if len(activities) == 0 {
		sb.WriteString("조회 결과가 없습니다.\n")
		return sb.String()
	}
	for _, act := range activities {
		lastActive := "(없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(없음)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}

		sb.WriteString(fmt.Sprintf(
			"• 사용자ID: %d / @%s / 닉네임: %s\n  최근활동: %s\n━━━━━━━━━━━━━━\n",
			act.UserID, username, nickname, lastActive,
		))
	}
	return sb.String()
}

func createUserActivityKeyboard(page, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	var topButtons []tgbotapi.InlineKeyboardButton

	if page > 1 {
		topButtons = append(topButtons, tgbotapi.NewInlineKeyboardButtonData("⬅️", fmt.Sprintf("visitors_page_%d", page-1)))
	}
	if page < totalPages {
		topButtons = append(topButtons, tgbotapi.NewInlineKeyboardButtonData("➡️", fmt.Sprintf("visitors_page_%d", page+1)))
	}

	if len(topButtons) > 0 {
		rows = append(rows, topButtons) // 상단 2개 버튼 한 줄
	}

	// 마지막 줄에 '뒤로가기' 버튼 추가
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 ", "admin_menu"),
	))

	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

// 외부 시스템에 콜백 URL 등록 요청
func notifyExternalSystem(url string) error {
	reqBody := strings.NewReader(`{"callback_url":"` + url + `"}`)

	req, err := http.NewRequest("POST", "https://external.api/register", reqBody)
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", "Bearer "+os.Getenv("EPUSDT_API_TOKEN"))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("외부 API 등록 실패, 상태코드: %d, 응답: %s", resp.StatusCode, string(body))
	}

	return nil
}

// .env 파일에 ngrok 및 관련 URL 자동 업데이트
func updateEnvNgrokURL(envPath, newURL string) error {
	data, err := os.ReadFile(envPath)
	if err != nil {
		return err
	}

	lines := strings.Split(string(data), "\n")
	updates := map[string]string{
		"NGROK_URL":         "NGROK_URL=" + newURL,
		"WEBHOOK_URL":       "WEBHOOK_URL=" + newURL + "/webhook",
		"EPUSDT_API_URL":    "EPUSDT_API_URL=" + newURL + "/api/notify/set",
		"EPUSDT_NOTIFY_URL": "EPUSDT_NOTIFY_URL=" + newURL + "/epusdt_notify",
	}

	keysUpdated := make(map[string]bool)
	var newLines []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			newLines = append(newLines, line)
			continue
		}
		parts := strings.SplitN(trimmed, "=", 2)
		key := parts[0]
		if val, ok := updates[key]; ok && !keysUpdated[key] {
			newLines = append(newLines, val)
			keysUpdated[key] = true
		} else {
			newLines = append(newLines, line)
		}
	}

	// 새로 추가할 키들 추가
	for key, val := range updates {
		if !keysUpdated[key] {
			newLines = append(newLines, val)
		}
	}

	output := strings.Join(newLines, "\n") + "\n"
	return os.WriteFile(envPath, []byte(output), 0644)
}

// [3] 트론 입금체크 → 주문생성/잔액갱신 처리 전체 함수
func checkTronDeposits() {
	walletList, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[트론그리드] 지갑 목록 조회 실패: %v", err)
		return
	}

	for _, wallet := range walletList {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[트론그리드] 입금 조회 실패: %v", err)
			continue
		}

		for _, deposit := range deposits {
			amount := deposit.Amount // float64
			txID := deposit.TxID     // string
			productName := "미매칭입금"   // 상품매칭 필요시 로직 추가

			err := createOrderAndUpdateBalance(wallet.UserID, productName, amount, txID)
			if err != nil {
				log.Printf("[주문처리] 실패: %v", err)
				continue
			}
		}
	}
}

func answerCallbackQuery(callbackID, text string) {
	callback := tgbotapi.NewCallback(callbackID, text)
	if _, err := bot.Request(callback); err != nil {
		log.Printf("CallbackQuery 응답 실패: %v", err)
	}
}

func processTronTransaction(tx TronTransaction) {
	processedTxsMu.Lock()
	if processedTxs[tx.TxID] {
		processedTxsMu.Unlock()
		return
	}
	processedTxs[tx.TxID] = true
	processedTxsMu.Unlock()

	// 이미 처리된 TX 확인
	var existing Order
	if err := db.Where("tx_id = ?", tx.TxID).First(&existing).Error; err == nil {
		return
	}

	amount, err := strconv.ParseFloat(tx.AmountStr, 64)
	if err != nil {
		log.Printf("[트론그리드] 입금액 파싱 실패 txid=%s, value=%s", tx.TxID, tx.AmountStr)
		return
	}

	var order Order
	err = db.Where("expected_amt = ? AND status = ?", amount, "입금대기중").First(&order).Error
	if err != nil {
		err = db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.001, amount+0.001, "입금대기중").First(&order).Error
	}
	if err != nil {
		log.Printf("[트론그리드] 매칭되는 주문 없음: amount=%.3f", amount)
		createUnmatchedOrder(amount, tx)
		return
	}

	// 주문에 TXID 설정 및 저장
	setOrderTxID(&order, tx.TxID)
	if err := db.Save(&order).Error; err != nil {
		log.Printf("[트론그리드] 주문 상태 업데이트 실패: %v", err)
		return
	}

	// 잔액충전 상품인 경우 잔액만 충전 후 종료
	if order.Product == "잔액충전" {
		if err := addUserBalance(order.UserID, order.Amount); err != nil {
			sendTelegram(order.UserID, "❌ 잔액 충전 실패! 관리자에게 문의하세요.")
			log.Printf("[잔액충전] 오류: %v", err)
		} else {
			sendTelegram(order.UserID, fmt.Sprintf("✅ %.3f USDT 잔액이 충전되었습니다!", order.Amount))
		}
		return
	}

	// 사용자, 관리자 알림
	userMsg := fmt.Sprintf(
		"🟢 *입금 확인 완료!*\n\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"📋 주문번호: #%d\n"+
			"📦 상품명: %s\n"+
			"💰 입금금액: %.3f USDT\n"+
			"🔗 트랜잭션: `%s`\n"+
			"⏰ 확인시간: %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"✅ 주문이 성공적으로 처리되었습니다!\n"+
			"🚀 상품이 곧 자동으로 지급됩니다.",
		order.ID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	msg := tgbotapi.NewMessage(order.UserID, userMsg)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	adminMsg := fmt.Sprintf(
		"🟢 *입금 확인 (매칭됨)*\n\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"📋 주문번호: #%d\n"+
			"👤 유저네임: %d\n"+
			"📦 상품: %s\n"+
			"💰 금액: %.3f USDT\n"+
			"🔗 TxID: `%s`\n"+
			"⏰ 시간: %s\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"✅ 자동 카드 지급 처리 중...",
		order.ID, order.UserID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	adminMsgObj := tgbotapi.NewMessage(unmatchedAdminChatID, adminMsg)
	adminMsgObj.ParseMode = "HTML"
	bot.Send(adminMsgObj)

	// 자동 카드 지급 비동기 처리
	go func(orderID uint, userID int64, txID string) {
		if err := processOrderWithValidation(orderID, txID); err != nil {
			log.Printf("[자동지급] 실패 orderID=%d, err=%v", orderID, err)
			msg := tgbotapi.NewMessage(userID, "❌ 지급 중 오류가 발생했습니다. 고객센터로 문의하세요.")
			bot.Send(msg)
		}
	}(order.ID, order.UserID, tx.TxID)
}

// TxID 설정 보조 함수 (sql.NullString 타입에 대응)
func setOrderTxID(order *Order, txID string) {
	order.TxID = &txID // ✅ string 값만 할당
}

func toFixed3(f float64) float64 {
	return math.Floor(f*1000) / 1000
}

// Telegram 메시지 전송 (에러 로깅 포함)
func notifySend(chatID int64, msg string) {
	if err := sendTelegram(chatID, msg); err != nil {
		log.Printf("Telegram 메시지 전송 실패 (chatID=%d): %v", chatID, err)
	}
}

// 한 번에 10명씩, 페이지네이션 지원
func getAllUsers() ([]User, error) {
	var users []User
	if err := db.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

// 전체 유저 수 카운트
func getUserCount() (int64, error) {
	var count int64
	err := db.Model(&User{}).Count(&count).Error
	return count, err
}

func showAdminAllUsersMenu(chatID int64, messageID int, page int) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	users, err := getUsersByPage(pageSize, offset)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 전체 유저 목록 조회 실패")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 더 이상 조회할 유저가 없습니다.")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("👥 전체 유저 (Page %d)\n\n", page)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(닉네임없음)"
		}
		username := user.UserName
		if username == "" {
			username = "없음"
		}
		text += fmt.Sprintf("%d. <b>%s</b> <code>%d</code> @%s - %s\n", i+1, nickname, user.UserID, username, user.LastSeen.Format("01-02 15:04"))
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s", nickname),
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// 페이징 버튼
	var navigation []tgbotapi.InlineKeyboardButton
	if page > 1 {
		navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("⬅️ 이전", fmt.Sprintf("admin_all_users_page_%d", page-1)))
	}
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("🔙 관리자메뉴", "admin_menu"))
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("➡️ 다음", fmt.Sprintf("admin_all_users_page_%d", page+1)))

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(navigation...))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Request(msg)
}

func showAdminCategoryMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	var rows [][]tgbotapi.InlineKeyboardButton

	// 2개씩 버튼을 묶어 한 행(row)에 추가
	for i := 0; i < len(categories); i += 2 {
		end := i + 2
		if end > len(categories) {
			end = len(categories)
		}
		var row []tgbotapi.InlineKeyboardButton
		for _, cat := range categories[i:end] {
			var callbackData string
			if cat == "VPS" {
				callbackData = "menu_vps" // VPS는 별도 메뉴로 연결
			} else {
				callbackData = "admin_cat_" + cat
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(cat, callbackData)
			row = append(row, btn)
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// 뒤로가기 버튼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 관리자 메뉴", "admin_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "📂상품수정 카테고리 선택")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// 카테고리명(category)으로 상품 조회
func showAdminProductListByCategory(chatID int64, messageID int, category string) {
	var products []Product

	err := db.Where("category = ?", category).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID,
			fmt.Sprintf("❗️ [%s] 카테고리에 상품이 없습니다.\n새 상품을 추가해 주세요.", category))
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_prod_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 카테고리로", "admin_category_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf("📦 [%s] 상품 목록\n상품을 선택하세요.", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// 미매칭 입금 주문 생성 및 관리자 알림
func createUnmatchedOrder(amount float64, tx TronTransaction) {
	unmatchedMsg := fmt.Sprintf(
		"🟢 *미매칭 입금 감지*\n\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"+
			"💰 금액: %.3f USDT\n"+
			"🔗 트랜잭션: `%s`\n"+
			"⏰ 시간: %s\n"+
			"📤 보낸주소: `%s`\n"+
			"📥 받은주소: `%s`\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"+
			"❓ 상태: 매칭되는 주문이 없습니다\n"+
			"💡 조치: 수동 확인 필요\n\n"+
			"🔍 주문번호와 금액 다시 확인 부탁드립니다.",
		amount, tx.TxID, time.Now().Format("2006-01-02 15:04:05"),
		tx.From, tx.To,
	)

	notifySend(unmatchedAdminChatID, unmatchedMsg)

	txID := tx.TxID
	order := Order{
		UserID:      0,
		Product:     "미상",
		Amount:      amount,
		Status:      "입금대기중",
		ExpectedAmt: amount,
		TxID:        &txID, // 포인터 할당
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("미매칭 입금 주문 저장 실패: %v", err)
	}
}

func updateUserGrade(userID int64, newGrade string) error {
	// 1. 등급 업데이트
	err := db.Model(&User{}).Where("user_id = ?", userID).Update("grade", newGrade).Error
	if err != nil {
		log.Printf("등급 업데이트 실패 userID=%d, newGrade=%s, err=%v", userID, newGrade, err)
		return err
	}

	// 2. 업데이트 성공 시 유저 정보 재조회 (username, chatID 필요)
	var user User
	if err := db.Where("user_id = ?", userID).First(&user).Error; err != nil {
		log.Printf("사용자 정보 조회 실패 userID=%d, err=%v", userID, err)
		return nil // 등급 변경은 성공했으므로 메시지 전송 실패는 무시
	}

	username := user.UserName
	if username == "" {
		username = "unknown"
	}

	msgText := fmt.Sprintf(
		"🔔 <b>회원 등급 변경 알림</b>\n\n"+
			"유저네임: <b>@%s</b> 님.\n"+
			"등급이 성공적으로 <b>%s</b> 로 변경되었습니다.\n\n"+
			"다양한 기능을 경험하시길 바랍니다.\n"+
			"WELCOME",
		username, newGrade,
	)

	msg := tgbotapi.NewMessage(user.ChatID, msgText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("회원 등급 변경 알림 전송 실패 userID=%d: %v", userID, err)
	}

	return nil
}

// ─── value(AmountStr) → float64 변환 유틸 ───
func parseUSDTAmount(raw string) float64 {
	val, _ := strconv.ParseFloat(raw, 64)
	return val / 1_000_000 // TRC20 USDT는 소수점 6자리(1 USDT == 1,000,000)
}

// ─── 타임스탬프(ms) → 사람이 읽을 수 있는 날짜 ───
func formatTronTimestamp(ts int64) string {
	return time.UnixMilli(ts).Format("2006-01-02 15:04:05")
}

func getTronDeposits(address string) ([]Deposit, error) {
	apiKey := getTronGridAPIKey()
	if apiKey == "" {
		return nil, fmt.Errorf("트론그리드 API 키가 설정되지 않음")
	}

	usdtContract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 메인넷 컨트랙트

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=50&contract_address=%s",
		address, usdtContract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	req.Header.Set("Accept", "application/json")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("트론그리드 API 응답 오류: %d %s", resp.StatusCode, string(body))
	}

	var apiResp struct {
		Data []struct {
			TxID      string `json:"transaction_id"`
			Value     string `json:"value"`
			Timestamp int64  `json:"block_timestamp"`
			From      string `json:"from"`
			To        string `json:"to"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, err
	}

	var deposits []Deposit
	for _, tx := range apiResp.Data {
		if !strings.EqualFold(tx.To, address) {
			continue
		}

		amount, err := strconv.ParseFloat(tx.Value, 64)
		if err != nil {
			log.Printf("[트론그리드] 입금액 파싱 실패 txid=%s, value=%s", tx.TxID, tx.Value)
			continue
		}
		amount = amount / 1_000_000

		deposits = append(deposits, Deposit{
			TxID:   tx.TxID,
			Amount: amount,
			Time:   time.UnixMilli(tx.Timestamp),
		})
	}
	return deposits, nil
}

func handleBroadcastInput(uid int64, text string) {
	// 입력 취소
	if text == "/cancel" {
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, "전체 공지 입력이 취소되었습니다.")
		return
	}

	// 전체 유저 채팅ID 조회
	var users []User
	err := db.Select("chat_id").Find(&users).Error
	if err != nil {
		sendTelegram(uid, "❌ 전체 유저 조회 실패")
		pendingBroadcastInput[uid] = false
		return
	}

	count := 0
	for _, user := range users {
		if user.ChatID == 0 {
			continue
		}
		_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "📢 <b>공지사항</b>\n\n"+text))
		if err != nil {
			log.Printf("공지 발송 실패: chat_id=%d, error=%v", user.ChatID, err)
			continue
		}
		count++
		time.Sleep(50 * time.Millisecond) // API 제한 회피용 조절 가능
	}

	pendingBroadcastInput[uid] = false
	sendTelegram(uid, fmt.Sprintf("✅ %d명에게 공지를 발송했습니다.", count))
}

// 입금 확인 및 주문 매칭 처리 (간결 로그 버전)
func processTronDeposits() {
	wallets, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[입금모니터링] 지갑 목록 조회 실패: %v", err)
		return
	}

	log.Printf("[입금모니터링] %d개 지갑 모니터링 시작", len(wallets))

	var (
		totalDeposits  int
		matchedCount   int
		unmatchedCount int
	)

	for _, wallet := range wallets {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[입금모니터링] %s... 입금 조회 실패: %v", wallet.Address[:10], err)
			continue
		}
		totalDeposits += len(deposits)

		for _, deposit := range deposits {
			if isDepositProcessed(deposit.TxID) {
				continue
			}

			// 주문 매칭 확인
			var existingOrder Order
			matchErr := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
				deposit.Amount-0.0001, deposit.Amount+0.0001, "입금대기중").
				First(&existingOrder).Error

			if matchErr == nil {
				matchedCount++
				log.Printf("[입금매칭] 주문 #%d, 금액: %.3f USDT, TxID: %.8s...", existingOrder.ID, deposit.Amount, deposit.TxID)
			} else {
				unmatchedCount++
				// log.Printf("[미매칭입금] %.3f USDT (TxID: %.8s...)", deposit.Amount, deposit.TxID)
			}

			processTronTransaction(TronTransaction{
				TxID:      deposit.TxID,
				From:      "", // 필요시 채우기
				To:        wallet.Address,
				AmountStr: fmt.Sprintf("%f", deposit.Amount),
				Timestamp: deposit.Time.UnixMilli(),
			})
			markDepositProcessed(deposit.TxID)
		}
	}

	// 최종 요약
	if totalDeposits > 0 {
		log.Printf("[입금모니터링] 요약: 총 %d건 | 매칭 %d | 미매칭 %d", totalDeposits, matchedCount, unmatchedCount)
	}
}

// 입금 모니터링 루프 시작
func startDepositMonitoring() {
	go func() {
		ticker := time.NewTicker(40 * time.Second)
		defer ticker.Stop()
		log.Println("🔍 입금 모니터링 시작... (40초 간격)")
		for {
			processTronDeposits()
			<-ticker.C
		}
	}()
}

func sendTelegram(chatID int64, text string) error {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML" // Markdown -> HTML 변경
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("텔레그램 메시지 전송 실패: %v", err)
		return err
	}
	return nil
}

func handleCoinPayment(cb *tgbotapi.CallbackQuery, uid int64, chatID int64, orderID uint64) {
	productCode := strings.TrimPrefix(cb.Data, "pay_coin_")

	// 상품 코드로 이름/가격 찾기
	var prodName string
	var basePrice float64
	found := false
	for _, cats := range cardCategories {
		for name, prod := range cats {
			if prod.Code == productCode {
				prodName = name
				basePrice = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}
	if !found {
		sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "상품 정보 없음"))
		return
	}

	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		log.Println("⚠️ COIN_PAYMENT_ADDR 환경변수 설정 안됨")
		sendTelegram(uid, "❌ 결제 주소가 설정되어 있지 않습니다. 관리자에게 문의하세요.")
		return
	}
	// 1. 주문 생성 (임시 금액, DB PK 확보)
	order := Order{
		UserID:      uid,
		Product:     prodName,  // 상품 이름 또는 코드
		Amount:      basePrice, // 임시로 basePrice 사용
		Status:      "입금대기중",
		ExpectedAmt: basePrice,
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("주문 생성 실패: %v", err)
		return
	}

	// 2. 주문별 고유 결제금액 생성 (주문ID 기반, 소수점 셋째자리 내림)
	uniqueAmt := toFixed3(basePrice + float64(order.ID)/1000.0)
	order.Amount = uniqueAmt
	order.ExpectedAmt = uniqueAmt
	if err := db.Save(&order).Error; err != nil {
		log.Printf("주문 금액 업데이트 실패: %v", err)
	}

	// 3. QR코드 생성
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID)
	if err := generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", coinAddr, uniqueAmt), qrPath); err != nil {
		log.Printf("QR 코드 생성 실패: %v", err)
	}

	// 4. 주문 안내 메시지
	msgText := fmt.Sprintf(
		"🛒 <b>주문 접수 완료</b>\n\n"+
			"• 주문번호: <code>%d</code>\n• 상품명: <b>%s</b>\n• 결제금액: <b>%.3f USDT</b>\n\n"+
			"(소수점까지 정확하게, QR 코드 활용 권장)\n20분 내 미입금시 자동취소 됩니다.",
		order.ID, prodName, uniqueAmt,
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("❌ 주문취소", fmt.Sprintf("cancel_order_%d", order.ID)),
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("주문 안내 메시지 전송 실패: %v", err)
	}
	userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)

	// 5. QR코드 안내 이미지 전송 (ParseMode=HTML)
	if qrPath != "" {
		photo := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(qrPath))
		photo.Caption = fmt.Sprintf(
			"아래 주소로 <b>정확한 금액</b>을 입금해 주세요.\n<b>━━━━━━━━━━━━━━━━</b>\n<code>%s</code>\n<b>━━━━━━━━━━━━━━━━</b>\n주소 클릭시 복사 됩니다.",
			coinAddr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("QR 코드 이미지 전송 실패: %v", err)
		}
	}

	// 6. 20분 미입금 자동취소 처리 (고루틴)
	go func(orderID uint, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "입금대기중" {
			ord.Status = "자동취소"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("주문 자동취소 저장 실패: %v", err)
			}
			sendTelegram(userID, fmt.Sprintf("❌ 주문 #%d 20분 내 미입금으로 자동취소되었습니다.", orderID))
		}
	}(order.ID, uid)

	bot.Send(tgbotapi.NewCallback(cb.ID, "주문이 접수되었습니다."))
}

// 전체 방문자 조회 (중복 없이 최근 방문자 목록 등)
func getAllVisitors() ([]Visitor, error) {
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen FROM (
			SELECT user_id, user_name, last_seen,
				ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_seen DESC) as rn
			FROM users
		) t
		WHERE rn = 1
		ORDER BY last_seen DESC
	`).Scan(&visitors).Error
	return visitors, err
}

func getVisitorsByDate(date time.Time) ([]Visitor, error) {
	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen
		FROM users
		WHERE last_seen BETWEEN ? AND ?
		ORDER BY last_seen DESC
	`, start, end).Scan(&visitors).Error
	return visitors, err
}

func handleAdminListVisitors(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
		return
	}

	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil {
		log.Printf("[handleAdminListVisitors] DB 조회 실패: %v", err)
		sendTelegram(uid, "❌ DB 조회 중 오류 발생")
		return
	}
	if len(activities) == 0 {
		log.Printf("[handleAdminListVisitors] 조회 결과 없음")
		sendTelegram(uid, "❌ 전체 방문자 조회 실패 또는 방문자 없음")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>👥 전체 방문자 (최신 50명)</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}
		lastActive := "(알 수 없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n  최근 활동: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")

	sendTelegram(uid, sb.String())
}

func createDepositOrder(userID int64, amount float64) error {
	// 상품명/가격 등은 입금전용 주문이면 명확하게 고정
	prodName := "USDT 충전"
	price := amount

	order := Order{
		UserID:      userID,
		Product:     prodName,
		Amount:      price,
		Status:      "입금대기중",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
	}

	// order로 바로 생성, 이후 order.ID 활용
	if err := db.Create(&order).Error; err != nil {
		return err
	}

	addr := os.Getenv("COIN_PAYMENT_ADDR")
	qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
	_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

	msgText := fmt.Sprintf(
		"💸 <b>충전 주문이 생성되었습니다!</b>\n\n"+
			"아래 주소로 <b>정확히 <code>%.3f USDT</code></b>를 입금해 주세요.\n\n"+
			"• 주문번호: <code>%d</code>\n"+
			"• 입금주소: <code>%s</code>\n"+
			"• 결제금액: <b>%.3f USDT</b>\n\n"+
			"(QR코드로 송금 가능, 소수점까지 정확히!)",
		amount, order.ID, addr, amount,
	)

	msg := tgbotapi.NewMessage(userID, msgText)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	photo := tgbotapi.NewPhoto(userID, tgbotapi.FilePath(qrPath))
	photo.Caption = "QR코드를 사용하면 금액이 자동 지정됩니다."
	photo.ParseMode = "HTML"
	bot.Send(photo)

	return nil
}
func sendTelegramHTML(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func handleAdminListVisitorsToday(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
		return
	}

	today := time.Now().Format("2006-01-02")

	var visitors []UserActivityLog
	err := db.Where("DATE(last_active) = ?", today).Order("last_active DESC").Find(&visitors).Error
	if err != nil || len(visitors) == 0 {
		sendTelegram(uid, "❌ 오늘 방문자 조회 실패 또는 방문자 없음")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>📅 오늘 방문자 목록</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, v := range visitors {
		username := v.Username
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}
		lastActive := v.LastActive.Format("15:04")

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n  최근 활동: %s\n\n",
			i+1, v.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")

	sendTelegram(uid, sb.String())
}

func showAdminProductDetail(chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(chatID, "❌ 상품 정보를 불러올 수 없습니다.")
		return
	}

	stockCount, err := getCardStock(product.Name)
	if err != nil {
		stockCount = 0
	}

	text := fmt.Sprintf(
		"📄 <b>상품 상세</b>\n\n"+
			"• 이름: %s\n"+
			"• 가격: %.2f USDT\n"+
			"• 설명: %s\n"+
			"• 재고: %d\n",
		product.Name, product.Price, product.Description, stockCount,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", fmt.Sprintf("admin_add_stock_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("📦 재고목록", fmt.Sprintf("admin_stock_list_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✏️ 상품수정", fmt.Sprintf("admin_edit_product_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("🗑 상품삭제", fmt.Sprintf("admin_delete_product_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 상품목록", fmt.Sprintf("admin_cat_back_%d", product.CategoryID)),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showTodayVisitorsMenu(chatID int64, messageID int) {
	// 오늘 날짜 00:00 ~ 23:59 기준
	today := time.Now().Format("2006-01-02")
	var users []User
	// last_seen 또는 last_login 칼럼 기준 (칼럼 이름에 맞게 수정)
	err := db.Where("DATE(last_seen) = ?", today).Order("last_seen DESC").Find(&users).Error
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 오늘 방문자 조회 실패")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "오늘 방문자가 없습니다.")
		bot.Request(msg)
		return
	}

	text := "👀 <b>오늘 방문자 (최신순)</b>\n\n"
	for i, u := range users {
		text += fmt.Sprintf("%d. <code>%d</code> @%s (%s)\n",
			i+1, u.UserID, u.UserName, u.LastSeen.Format("15:04"))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 메인으로", "admin_visitor_menu"),
		),
	)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

// QR코드 생성 함수
func generateWalletQRCode(data string, filename string) error {
	if data == "" {
		log.Println("QR코드 생성 스킵: 주소(데이터) 없음")
		return fmt.Errorf("QR코드 생성 실패: 입력 데이터 없음")
	}

	// 파일 저장 디렉토리 생성 (없으면 자동 생성)
	dir := filepath.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		log.Printf("QR코드 저장 폴더 생성 실패: %v", err)
		return fmt.Errorf("QR코드 폴더 생성 실패: %w", err)
	}

	// QR코드 파일 생성
	if err := qrcode.WriteFile(data, qrcode.Medium, 256, filename); err != nil {
		log.Printf("QR코드 이미지 생성 실패: %v", err)
		return fmt.Errorf("QR코드 이미지 생성 실패: %w", err)
	}

	return nil // 성공
}

func findMatchingOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "입금대기중").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("매칭되는 주문 없음: %.6f", amount)
	}
	return &order, nil
}

// 트론그리드 API 키 가져오기
func getTronGridAPIKey() string {
	apiKey := os.Getenv("TRONGRID_API_KEY")
	if apiKey == "" {
		log.Println("⚠️ TRONGRID_API_KEY 환경변수가 설정되지 않았습니다.")
	}
	return apiKey
}

// amount에 근접한 '입금대기중' 상태 주문 조회 (오차 ±0.0001 허용)
func matchOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.0001, amount+0.0001, "입금대기중").First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("매칭되는 주문 없음: %.6f", amount)
	}
	return &order, nil
}

// 방문자 페이지별 조회 (한 페이지에 10명)
func getVisitorsByPage(page int) ([]User, error) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	return getUsersByPage(pageSize, offset)
}

func showAllVisitorsMenu(chatID int64, messageID int) {
	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil || len(activities) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 전체 방문자 조회 실패 또는 방문자 없음")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>👥 전체 방문자 (최신 50명)</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}
		lastActive := "(알 수 없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n  최근 활동: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 메인으로", "admin_visitor_menu"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func formatUserActivitiesMessagePaged(activities []UserActivityLog, page, pageSize int) string {
	total := len(activities)
	start := (page - 1) * pageSize
	if start >= total {
		return "조회 결과가 없습니다."
	}

	end := start + pageSize
	if end > total {
		end = total
	}

	totalPages := (total + pageSize - 1) / pageSize

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 최근 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))

	for _, act := range activities[start:end] {
		lastActive := "(없음)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(없음)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}

		sb.WriteString(fmt.Sprintf(
			"• 사용자ID: %d / @%s / 닉네임: %s\n  최근활동: %s\n━━━━━━━━━━━━━━\n",
			act.UserID, username, nickname, lastActive,
		))
	}

	return sb.String()
}

func showAdminBroadcastMenu(chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "📢 전체공지\n\n모든 회원에게 보낼 메시지를 입력하세요.\n취소: /cancel")
	bot.Request(msg)
	// 입력 대기 상태 세팅은 handleCallback에서 처리
}

// 트론 입금 트랜잭션과 주문 매칭 함수 예시
func matchOrderByDepositAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "입금대기중").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("매칭되는 주문 없음: %.6f", amount)
	}
	return &order, nil
}

// 방문자 목록 페이지네이션 인라인 키보드 생성
func getVisitorPaginationKeyboard(currentPage, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var buttons []tgbotapi.InlineKeyboardButton

	// 뒤로가기 버튼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙 뒤로가기", "admin_visitor_menu")

	// 이전/다음 페이지 버튼
	if currentPage > 1 {
		buttons = append(buttons,
			tgbotapi.NewInlineKeyboardButtonData("⬅️ 이전", fmt.Sprintf("visitor_page_%d", currentPage-1)),
		)
	}
	if currentPage < totalPages {
		buttons = append(buttons,
			tgbotapi.NewInlineKeyboardButtonData("다음 ➡️", fmt.Sprintf("visitor_page_%d", currentPage+1)),
		)
	}

	// 현재 페이지 표시 버튼 (클릭 불가용)
	pageBtn := tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("페이지 %d/%d", currentPage, totalPages), "noop")

	// 버튼 배열 구성 (뒤로가기 별도 줄로)
	row1 := []tgbotapi.InlineKeyboardButton{backBtn}
	row2 := []tgbotapi.InlineKeyboardButton{pageBtn}
	row2 = append(row2, buttons...)

	return tgbotapi.NewInlineKeyboardMarkup(row1, row2)
}

// 방문자 페이지 조회 및 메시지 전송 함수
func showVisitorListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, total, err := getVisitors(page, pageSize)
	if err != nil {
		sendTelegram(uid, "❌ 방문자 목록을 불러오는 중 오류가 발생했습니다.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatVisitorListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("방문자 목록 메시지 전송 실패: %v", err)
	}
}

func formatVisitorListMessage(users []User, page, totalPages int) string {
	if len(users) == 0 {
		return "<b>조회 결과가 없습니다.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>👥 방문자 목록 (페이지 %d / %d)</b>\n━━━━━━━━━━━━━━\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(없음)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(이름 없음)"
		}
		lastSeen := "(알 수 없음)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\n최근 접속: %s\n━━━━━━━━━━━━━━\n",
			(i+1)+(page-1)*10, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

// 유저ID로 등록된 트론(USDT) 지갑 주소 조회
func getWalletAddress(uid int64) (string, error) {
	var walletMap WalletMap
	err := db.Where("user_id = ?", uid).First(&walletMap).Error
	if err != nil || walletMap.Wallet == "" {
		return "", fmt.Errorf("등록된 지갑 없음")
	}
	return walletMap.Wallet, nil
}

func handleAdminMonthlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "📊 월간 리포트\n\n" +
		"• 총 매출: 1,000,000 USDT\n" +
		"• 총 주문 수: 1500건\n" +
		"• 인기 상품: VPS 1개월\n" +
		"• 신규 가입자: 200명\n\n" +
		"📅 해당 달 데이터를 표시합니다."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("월간 리포트 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "월간 리포트 표시"))
}

func handleAdminYearlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "📊 연간 리포트\n\n" +
		"• 총 매출: 12,000,000 USDT\n" +
		"• 총 주문 수: 18,000건\n" +
		"• 인기 상품: VPS 1년\n" +
		"• 신규 가입자: 2,500명\n\n" +
		"📅 해당 연도 데이터를 표시합니다."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("연간 리포트 전송 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "연간 리포트 표시"))
}

// 관리자에게 상품명/가격 입력 요청
func promptEditProduct(uid, chatID int64, msgID int, productID int) {
	// DB에서 상품 정보 조회
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}
	// 임시로 수정 대기상태 저장 (uid별 productID)
	pendingEditProduct[uid] = productID

	msg := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf(
		"🔧 <b>상품 정보 수정</b>\n\n"+
			"현재 이름: <code>%s</code>\n현재 가격: <b>%.2f USDT</b>\n\n"+
			"수정할 <b>이름:가격</b>을 아래 형식으로 입력해 주세요.\n"+
			"(예시: <code>%s:%.2f</code>)", prod.Name, prod.Price, prod.Name, prod.Price))
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func foo(cb *tgbotapi.CallbackQuery) {
	log.Println(cb.Data)
}

func myFunc(cb *tgbotapi.CallbackQuery) {
	log.Println(cb.Data)
}

func sendCaptchaChallenge(chatID int64, a, b, correctAnswer int) {
	text := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🔒<b>PRIVATE ACCESS ONLY</b>\n"+
			"접근 권한이 없습니다.\n"+
			"아래 문제를 풀어 해제 하세요.\n\n"+
			"<b>%d + %d = ?</b>\n"+
			"<b>━━━━━━━━━━━━━━━━</b>",
		a, b,
	)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer), fmt.Sprintf("verify_%d", correctAnswer)),
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer+1), fmt.Sprintf("verify_%d", correctAnswer+1)),
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer-1), fmt.Sprintf("verify_%d", correctAnswer-1)),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = markup
	bot.Send(msg)
}

func handlePhotoMessage(msg *tgbotapi.Message) {
	// 사진 메시지 처리 로직
}

func handleMessage(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	text := strings.TrimSpace(msg.Text)

	if len(msg.Photo) > 0 {
		handlePhotoMessage(msg)
		return
	}

	username := ""
	if msg.From != nil {
		username = msg.From.UserName
	}
	isAdminUser := isAdmin(uid)

	if !verifiedUsers[uid] {
		a, b, ans := generateCaptcha()
		verificationAnswers[uid] = ans
		sendCaptchaChallenge(chatID, a, b, ans)
		return
	}

	if pendingBroadcastInput[uid] {
		if text == "/cancel" {
			pendingBroadcastInput[uid] = false
			sendTelegram(uid, "전체 공지 입력이 취소되었습니다.")
			return
		}
		var users []User
		err := db.Select("chat_id").Find(&users).Error
		if err != nil {
			sendTelegram(uid, "❌ 전체 유저 조회 실패")
			pendingBroadcastInput[uid] = false
			return
		}
		successCount := 0
		for _, user := range users {
			if user.ChatID == 0 {
				continue
			}
			_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "📢 [공지]\n\n"+text))
			if err == nil {
				successCount++
			}
			time.Sleep(30 * time.Millisecond)
		}
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, fmt.Sprintf("✅ 총 %d명에게 공지를 전송했습니다.", successCount))
		return
	}

	if pid, ok := pendingEditProduct[uid]; ok {
		if text == "취소" || text == "나가기" || text == "/cancel" {
			delete(pendingEditProduct, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "❌ 상품 추가가 취소되었습니다.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showCategoryMenu(uid, chatID, 0)
			return
		}
		if pid == 0 {
			delete(pendingEditProduct, uid)
			cat, ok := selectedCategory[uid]
			if !ok || cat == "" {
				sendTelegram(uid, "❌ 먼저 카테고리를 선택하세요!")
				return
			}
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "❌ 올바른 형식이 아닙니다.\n예시: 새상품명:9.99")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price <= 0 {
				sendTelegram(uid, "❌ 가격은 숫자(1 이상)로 입력해 주세요.")
				return
			}
			categoryID, ok := categoryMap[cat]
			if !ok {
				sendTelegram(uid, "❌ 잘못된 카테고리입니다.")
				return
			}
			code := uuid.New().String()
			prod := Product{
				Code:       code,
				Name:       name,
				Price:      price,
				Active:     true,
				CategoryID: categoryID,
			}
			if err := db.Create(&prod).Error; err != nil {
				sendTelegram(uid, fmt.Sprintf("❌ 상품 추가 실패: %v", err))
				return
			}
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("✅ 새 상품 '%s' (%.2f USDT) 추가 완료! [카테고리: %s]", name, price, cat))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}

		if pid != 0 {
			delete(pendingEditProduct, uid)
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "❌ 입력 형식이 올바르지 않습니다.\n(예시: 상품명:9.99)")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price < 0.01 {
				sendTelegram(uid, "❌ 가격은 0.01 이상 숫자로 입력해 주세요.")
				return
			}
			var prod Product
			if err := db.First(&prod, pid).Error; err != nil {
				sendTelegram(uid, "❌ 상품 정보를 불러올 수 없습니다.")
				return
			}
			cat := ""
			for k, v := range categoryMap {
				if v == prod.CategoryID {
					cat = k
					break
				}
			}
			if err := db.Model(&Product{}).Where("id = ?", pid).
				Updates(map[string]interface{}{"name": name, "price": price}).Error; err != nil {
				sendTelegram(uid, "❌ 상품 정보 수정 실패! 다시 시도해 주세요.")
			} else {
				sendTelegram(uid, fmt.Sprintf("✅ 상품이 수정되었습니다!\n이름: %s\n가격: %.2f", name, price))
			}
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}
	}

	if pidStr, ok := pendingStockInput[uid]; ok {
		productID, _ := strconv.Atoi(pidStr)
		var prod Product
		if err := db.First(&prod, productID).Error; err != nil {
			sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
			return
		}
		if !pendingStockInputNotified[uid] {
			sendTelegram(uid, fmt.Sprintf("🔹 [%s] 상품에 재고 코드를 붙여넣거나 입력하세요.\n완료 시 '완료'를 입력하세요.", prod.Name))
			pendingStockInputNotified[uid] = true
		}

		if text == "취소" || text == "나가기" || text == "/cancel" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "❌ 재고 추가가 취소되었습니다.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showCategoryMenu(uid, chatID, 0)
			return
		}

		lines := strings.Split(text, "\n")
		var added int
		for _, line := range lines {
			code := strings.TrimSpace(line)
			if code == "" || code == "완료" {
				continue
			}
			stock := StockCard{
				Name:    prod.Name,
				Content: code,
				Used:    false,
			}
			if err := db.Create(&stock).Error; err == nil {
				added++
			}
		}
		if strings.Contains(text, "완료") || text == "완료" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("✅ %d개의 코드가 추가되었습니다! (상품명: %s)", added, prod.Name))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
		} else {
			bot.Send(tgbotapi.NewMessage(uid, fmt.Sprintf("임시저장: [%d개] 코드가 입력되었습니다. 계속 붙여넣거나 '완료'를 입력하세요.", added)))
		}
		return
	}

	if pendingDepositInput[uid] {
		amount, err := strconv.ParseFloat(text, 64)
		if err != nil || amount < 1 {
			sendTelegram(uid, "❌ 1 USDT 이상, 올바른 숫자만 입력해 주세요.")
			return
		}
		delete(pendingDepositInput, uid)

		prodName := "USDT 충전"
		price := amount

		order := Order{
			UserID:      uid,
			Product:     prodName,
			Amount:      price,
			Status:      "입금대기중",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
		}

		if err := db.Create(&order).Error; err != nil {
			sendTelegram(uid, "❌ 주문 생성 실패! 관리자에게 문의해 주세요.")
			return
		}

		addr := os.Getenv("COIN_PAYMENT_ADDR")
		qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
		_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

		msgText := fmt.Sprintf(
			"💸 <b>충전 주문이 생성되었습니다!</b>\n\n"+
				"아래 주소로 <b>정확히 <code>%.3f USDT</code></b>를 입금해 주세요.\n\n"+
				"• 주문번호: <code>%d</code>\n"+
				"• 입금주소: <code>%s</code>\n"+
				"• 결제금액: <b>%.3f USDT</b>\n\n"+
				"(QR코드로 송금 가능, 소수점까지 정확히!)",
			amount, order.ID, addr, amount,
		)
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		bot.Send(msg)

		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photo.Caption = "QR코드를 사용하면 금액이 자동 지정됩니다."
		photo.ParseMode = "HTML"
		bot.Send(photo)
		return
	}

	if strings.HasPrefix(text, "/") {
		switch text {
		case "/start":
			handleStart(msg)
		case "/menu":
			showMenu(uid, username, chatID)
		case "/공지":
			if isAdminUser {
				pendingBroadcastInput[uid] = true
				sendTelegram(uid, "전체 공지 내용을 입력하세요. 취소하려면 /cancel 입력")
			} else {
				sendTelegram(uid, "권한이 없습니다.")
			}
		case "/balance":
			handleBalanceCommand(msg)
		case "/addstock":
			handleAddStockCommand(msg)
		case "/내지갑":
			wallet := getUserWallet(uid)
			if wallet == "" {
				sendTelegram(chatID, "❌ 등록된 지갑이 없습니다. /지갑등록 명령어로 지갑을 먼저 등록해 주세요.")
			} else {
				sendTelegram(chatID, fmt.Sprintf("✅ 등록된 TRC20 지갑 주소:\n<code>%s</code>", wallet))
			}
		default:
			log.Printf("[handleMessage] 알 수 없는 명령어: %s", text)
		}
		return
	}

	switch text {
	case "에너지":
		showEnergyMenu(uid, chatID, msg.MessageID)
		return
	case "내 정보":
		showBalanceMenu(uid, chatID, 0)
		return
	case "고객센터":
		showSupportMenu(uid, chatID, 0)
		return
	case "주문내역":
		showOrderHistoryMenu(uid, chatID, msg.MessageID)
		return
	}

	if !isAdminUser {
		log.Printf("[handleMessage] uid=%d, text=%q (관리자 아님, 무시)", uid, text)
		return
	}

	if strings.Contains(text, ":") && len(strings.Split(text, ":")) >= 3 {
		if err := saveStockWithImage(uid, text, ""); err != nil {
			sendTelegram(uid, fmt.Sprintf("❌ 재고 추가 실패: %v", err))
		} else {
			sendTelegram(uid, "✅ 재고가 성공적으로 추가되었습니다!")
		}
		return
	}

	if text == "등록" {
		sendTelegram(uid, "❌ 등록할 재고 정보가 없습니다. 먼저 재고 정보를 입력해주세요.")
		return
	}

	log.Printf("[handleMessage] uid=%d, text=%q (처리할 내용 없음)", uid, text)
}

func getUsersByPage(limit, offset int) ([]User, error) {
	var users []User
	err := db.Order("last_seen DESC").Limit(limit).Offset(offset).Find(&users).Error
	return users, err
}

func showOrderHistoryMenu(uid int64, chatID int64, msgID int) {
	// 최근 주문 10개 조회
	var orders []Order
	err := db.
		Where("user_id = ?", uid).
		Order("created_at DESC").
		Limit(10).
		Find(&orders).Error
	if err != nil {
		msg := tgbotapi.NewMessage(chatID, "❌ 주문 내역을 불러오지 못했습니다.")
		bot.Send(msg)
		return
	}

	if len(orders) == 0 {
		msg := tgbotapi.NewMessage(chatID, "최근 주문 내역이 없습니다.")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("🧾 <b>최근 주문 내역 (최대 10개)</b>\n\n")

	for _, order := range orders {
		var txid string
		switch v := any(order.TxID).(type) {
		case sql.NullString:
			if v.Valid {
				txid = v.String
			} else {
				txid = "-"
			}
		case *string:
			if v != nil && *v != "" {
				txid = *v
			} else {
				txid = "-"
			}
		case string:
			if v != "" {
				txid = v
			} else {
				txid = "-"
			}
		default:
			txid = "-"
		}

		sb.WriteString(fmt.Sprintf(
			"• <b>주문번호:</b> <code>%d</code>\n"+
				"  <b>상품명:</b> %s\n"+
				"  <b>금액:</b> %.3f USDT\n"+
				"  <b>상태:</b> %s\n"+
				"  <b>TXID:</b> %s\n"+
				"  <b>일시:</b> %s\n\n",
			order.ID,
			html.EscapeString(order.Product),
			order.Amount,
			order.Status,
			txid,
			order.CreatedAt.Format("2006-01-02 15:04"),
		))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 뒤로가기", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func promptAddStock(uid, chatID int64, msgID int, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}
	pendingStockInput[uid] = strconv.Itoa(productID)

	msg := tgbotapi.NewMessage(chatID, fmt.Sprintf(
		"<b>[%s]</b>  상품에 추가할 코드(한 줄에 하나씩 붙여넣기) 입력!\n(입력 종료: '완료', 취소: '취소' 또는 '/cancel' 입력\n"+
			"여러 줄 입력 가능하며, 마지막 줄에 <b>완료</b>를 입력하면 저장됩니다.\n\n"+
			"예시:\n<code>1234-5678-ABCD\nQWER-8888-ZXCV\nA1B2C3D4E5F6\n...</code>\n\n(끝나면 '완료' 입력)",
		prod.Name))
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func showProductListMenuByCategory(chatID int64, messageID int, category string) {
	var products []Product
	err := db.Where("category_id = ?", categoryMap[category]).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 해당 카테고리에 상품이 없습니다.")
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_stock_detail_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 카테고리 목록", "admin_inventory"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("📋 [%s] 상품 목록", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// 단순 메시지 전송 함수
func sendSimpleMsg(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	bot.Send(msg)
}

// 상품 없을 때 안내 메시지
func showEmptyCategoryMessage(chatID int64, messageID int, category string) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 상품추가", fmt.Sprintf("add_product_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("🔙 카테고리로", "admin_menu"),
		),
	}
	msgText := fmt.Sprintf("❗️ [%s] 카테고리에 상품이 없습니다.\n[➕ 상품추가]로 새 상품을 등록하세요!", category)
	editMsgWithButtons(chatID, messageID, msgText, rows)
}

func buildProductButtons(products []Product) [][]tgbotapi.InlineKeyboardButton {
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		rows = append(rows,
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("➕ 재고", fmt.Sprintf("admin_add_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("ℹ️ 상세", fmt.Sprintf("admin_stock_detail_%d", p.ID)),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("✏️ 수정", fmt.Sprintf("admin_edit_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("🗑 삭제", fmt.Sprintf("admin_del_stock_%d", p.ID)),
			),
		)
	}
	return rows
}

// 메시지 수정 + 버튼 붙이기 함수
func editMsgWithButtons(chatID int64, messageID int, text string, rows [][]tgbotapi.InlineKeyboardButton) {
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	if _, err := bot.Send(edit); err != nil {
		log.Printf("메시지 수정 실패: %v", err)
	}
}

func showUserGradeChangeMenu(chatID int64, msgID int, userID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🥉", fmt.Sprintf("admin_set_grade_%d_bronze", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥈", fmt.Sprintf("admin_set_grade_%d_silver", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥇", fmt.Sprintf("admin_set_grade_%d_gold", userID)),
			tgbotapi.NewInlineKeyboardButtonData("💎", fmt.Sprintf("admin_set_grade_%d_diamond", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 돌아가기", "admin_user_list"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, "변경할 등급을 선택하세요.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"
	bot.Send(edit)
}

func promptAddStockInput(uid int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 정보를 찾을 수 없습니다.")
		return
	}

	msgText := fmt.Sprintf("➕ 재고 추가 - 상품: <b>%s</b>\n\n재고 코드를 한 줄에 하나씩 입력해 주세요.\n완료 시 '완료'를 입력하거나 /cancel 명령어를 사용하세요.", prod.Name)
	sendTelegram(uid, msgText) // 수정된 부분

	pendingStockInput[uid] = strconv.Itoa(productID)
}

func handleCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleCallback] 콜백 데이터: %s", cb.Data)
	data := cb.Data
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	uid := int64(cb.From.ID)
	callbackID := cb.ID
	username := ""
	if cb.From != nil {
		username = cb.From.UserName
	}

	// VPS 상세 설명
	vpsDetails := map[string]string{
		"vps1": "<b>KVM - E1</b>\n\n• CPU: 4코어\n• RAM: 4GB\n• 저장공간: 100GB NVMe\n• 가격: 70 USDT\n\n- 빠른 NVMe SSD\n- 일반 사무용 적합\n\n※ DMCA 요청은 무시합니다.",
		"vps2": "<b>KVM - E2</b>\n\n• CPU: 4코어\n• RAM: 6GB\n• 저장공간: 140GB NVMe\n• 가격: 90 USDT\n\n- 중급 사양\n- 개발 및 서비스 운영 적합\n\n※ DMCA 요청은 무시합니다.",
		"vps3": "<b>KVM - T1</b>\n\n• CPU: 8코어\n• RAM: 16GB\n• 저장공간: 160GB NVMe\n• 가격: 120 USDT\n\n- 고부하 작업 적합\n- 게임 서버 및 데이터 처리\n\n※ DMCA 요청은 무시합니다.",
		"vps4": "<b>KVM - T2</b>\n\n• CPU: 12코어\n• RAM: 24GB\n• 저장공간: 256GB NVMe\n• 가격: 150 USDT\n\n- 고성능 대규모 서비스용\n- 최적화된 하드웨어\n\n※ DMCA 요청은 무시합니다.",
		"vps5": "<b>맞춤 제작</b>\n\n- 맞춤형 사양 제공\n- 문의 후 견적 안내\n- 안정성과 성능 우선",
	}

	if detail, ok := vpsDetails[data]; ok {
		orderBtn := tgbotapi.NewInlineKeyboardButtonData("🛒 주문", "order_"+data)
		backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙 ", "menu_vps")
		kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(orderBtn, backBtn))
		edit := tgbotapi.NewEditMessageText(cb.Message.Chat.ID, cb.Message.MessageID, detail)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
		return
	}

	// 2. VPS 목록 보여주기
	if data == "menu_vps" {
		showVPSMenu(uid, chatID, msgID)
		return
	}
	if strings.HasPrefix(data, "admin_cat_") {
		category := strings.TrimPrefix(data, "admin_cat_")
		selectedCategory[uid] = category
		showProductListMenuByCategory(chatID, msgID, category)
		return
	}
	if data == "admin_list_stock" {
		handleListStockCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "재고 목록 요청 처리 중"))
		return
	}

	if data == "admin_add_admin" {
		handleAddAdminCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 추가 요청 처리 중"))
		return
	}
	if data == "admin_cancel_order" {
		handleCancelOrderCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "주문 취소 요청 처리 중"))
		return
	}

	if strings.HasPrefix(data, "visitors_page_") {
		handleVisitorPageCallback(cb)
		return
	}
	if strings.HasPrefix(data, "verify_") {
		handleVerificationResponse(cb)
		return
	}
	if strings.HasPrefix(data, "admin_send_backup_") {
		fileName := strings.TrimPrefix(data, "admin_send_backup_")
		filePath := "/home/minho/backups/" + fileName
		bot.Send(tgbotapi.NewDocument(chatID, tgbotapi.FilePath(filePath)))
		return
	}
	if strings.HasPrefix(data, "admin_all_users_page_") {
		pageStr := strings.TrimPrefix(data, "admin_all_users_page_")
		page, _ := strconv.Atoi(pageStr)
		showAdminAllUsersMenu(chatID, msgID, page)
		return
	}
	if strings.HasPrefix(data, "order_") {
		productCode := strings.TrimPrefix(data, "order_")
		showOrderConfirmButtons(cb, productCode)
		return
	}
	if strings.HasPrefix(data, "add_product_") {
		cat := strings.TrimPrefix(data, "add_product_")
		selectedCategory[uid] = cat // uid별로 선택 카테고리 기록
		pendingEditProduct[uid] = 0 // 신규 상품 추가 플래그

		cancelKb := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("취소"),
				tgbotapi.NewKeyboardButton("나가기"),
			),
		)

		msg := tgbotapi.NewMessage(uid, fmt.Sprintf(
			"➕ [%s] 카테고리에 추가할 <b>상품명:가격</b>을 입력하세요!\n예시: 신상품:9.99", cat))
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = cancelKb
		bot.Send(msg)

		bot.Send(tgbotapi.NewCallback(cb.ID, "상품 추가 대기중"))
		return
	}
	// 상품 상세
	if strings.HasPrefix(data, "admin_stock_detail_") {
		productID, err := strconv.Atoi(strings.TrimPrefix(data, "admin_stock_detail_"))
		if err != nil {
			sendTelegram(uid, "❌ 상품 ID가 올바르지 않습니다.")
			return
		}
		showAdminStockDetail(uid, chatID, msgID, productID)
		return
	}
	// 상품 수정
	if strings.HasPrefix(data, "admin_edit_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_edit_stock_"))
		promptEditProduct(uid, chatID, msgID, productID)
		return
	}
	// 상품 삭제
	if strings.HasPrefix(data, "admin_del_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_del_stock_"))
		showAdminStockDeleteMenu(uid, chatID, msgID, productID)
		return
	}
	// 신규 상품 추가 콜백
	if data == "add_product" {
		pendingEditProduct[uid] = 0 // 0번이면 신규
		sendTelegram(uid, "➕ 추가할 <b>상품명:가격</b>을 입력해 주세요!\n예: 신상품:9.99")
		bot.Send(tgbotapi.NewCallback(cb.ID, "상품 추가 대기중"))
		return
	}
	if data == "cancel_pending_add" {
		delete(pendingEditProduct, uid)
		delete(pendingStockInput, uid)
		sendTelegram(uid, "❌ 작업이 취소되었습니다.")
		showCategoryMenu(uid, chatID, 0)
		return
	}
	if strings.HasPrefix(data, "admin_add_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_add_stock_"))
		promptAddStock(uid, chatID, msgID, productID)
		return
	}
	if data == "support_close" {
		// 상담 세션 종료 (세션 map 등에서 제거)
		delete(activeSupportSessions, uid)
		sendTelegram(uid, "상담이 종료되었습니다. 언제든 다시 문의해 주세요.")
		// 관리자에게도 알림
		for _, adminID := range adminIDs {
			sendTelegram(int64(adminID), fmt.Sprintf("유저 %d의 상담이 종료되었습니다.", uid))
		}
		bot.Send(tgbotapi.NewCallback(cb.ID, "상담이 종료되었습니다."))
		return
	}
	if strings.HasPrefix(data, "admin_user_detail_") {
		userIDstr := strings.TrimPrefix(data, "admin_user_detail_")
		userID, _ := strconv.ParseInt(userIDstr, 10, 64)
		showAdminUserDetailMenu(chatID, msgID, userID)
		return
	}
	if data == "check_wallet" {
		wallet := getUserWallet(uid)
		if wallet == "" {
			sendTelegram(uid, "❌ 등록된 지갑이 없습니다.")
			return
		}
		sendTelegram(uid, fmt.Sprintf("지갑 주소: <code>%s</code>", wallet))
		if data == "admin_today_visitors" {
			showTodayVisitorsMenu(chatID, msgID)
			return
		}
		if data == "admin_all_visitors" {
			showAllVisitorsMenu(chatID, msgID)
			return
		}
		if data == "admin_all_users" {
			showAdminAllUsersMenu(chatID, msgID, 1) // page=1부터 시작
			return
		}
		if data == "admin_advanced" {
			showAdvancedAdminMenu(uid, chatID, msgID)
			return
		}
		if data == "admin_system_health" {
			showSystemHealthMenu(uid, chatID, msgID)
			return
		}

		// 직접입력(입금 custom)
		if data == "deposit_custom" {
			pendingDepositInput[uid] = true
			sendTelegram(uid, "원하는 USDT 금액을 숫자로 입력해 주세요 (예: 23.5)")
			bot.Send(tgbotapi.NewCallback(cb.ID, "직접입력 대기중"))
			return
		}

		if strings.HasPrefix(data, "deposit_amount_") {
			amountStr := strings.TrimPrefix(data, "deposit_amount_")
			amount, err := strconv.ParseFloat(amountStr, 64)
			if err != nil {
				sendTelegram(chatID, "❌ 금액 파싱 실패")
				return
			}
			pendingDepositInput[uid] = false // 혹시 직접입력 대기 중이라면 종료
			// 주문 생성 함수 호출 (예: createDepositOrder(uid, amount))
			err = createDepositOrder(uid, amount)
			if err != nil {
				sendTelegram(chatID, "❌ 충전 주문 생성 실패")
				return
			}
			sendTelegram(chatID, fmt.Sprintf("✅ %.2f USDT 충전 주문이 생성되었습니다.", amount))
			return
		}

		// 등급변경 콜백
		if strings.HasPrefix(data, "admin_set_grade_") {
			parts := strings.Split(data, "_")
			if len(parts) == 5 {
				grade := parts[3]
				targetUserID, err := strconv.ParseInt(parts[4], 10, 64)
				if err != nil {
					sendTelegram(chatID, "❌ 사용자 ID 파싱 실패")
					return
				}
				if !isValidGrade(grade) {
					sendTelegram(chatID, "❌ 허용되지 않은 등급입니다.")
					return
				}
				err = updateUserGrade(targetUserID, grade)
				if err != nil {
					sendTelegram(chatID, "❌ 등급 변경 실패")
				} else {
					sendTelegram(chatID, "✅ 등급이 변경되었습니다.")
					showAdminUserDetailMenu(chatID, msgID, targetUserID)
				}
				return
			}
		}
		if data == "go_catmenu" {
			showCategoryMenu(cb.From.ID, cb.Message.Chat.ID, cb.Message.MessageID)
			bot.Send(tgbotapi.NewCallback(cb.ID, "카테고리로 이동"))
			return
		}
		// "⬅️ 목록으로" 처리
		if data == "admin_user_list" {
			showAdminUserListMenu(uid, chatID, msgID)
			return
		}
		// ────────────────────── 2. switch-case(일반 콜백) ──────────────────────
		switch data {
		case "show_menu":
			// detail과 msg가 정의되어 있지 않은 문제 수정
			detail := "메뉴를 표시합니다." // detail에 적절한 값을 할당 (필요에 따라 수정)
			edit := tgbotapi.NewEditMessageText(cb.Message.Chat.ID, cb.Message.MessageID, detail)
			edit.ParseMode = "HTML"
			bot.Send(edit)
			showMenu(uid, username, chatID)
			return

		case "go_main":
			// 기존 메시지 삭제 (선택)
			bot.Send(tgbotapi.NewDeleteMessage(chatID, cb.Message.MessageID))
		
			// 메인 메뉴 표시
			showMenu(uid, cb.From.UserName, chatID)
		
			// 콜백 응답
			bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
			return

		case "support_request":
			// 상담 대기열에 등록 (예: activeSupportSessions 등 활용)
			pendingSupportQueue[uid] = time.Now()

			kb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("❌ 상담취소", "support_cancel"),
				),
			)
			msg := tgbotapi.NewMessage(chatID, "실시간 문의가 접수되었습니다.\n상담원이 곧 연락드립니다.")
			msg.ParseMode = "HTML"
			msg.ReplyMarkup = kb
			bot.Send(msg)
			bot.Send(tgbotapi.NewCallback(cb.ID, "고객센터 문의 접수"))

			// 관리자에게 상담 요청 알림
			for _, adminID := range adminIDs {
				adminKb := tgbotapi.NewInlineKeyboardMarkup(
					tgbotapi.NewInlineKeyboardRow(
						tgbotapi.NewInlineKeyboardButtonData("✅ 상담수락", fmt.Sprintf("support_accept_%d", uid)),
						tgbotapi.NewInlineKeyboardButtonData("❌ 거절", fmt.Sprintf("support_reject_%d", uid)),
					),
				)
				adminMsg := tgbotapi.NewMessage(int64(adminID),
					fmt.Sprintf("🆕 [상담 요청]\n유저: <code>%d</code>\n유저명: <b>%s</b>\n", uid, cb.From.UserName))
				adminMsg.ParseMode = "HTML"
				adminMsg.ReplyMarkup = adminKb
				bot.Send(adminMsg)
			}
			return
		case "support_cancel":
			// 대기열에서 제거
			delete(pendingSupportQueue, uid)
			sendTelegram(uid, "상담이 취소되었습니다. 언제든 다시 문의해 주세요.")
			bot.Request(tgbotapi.NewCallback(cb.ID, "상담 취소되었습니다."))
			return

		case "menu_help":
			kb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" 🪫 ENERGY ", "help_energy"),
					tgbotapi.NewInlineKeyboardButtonData(" 🆔 ACCOUNT ", "help_account"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" 👥 MEMBERS ", "help_membership"),
					tgbotapi.NewInlineKeyboardButtonData(" 📱 ESIM ", "help_esim"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" 🖥️  VPS/KVM ", "help_vps"),
					tgbotapi.NewInlineKeyboardButtonData(" 🔄 COINSWAP ", "help_swap"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" 🔙 ", "go_main"),
				),
			)
			edit := tgbotapi.NewEditMessageText(chatID, msgID, "ℹ️ 사용방법 안내 메세지 오류및 상담\n문의하기는  사항은 고객센터 실시간 문의로 연락주세요.")
			edit.ReplyMarkup = &kb
			edit.ParseMode = "HTML"
			bot.Send(edit)
			bot.Send(tgbotapi.NewCallback(callbackID, ""))
			return

		case "help_energy", "help_account", "help_membership", "help_esim", "help_card", "help_swap", "help_vps":
			showHelpMessage(uid, data)
			bot.Request(tgbotapi.NewCallback(cb.ID, ""))
			return

		// ───── 관리자 메뉴 및 하위메뉴 ─────
		case "admin_menu":
			if !isAdmin(uid) {
				sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "관리자 권한이 없습니다."))
				return
			}
			showAdminMenu(uid, chatID, msgID)
			return
		case "admin_inventory":
			// 1단계: 카테고리 메뉴부터 노출
			showAdminCategoryMenu(chatID, msgID)
			return
		case "admin_add_stock":
			handleAddStockCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
			return
		case "admin_stock_analytics":
			showStockAnalyticsMenu(uid, chatID, msgID)
			return
		case "admin_stock_list":
			showAdminStockList(chatID, msgID) // 변수명 msgID로 변경
			return
		case "admin_stock_delete":
			promptStockDeletion(chatID) // 재고 삭제 안내 함수
			return
		case "admin_stock":
			promptStockAddition(chatID) // 재고 추가 안내 함수
			return
		case "admin_stats":
			showAdminStatsMenu(uid, chatID, msgID)
			return
		case "admin_orders":
			showAdminOrderListMenu(uid, chatID, msgID)
			return
		case "admin_member_menu":
			showAdminUserListMenu(uid, chatID, msgID)
			return
		case "admin_advanced":
			showAdvancedAdminMenu(uid, chatID, msgID)
			return
		case "weekly_stats":
			showDetailedReportMenu(uid, chatID, msgID)
			return
		case "showAdminSettings":
			showAdminSettings(chatID, msgID, cb.ID)
			return
		case "admin_list_visitors_today":
			// 권한 체크 포함해서 방문자 오늘 목록 함수 호출
			uid := int64(cb.From.ID)
			if !isAdmin(uid) {
				sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
				return
			}
			handleAdminListVisitorsToday(uid)
			bot.Request(tgbotapi.NewCallback(cb.ID, "당일 방문자 목록 출력"))
			return

		case "admin_list_visitors":
			uid := int64(cb.From.ID)
			if !isAdmin(uid) {
				sendTelegram(uid, "❌ 관리자만 접근 가능합니다.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
				return
			}
			handleAdminListVisitors(uid)
			bot.Request(tgbotapi.NewCallback(cb.ID, "전체 방문자 목록 출력"))
			return
		case "admin_add":
			sendTelegram(uid, "👤 관리자 추가 기능은 준비 중입니다.")
			bot.Request(tgbotapi.NewCallback(cb.ID, "준비중입니다"))
			return

		// ───── 유저 일반 메뉴 ─────
		case "show_deposit_menu":
			sendDepositMenuNewMessage(uid)
			return
		case "balance_menu":
			showBalanceMenu(uid, chatID, 0)
			return
		case "show_energy":
			showEnergyMenu(uid, chatID, msgID)
			bot.Request(tgbotapi.NewCallback(cb.ID, "에너지 메뉴"))
			return
		default:
			// (여긴 원래는 아무 것도 두지 않는 것이 정석!)
			log.Printf("[handleCallback] 알 수 없는 콜백: %s", data)
			bot.Request(tgbotapi.NewCallback(cb.ID, "지원하지 않는 명령"))
		}
		if strings.HasPrefix(data, "del_stock_") {
			handleDeleteStockCategory(cb)
			return
		}

		if strings.HasPrefix(data, "confirm_del_") {
			handleConfirmDeleteStock(cb)
			return
		}
		if strings.HasPrefix(cb.Data, "menu_") || cb.Data == "go_main" {
			handleMenuCallback(cb)
			return
		}
		if strings.HasPrefix(data, "cardcat_") {
			categoryName := strings.TrimPrefix(data, "cardcat_") // ✅ 콜백에서 이름 추출
			showProductMenu(categoryName, chatID, msgID)          // ✅ 올바른 인자 전달
			return
		}

		if strings.HasPrefix(data, "prod_") {
			handleProductCallback(cb)
			return
		}

		if strings.HasPrefix(data, "pay_coin_") {
			orderIDStr := strings.TrimPrefix(data, "pay_coin_")     // "pay_coin_" 제거
			orderID64, err := strconv.ParseUint(orderIDStr, 10, 64) // 문자열 → uint64 변환
			if err != nil {
				sendTelegram(uid, "❌ 주문번호 파싱 실패")
				return
			}

			handleCoinPayment(cb, uid, chatID, orderID64) // 함수에 정확한 인자 전달
			bot.Request(tgbotapi.NewCallback(cb.ID, "코인 결제 처리 중"))
			return
		}
		if strings.HasPrefix(data, "pay_balance_") {
			orderIDStr := strings.TrimPrefix(data, "pay_balance_")
			orderID64, err := strconv.ParseUint(orderIDStr, 10, 64)
			if err != nil {
				sendTelegram(uid, "❌ 주문번호 파싱 실패")
				return
			}
			orderID := uint(orderID64)

			err = handleBalancePayment(orderID, uid)
			if err != nil {
				sendTelegram(uid, "❌ 잔액 결제 실패: "+err.Error())
			} else {
				sendTelegram(uid, "✅ 잔액 결제가 완료되었습니다.")
			}

			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "잔액 결제 처리 중")); err != nil {
				log.Printf("콜백 응답 실패: %v", err)
			}
			return
		}

		if strings.HasPrefix(data, "support_accept_") {
			targetUIDStr := strings.TrimPrefix(data, "support_accept_")
			targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
			if err != nil {
				sendTelegram(uid, "❌ 상담 대상자 ID 파싱 실패")
				return
			}

			activeSupportSessions[targetUID] = uid

			// 상담종료 버튼 키보드
			closeKb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("🔚 상담종료", fmt.Sprintf("support_close_%d", uid)),
				),
			)
			closeKb2 := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("🔚 상담종료", fmt.Sprintf("support_close_%d", targetUID)),
				),
			)

			// 유저에게 안내+상담종료 버튼
			msg := tgbotapi.NewMessage(targetUID, "✅ 상담원이 연결되었습니다! 궁금한 내용을 메시지로 보내주세요.\n\n상담이 끝나면 하단의 [상담종료] 버튼을 눌러주세요.")
			msg.ReplyMarkup = closeKb
			bot.Send(msg)

			// 상담원(관리자)에게 안내+상담종료 버튼
			adminMsg := tgbotapi.NewMessage(uid, "🙋‍♂️ 상담이 시작되었습니다. 유저에게 답변해 주세요.\n\n상담이 끝나면 [상담종료]를 꼭 눌러주세요.")
			adminMsg.ReplyMarkup = closeKb2
			bot.Send(adminMsg)

			// 상담 시작 콜백 응답
			bot.Request(tgbotapi.NewCallback(cb.ID, "상담이 시작되었습니다."))

			return
		}
	} // ✅ 이걸 붙여주셔야 오류 해결됩니다.
}

// 총 페이지 수 계산 함수 (10명 단위)
func getTotalVisitorPages() int {
	var total int64
	err := db.Model(&User{}).Count(&total).Error
	if err != nil || total == 0 {
		return 1
	}
	return int((total + 9) / 10) // 올림
}

// 방문자 목록 조회 함수 (페이징 포함)
func getVisitors(page, pageSize int) ([]User, int64, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	err := db.Order("last_seen DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&users).Error
	return users, total, err
}

func checkDepositMatch(senderAddress string, amount float64) (*Order, error) {
	var order Order
	err := db.Where("sender_address = ? AND status = ?", senderAddress, "pending").First(&order).Error
	if err != nil {
		return nil, err
	}
	return &order, nil
}

func formatVisitorList(users []User) string {
	var sb strings.Builder
	sb.WriteString("<b>👥 방문자 목록</b>\n━━━━━━━━━━━━━━━━━━━━━━\n\n")

	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "없음"
		} else {
			username = "@" + username
		}

		nickname := u.Nickname
		if nickname == "" {
			nickname = "이름 없음"
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> • <b>%s</b> • <i>%s</i>\n\n",
			i+1, u.UserID, nickname, username,
		))
	}

	sb.WriteString("━━━━━━━━━━━━━━━━━━━━━━\n")
	sb.WriteString("🔍 누군지 바로 알 수 있도록 닉네임과 아이디 표시\n")

	return sb.String()
}

// showHelpMessage 함수 (수정본)
func showHelpMessage(uid int64, data string) {
	switch data {
	case "help_account":
		msg := tgbotapi.NewMessage(uid,
			"🆔 <b>(ACCOUNT) 상품 안내</b>\n\n"+
				"결제 확인 후, <b>자동</b> 메세지로 지급됩니다.\n"+
				"<b>번호 | link</b> 형식으로 발송되며 로그인 🔜 link 🔜 2FA 확인\n"+
				"・<i>EX: <a href=\"https://t.me/EX_TGID\">짧은번호</a> 포커문의</i>\n"+
				"<i>PC 및 모바일 모두 가능합니다.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_account 전송 실패: %v", err)
		}

	case "help_membership":
		msg := tgbotapi.NewMessage(uid,
			"👥 <b>(MEMBERSHIP) 안내</b>\n\n"+
				"・ 결제 후 별도 등록 없이 <b>즉시 선물</b>로 전송됩니다.\n"+
				"・ 각 플랫폼 사용법은 메세지와 함께 안내됩니다.\n"+
				"・ <i>문의 사항은 고객센터로 연락 주세요.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_membership 전송 실패: %v", err)
		}

	case "help_esim":
		photoFile := "/home/minho/epusdt/images/esim_usage.jpeg" // 절대경로
		photoMsg := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(photoFile))
		photoMsg.Caption = "📱 <b>(E-SIM) 안내</b>\n\n" +
			"・ DATA ONLY, 5G/4G 걱정X\n" +
			"・ 결제 후 QR코드 정보가 자동 지급됩니다.\n" +
			"・ 위치 조회시 홍콩 홍콩번호 부여.\n"
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("help_esim 사진 전송 실패: %v", err)
			sendTelegram(uid, "❌ eSIM 안내 이미지 전송에 실패했습니다.")
		}

	case "help_energy":
		msgText := `<b>🪫 USDT 송금 수수료 80% 절감 🪫</b>
	
	💸 전송 1회당 수수료 최대 만원 절감
	
	📊 평균 테더 100회 송금 시 트론 소비량 비교
	
	🔹 일반 송금: 최소 1,800 ~ 2,800 TRX   
	🔹 에너지 송금: 최소 250 ~ 500 TRX
	
	<b>KRW 기준</b>
	일반송금 : 670,000 ~ 1,036,000
	에너지송금 : 92,500 ~ 185,000
	
	1회 전송에 필요한 에너지 = 65K 에너지
	
	65K 에너지 = 2.5 TRX (전송 1회)  
	예: 10 TRX = 260K 에너지 (3~4회)
	
	⏱ 전송한 주소로 5초 이내 에너지 할당 완료
	
	━━━━━━━━━━━━━━━
	
	⬇️ <b>결제 주소</b> ⬇️
	
	<b><code>TDFfEdkdkdkdososlsksospzkPn</code></b>
	
	⬆️ 주소 클릭 시 자동 복사 ⬆️
	
	━━━━━━━━━━━━━━━
	
	⏳ 에너지는 1시간 후 자동 소멸  
	⚠️ USDT가 없는 새 지갑으로 송금 시  
	130K 에너지(5 TRX) 발생 가능  
	송금 전 수수료 꼭 확인`

		msg := tgbotapi.NewMessage(uid, msgText)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_energy 전송 실패: %v", err)
		}

	case "help_card":
		msg := tgbotapi.NewMessage(uid,
			"💳 <b>(CARD) 결제 안내</b>\n\n"+
				"・ 대리 및 VPN 결제가 가능합니다.\n"+
				"・ 구매 후 ‘고객센터' 버튼을 눌러 문의해 주세요.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_card 전송 실패: %v", err)
		}

	case "help_swap":
		msg := tgbotapi.NewMessage(uid,
			"🔄 <b>스왑 안내</b>\n\n"+
				"코인 스왑 잠시 점검 중입니다.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_swap 전송 실패: %v", err)
		}

	case "help_vps":
		msg := tgbotapi.NewMessage(uid,
			"🖥️ <b>VPS/KVM 안내</b>\n\n"+
				"여러 가지 VPS 및 KVM 서버 옵션을 제공합니다.\n"+
				"더 자세한 내용은 제품 목록에서 확인하세요.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_vps 전송 실패: %v", err)
		}

	default:
		msg := tgbotapi.NewMessage(uid,
			"❓ 해당 도움말이 존재하지 않습니다.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_default 전송 실패: %v", err)
		}
	}
}

func handleBalancePayment(orderID uint, userID int64) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("주문 조회 실패: %w", err)
	}

	if order.Status != "입금대기중" {
		return fmt.Errorf("잘못된 주문 상태: %s", order.Status)
	}

	balance, err := getUserBalance(userID)
	if err != nil {
		return fmt.Errorf("잔액 조회 실패: %w", err)
	}
	if balance < order.Amount {
		return fmt.Errorf("잔액 부족 (보유: %.2f, 필요: %.2f)", balance, order.Amount)
	}

	// 트랜잭션 처리 권장 (아래는 단순 예시)
	if err := deductBalance(userID, order.Amount); err != nil {
		return fmt.Errorf("잔액 차감 실패: %w", err)
	}

	order.Status = "완료"
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("주문 상태 저장 실패: %w", err)
	}

	// 관리자 알림
	adminChatID := getAdminChatID()
	adminMsg := fmt.Sprintf(
		"💳 잔액 결제 완료\n주문번호: %d\n사용자ID: %d\n금액: %.2f USDT",
		order.ID, userID, order.Amount)
	if _, err := bot.Send(tgbotapi.NewMessage(adminChatID, adminMsg)); err != nil {
		log.Printf("관리자 알림 실패: %v", err)
	}

	// 유저 알림
	sendTelegram(userID, fmt.Sprintf(
		"✅ 잔액 결제가 완료되었습니다.\n주문번호: %d\n금액: %.2f USDT",
		order.ID, order.Amount,
	))

	return nil
}

func handleMenuCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleMenuCallback] cb.Data: %s", cb.Data)
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	switch cb.Data {
	case "menu_products":
		showCategoryMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "🛒 상품 목록을 불러옵니다"))
		return

	case "menu_vps":
		showVPSMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "💻 VPS 목록"))
		return

	case "menu_swap":
		showSwapMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "🔄 코인 교환"))
		return

	case "menu_help":
		showFAQMenu(chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ℹ️ 도움말"))
		return

	case "admin_monthly_report":
		handleAdminMonthlyReport(uid, chatID, messageID, cb.ID)
		return

	case "admin_yearly_report":
		handleAdminYearlyReport(uid, chatID, messageID, cb.ID)
		return

	case "go_main":
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "메인 메뉴로 이동"))
		return

	default:
		log.Printf("[handleMenuCallback] 알 수 없는 메뉴: %s", cb.Data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "❓ 알 수 없는 메뉴입니다"))
		return
	}
}

func getStockCount(productName string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).
		Where("name = ? AND used = ?", productName, false).
		Count(&count).Error
	if err != nil {
		return 0, err
	}
	return count, nil
}

func showFAQMenu(chatID int64, messageID int) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📌 이용방법", "faq_usage"),
			tgbotapi.NewInlineKeyboardButtonData("💳 결제문의", "faq_payment"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 메인으로", "go_main"),
		),
	)

	msgText := "<b>📖 자주 묻는 질문 (FAQ)</b>\n\n" +
		"궁금한 내용을 선택하세요."

	edit := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, kb)
	edit.ParseMode = "HTML"
	if _, err := bot.Send(edit); err != nil {
		log.Printf("showFAQMenu 전송 실패: %v", err)
	}
}

func showSwapMenu(uid, chatID int64, messageID int) {
	swapPairs := []struct {
		display string
		data    string
	}{
		{"USDT → TRX", "swap_usdt_trx"},
		{"TRX → USDT", "swap_trx_usdt"},
		{"USDT → ETH", "swap_usdt_eth"},
		{"ETH → USDT", "swap_eth_usdt"},
		{"USDT → SOL", "swap_usdt_sol"},
		{"SOL → USDT", "swap_sol_usdt"},
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(swapPairs); i += 2 {
		var row []tgbotapi.InlineKeyboardButton
		row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i].display, swapPairs[i].data))
		if i+1 < len(swapPairs) {
			row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i+1].display, swapPairs[i+1].data))
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// 마지막 한 줄은 메뉴로 가기 버튼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("🔙", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "🔄 코인 스왑 메뉴\n 변경할 코인을 선택하세요.[점검]")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showSwapMenu 메시지 전송 실패: %v", err)
	}
}

func handleCategoryCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	category := strings.TrimPrefix(cb.Data, "cardcat_")
	showProductMenu(category, chatID, messageID)
}

// 상품 콜백 처리
func handleProductCallback(cb *tgbotapi.CallbackQuery) {
	data := cb.Data // 예: "prod_vps1"
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID

	code := strings.TrimPrefix(data, "prod_")

	for _, category := range cardCategories {
		for name, prod := range category {
			if prod.Code == code {
				text := fmt.Sprintf("<b>%s</b>\n\n%s\n\n💰 가격: %.2f USDT", name, prod.Description, prod.Price)
				edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
				edit.ParseMode = "HTML"
				bot.Send(edit)

				// 확인 버튼 보여주기
				showOrderConfirmButtons(cb, code)
				return
			}
		}
	}

	bot.Send(tgbotapi.NewMessage(chatID, "❌ 상품을 찾을 수 없습니다."))
}

func handleGoMainCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	uid := int64(cb.From.ID)
	username := cb.From.UserName

	showMenu(uid, username, chatID)

	// 콜백 쿼리 응답
	callback := tgbotapi.NewCallback(cb.ID, "메인으로 이동합니다.")
	if _, err := bot.Request(callback); err != nil {
		log.Printf("Callback 응답 실패: %v", err)
	}
}

func showOrderConfirmButtons(cb *tgbotapi.CallbackQuery, productCode string) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	var prodName string
	var price float64
	found := false

	// VPS 상품인지 먼저 체크
	if vpsProd, ok := vpsProductMap[productCode]; ok {
		prodName = vpsProd.Name
		price = vpsProd.Price
		found = true
	} else {
		// 일반 카드 상품에서 찾기
		for _, products := range cardCategories {
			for _, prod := range products {
				if prod.Code == productCode {
					prodName = prod.Name
					price = prod.Price
					found = true
					break
				}
			}
			if found {
				break
			}
		}
	}

	if !found {
		sendTelegram(uid, "❌ 해당 상품을 찾을 수 없습니다.")
		callback := tgbotapi.NewCallback(cb.ID, "상품 정보 없음")
		bot.Request(callback)
		return
	}

	// 주문 생성
	order, err := createOrder(uid, prodName, price)
	if err != nil {
		sendTelegram(uid, "❌ 주문 생성 실패: "+err.Error())
		return
	}

	// 메시지 텍스트 구성
	msgText := fmt.Sprintf(
		"<b>━━━━━━━━━━━━━━━━</b>\n"+
			"🛒 <b>%s</b>\n"+
			"💰 가격: <b>%.3f USDT</b>\n"+
			"<b>━━━━━━━━━━━━━━━━</b>\n\n"+
			"<b>결제수단을 선택해 주세요.</b>\n",
		prodName, price,
	)

	// 인라인 버튼 구성
	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("💸 코인 결제", fmt.Sprintf("pay_coin_%d", order.ID)),
			tgbotapi.NewInlineKeyboardButtonData("🏦 잔액 결제", fmt.Sprintf("pay_balance_%d", order.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 돌아가기", "go_main"),
		),
	)

	// 메시지 수정 및 전송
	edt := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, markup)
	edt.ParseMode = "HTML"
	if _, err := bot.Send(edt); err != nil {
		log.Printf("❌ 주문 확인 버튼 표시 실패: %v", err)
	}
}

func main() {
	initDB()
	migrateDB()

	// VPS 상품 등록 (중복 등록 체크 필요)
	if err := addVPSProducts(); err != nil {
		log.Fatalf("VPS 상품 등록 실패: %v", err)
	}

	log.SetFlags(log.LstdFlags | log.Lshortfile)
	rand.Seed(time.Now().UnixNano())
	log.Println("🚀 EPUSDT 봇 시작 중...")

	startTime := time.Now()

	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		log.Fatal("❌ TELEGRAM_BOT_TOKEN 환경변수가 설정되지 않았습니다.")
	}
	log.Printf("🔍 로드된 토큰: %s", token)

	startDepositMonitoring()

	var err error
	bot, err = initBotWithWebhook()
	if err != nil {
		log.Fatalf("❌ 봇 초기화 실패: %v", err)
	}
	log.Println("✅ 봇 초기화 완료")

	router := gin.Default()
	router.SetTrustedProxies(nil)

	router.POST("/webhook", handleWebhook)
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok", "uptime": time.Since(startTime).String()})
	})

	log.Println("🌐 서버를 9020 포트에서 시작합니다...")
	if err := router.Run(":9020"); err != nil {
		log.Fatalf("❌ 서버 실행 실패: %v", err)
	}
}

// 문자열 포인터 생성 함수
func ptr(s string) *string {
	return &s
}

func createOrder(uid int64, prodName string, price float64) (*Order, error) {
	emptyTxID := "" // 빈 문자열 변수 선언
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "입금대기중",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        &emptyTxID, // 빈 문자열 포인터 전달
	}
	if err := db.Create(&order).Error; err != nil {
		return nil, err
	}
	return &order, nil
}

func confirmDeposit(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return err
	}

	// 주문 상태 업데이트
	order.Status = "입금확인"
	txIDCopy := txID
	order.TxID = &txIDCopy

	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// 카드 자동 지급 부분 제거됨
	// 카드 정보 업데이트는 필요에 따라 직접 처리하세요
	// 예를 들어, 카드 정보 없이 상태만 완료 처리할 경우:

	order.Status = "완료"
	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// 사용자에게 알림 (에러 로그만 남기고 리턴은 안함)
	if err := sendTelegram(order.UserID, fmt.Sprintf("✅ 주문이 완료되었습니다!\n\n상품: %s\n", order.Product)); err != nil {
		log.Printf("사용자 알림 전송 실패: %v", err)
	}

	return nil
}

// 잔액 확인
func getUserBalance(userID int64) (float64, error) {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// 잔액이 없으면 0으로 초기화
			balance = UserBalance{UserID: userID, Balance: 0}
			db.Create(&balance)
			return 0, nil
		}
		return 0, err
	}
	return balance.Balance, nil
}

// 잔액 차감
func deductBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		return err
	}

	if balance.Balance < amount {
		return fmt.Errorf("잔액 부족")
	}

	balance.Balance -= amount
	return db.Save(&balance).Error
}

// 잔액 추가
func addBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance = UserBalance{UserID: userID, Balance: amount}
			return db.Create(&balance).Error
		}
		return err
	}

	balance.Balance += amount
	return db.Save(&balance).Error
}

// 주문 내역 조회
func getUserOrders(userID int64) ([]Order, error) {
	var orders []Order
	err := db.Where("user_id = ?", userID).Order("timestamp desc").Find(&orders).Error
	return orders, err
}

// 주문 상태 업데이트
func updateOrderStatus(orderID uint, status string) error {
	return db.Model(&Order{}).Where("id = ?", orderID).Update("status", status).Error
}

// 카드 재고 확인
func getCardStock(category string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).Where("category = ? AND used = ?", category, false).Count(&count).Error
	return count, err
}

// 사용된 카드 조회
func getUsedCards(userID int64) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("used_by = ?", userID).Find(&cards).Error
	return cards, err
}

// 통계 데이터 조회
func updateDailyStats(amount float64) error {
	today := time.Now().Format("2006-01-02")

	var stats SalesStats
	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: amount, TotalCount: 1, Count: 1, SalesCount: 1}
			return db.Create(&stats).Error
		}
		return err
	}

	stats.TotalSales += amount
	stats.TotalCount++
	stats.Count++
	stats.SalesCount++

	return db.Save(&stats).Error
}

func handleCreateTransaction(c *gin.Context) {
	var req struct {
		UserID      int64   `json:"user_id"`
		ProductCode string  `json:"product_code"`
		Amount      float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "잘못된 요청"})
		return
	}

	// 주문 생성
	order, err := createOrder(req.UserID, req.ProductCode, req.Amount)
	if err != nil {
		c.JSON(500, gin.H{"error": "주문 생성 실패"})
		return
	}

	// 지갑 주소 생성
	walletAddress, err := generateWalletAddress()
	if err != nil {
		c.JSON(500, gin.H{"error": "지갑 생성 실패"})
		return
	}

	c.JSON(200, gin.H{
		"order_id": order.ID,
		"address":  walletAddress,
		"amount":   req.Amount,
	})
}

func showAdminStockMenu(uid, chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	text := "📦 재고 현황\n\n"
	totalStock := int64(0)

	for _, category := range categories {
		count, err := getCardStock(category)
		if err != nil {
			text += fmt.Sprintf("❌ %s: 조회 실패\n", category)
		} else {
			text += fmt.Sprintf("✅ %s: %d개\n", category, count)
			totalStock += count
		}
	}

	text += fmt.Sprintf("\n📊 총 재고: %d개", totalStock)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📋 상세보기", "admin_stock_detail"),
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", "admin_add_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🗑️ 재고삭제", "admin_del_stock"),
			tgbotapi.NewInlineKeyboardButtonData("📊 분석", "admin_stock_analytics"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자메뉴", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("관리자 재고 메뉴 수정 실패: %v", err)
	}
}

func createProductManagementKeyboard(productID int, productName string, price float64) tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s %.2fUSDT", productName, price), fmt.Sprintf("product_detail_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("📝 수정", fmt.Sprintf("product_edit_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("🗑️ 삭제", fmt.Sprintf("product_delete_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("📦 재고", fmt.Sprintf("product_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("➕ 재고추가", fmt.Sprintf("product_add_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 관리자메뉴로", "admin_menu"),
		),
	)
}

func showProductListForCategory(uid, chatID int64, messageID int, category string) {
	products, err := getProductsByCategory(category) // DB에서 상품 리스트 조회 함수 예시
	if err != nil {
		sendTelegram(uid, "❌ 상품 목록 조회 실패")
		return
	}

	text := fmt.Sprintf("📋 %s 상품 목록\n\n", category)
	for i, p := range products {
		text += fmt.Sprintf("%d. %s - %.2f USDT\n", i+1, p.Name, p.Price)
	}

	// 개별 상품별 버튼을 InlineKeyboard에 담기
	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		kb := createProductManagementKeyboard(int(p.ID), p.Name, p.Price) // p로 수정
		for _, row := range kb.InlineKeyboard {
			keyboardRows = append(keyboardRows, row)
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: keyboardRows}
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("상품 리스트 전송 실패: %v", err)
	}
}

func getProductsByCategory(category string) ([]Product, error) {
	var products []Product
	err := db.Where("category = ?", category).Find(&products).Error
	if err != nil {
		return nil, err
	}
	return products, nil
}

func showAdminStatsMenu(uid, chatID int64, messageID int) {
	// 일일 통계 조회
	stats, err := getDailyStatsNew()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 통계 조회 실패")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("📊 일일 통계 (%s)\n\n", stats.Date)
	text += fmt.Sprintf("총 매출: %.4f USDT\n", stats.TotalSales)
	text += fmt.Sprintf("총 주문: %d건\n", stats.TotalCount)
	text += fmt.Sprintf("완료 주문: %d건\n", stats.SalesCount)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "주간 통계", CallbackData: ptr("admin_weekly_stats")}},
			{{Text: "월간 통계", CallbackData: ptr("admin_monthly_stats")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

func showAdminUserListMenu(uid, chatID int64, messageID int) {
	// 유저 목록 조회 (최근 10명)
	users, err := getRecentUsers(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 유저 목록 조회 실패")
		bot.Request(msg)
		return
	}

	text := "👥 최근 가입 유저 (10명)\n\n"
	var rows [][]tgbotapi.InlineKeyboardButton

	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(닉네임없음)"
		}
		userName := user.UserName
		if userName == "" {
			userName = "없음"
		}
		text += fmt.Sprintf(
			"%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1, nickname, user.UserID, userName, user.LastSeen.Format("01-02 15:04"),
		)
		// 버튼에도 닉네임 표시
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s", nickname),
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// 하단 고정 버튼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("전체 유저", "admin_all_users"),
	))
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Request(msg)
}

func getUserByUserID(userID int64) (*User, error) {
	var user User
	result := db.Where("user_id = ?", userID).First(&user)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

func showAdminUserDetailMenu(chatID int64, messageID int, userID int64) {
	user, err := getUserByUserID(userID)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 유저 정보 조회 실패")
		bot.Request(msg)
		return
	}

	// 등급 이모지만
	emoji := getGradeEmoji(user.Grade)

	text := fmt.Sprintf(
		"👤 <b>유저 정보</b>\n\n"+
			"• <b>고유번호</b>: <code>%d</code>\n"+
			"• <b>유저네임</b>: <b>%s</b>\n"+
			"• <b>등급</b>: %s\n"+
			"• <b>최근접속</b>: <code>%s</code>",
		user.UserID,
		func() string {
			if user.UserName == "" {
				return "unknown"
			}
			return "@" + user.UserName
		}(),
		emoji, user.LastSeen.Format("2006-01-02 15:04"),
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🥉", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥈", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("🥇", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("💎", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("👑", fmt.Sprintf("admin_set_grade_vip_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 돌아가기", "admin_user_list"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

func showAdminOrderListMenu(uid, chatID int64, messageID int) {
	// 최근 주문 내역 조회
	orders, err := getRecentOrders(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 주문 내역 조회 실패")
		bot.Request(msg)
		return
	}

	text := "📋 최근 주문 내역 (10건)\n\n"
	for i, order := range orders {
		text += fmt.Sprintf("%d. %s - %.4f USDT - %s\n",
			i+1, order.Product, order.Amount, order.Status)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "전체 주문", CallbackData: ptr("admin_all_orders")}},
			{{Text: "미처리 주문", CallbackData: ptr("admin_pending_orders")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 유틸리티 함수들
func getRecentUsers(limit int) ([]User, error) {
	var users []User
	err := db.Order("joined_at desc").Limit(limit).Find(&users).Error
	return users, err
}

func getRecentOrders(limit int) ([]Order, error) {
	var orders []Order
	err := db.Order("timestamp desc").Limit(limit).Find(&orders).Error
	return orders, err
}

func getPendingOrders() ([]Order, error) {
	var orders []Order
	err := db.Where("status = ?", "입금대기중").Find(&orders).Error
	return orders, err
}

func getSumAmountBetweenDatesAndCategory(start, end, categoryLike string) (float64, error) {
	var total sql.NullFloat64
	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		start, end, categoryLike+"%",
	).Scan(&total).Error
	if err != nil {
		return 0, err
	}
	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULL인 경우 0 반환
}

// 예: 주간 매출 통계 함수 내에서 호출 예시
func getWeeklySalesByCategory() (map[string]float64, error) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}
	start := time.Now().AddDate(0, 0, -7).Format("2006-01-02")
	end := time.Now().Format("2006-01-02")

	results := make(map[string]float64)
	for _, cat := range categories {
		sum, err := getSumAmountBetweenDatesAndCategory(start, end, cat)
		if err != nil {
			log.Printf("카테고리 %s 매출 조회 실패: %v", cat, err)
			continue
		}
		results[cat] = sum
	}
	return results, nil
}

// 주간/월간 통계
func getWeeklyStats() (SalesStats, error) {
	weekStart := time.Now().AddDate(0, 0, -7).Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date >= ?", weekStart).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: weekStart, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func getMonthlyStats() (SalesStats, error) {
	monthStart := time.Now().AddDate(0, -1, 0).Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date >= ?", monthStart).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: monthStart, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

// 카드 재고 관리
func addCardStock(category, name, content string) error {
	card := StockCard{
		Category:  category,
		Name:      name,
		Content:   content,
		Used:      false,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	return db.Create(&card).Error // ★ 수정!
}

func deleteCardStock(cardID uint) error {
	return db.Delete(&StockCard{}, cardID).Error
}

func getCardStockByCategory(category string) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("category = ?", category).Find(&cards).Error
	return cards, err
}

// 사용자 활동 로그
func logUserActivity(userID int64, action string) error {
	log := UserActivityLog{
		UserID:     userID,
		LastActive: time.Now(),
	}
	return db.Create(&log).Error
}

// 시스템 상태 체크
func checkSystemHealth() map[string]interface{} {
	health := make(map[string]interface{})

	// DB 연결 상태
	sqlDB, err := db.DB()
	if err != nil {
		health["database"] = "error"
	} else if err = sqlDB.Ping(); err != nil {
		health["database"] = "error"
	} else {
		health["database"] = "ok"
	}

	// 봇 상태
	if bot != nil {
		health["bot"] = "ok"
	} else {
		health["bot"] = "error"
	}

	// 메모리 사용량
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	health["memory_mb"] = float64(m.Alloc) / 1024 / 1024

	// 업타임
	health["uptime"] = time.Since(startTime).String()

	return health
}

// 환경 설정 관리
func updateBotSettings(setting string, value string) error {
	// 설정 업데이트 로직
	log.Printf("설정 업데이트: %s = %s", setting, value)
	return nil
}

func getBotSettings() map[string]string {
	settings := make(map[string]string)
	settings["webhook_url"] = os.Getenv("WEBHOOK_URL")
	settings["tron_api_key"] = os.Getenv("TRON_API_KEY")
	settings["admin_user_id"] = os.Getenv("ADMIN_USER_ID")
	return settings
}

// 로그 관리
func getSystemLogs(limit int) ([]string, error) {
	// 시스템 로그 조회 로직
	logs := []string{
		"2025-06-29 21:14:15 [INFO] 봇 시작됨",
		"2025-06-29 21:14:16 [INFO] DB 연결 성공",
		"2025-06-29 21:14:17 [INFO] 웹훅 설정 완료",
	}
	return logs, nil
}

func clearSystemLogs() error {
	// 시스템 로그 정리 로직
	log.Println("시스템 로그 정리 완료")
	return nil
}

// 고급 관리자 기능들
func showAdvancedAdminMenu(uid, chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "🔧 고급 관리자 메뉴\n\n시스템 관리 및 고급 기능을 선택하세요.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "시스템 상태", CallbackData: ptr("admin_system_health")}},
			{{Text: "로그 관리", CallbackData: ptr("admin_logs")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 시스템 상태 체크 메뉴
func showSystemHealthMenu(uid, chatID int64, messageID int) {
	health := checkSystemHealth()

	text := "🔍 시스템 상태\n\n"
	text += fmt.Sprintf("데이터베이스: %s\n", health["database"])
	text += fmt.Sprintf("봇 상태: %s\n", health["bot"])
	text += fmt.Sprintf("메모리 사용량: %.2f MB\n", health["memory_mb"])
	text += fmt.Sprintf("업타임: %s\n", health["uptime"])

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "새로고침", CallbackData: ptr("admin_refresh_health")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 로그 관리 메뉴
func showLogsMenu(uid, chatID int64, messageID int) {
	logs, err := getSystemLogs(5)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 로그 조회 실패")
		bot.Request(msg)
		return
	}

	text := "📋 최근 시스템 로그 (5건)\n\n"
	for _, log := range logs {
		text += log + "\n"
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "로그 정리", CallbackData: ptr("admin_clear_logs")}},
			{{Text: "전체 로그", CallbackData: ptr("admin_all_logs")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// 재고 조회 및 사용 가능한 카드 내용 반환 함수
func getCardStockAndContent(productName string) (int64, string, error) {
	var card StockCard
	count, err := getStockCount(productName)
	if err != nil {
		return 0, "", err
	}
	if count == 0 {
		return 0, "", nil
	}

	// 재고 중 하나의 카드 내용을 가져옴
	err = db.Where("name = ? AND used = ?", productName, false).First(&card).Error
	if err != nil {
		return count, "", err
	}

	return count, card.Content, nil
}

func processOrderWithValidation(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("주문 조회 실패: %w", err)
	}

	if order.Status != "입금대기중" && order.Status != "결제완료" {
		return fmt.Errorf("주문 상태가 올바르지 않습니다: %s", order.Status)
	}

	stock, cardContent, err := getCardStockAndContent(order.Product)
	if err != nil {
		return fmt.Errorf("재고 조회 실패: %w", err)
	}
	if stock <= 0 {
		order.Status = "재고없음"
		if err := db.Save(&order).Error; err != nil {
			return fmt.Errorf("재고 부족 상태 저장 실패: %w", err)
		}
		sendTelegram(order.UserID, "❌ 주문하신 상품의 재고가 부족합니다. 관리자에게 문의해 주세요.")
		return fmt.Errorf("상품 재고 부족: %s", order.Product)
	}

	err = db.Model(&StockCard{}).
		Where("name = ? AND used = 0", order.Product).
		Limit(1).
		Updates(map[string]interface{}{
			"used":     true,
			"used_by":  order.UserID,
			"order_id": order.ID,
		}).Error
	if err != nil {
		return fmt.Errorf("재고 카드 사용 처리 실패: %w", err)
	}

	txIDCopy := txID
	order.CardInfo = cardContent
	order.Status = "완료"
	order.TxID = &txIDCopy
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("주문 상태 저장 실패: %w", err)
	}

	if err := updateDailyStats(order.Amount); err != nil {
		log.Printf("통계 업데이트 실패: %v", err)
	}

	notifyMsg := fmt.Sprintf(
		"주문이 완료되었습니다\n\n상품명: %s\n상품 정보:\n%s\n\n 오류시 문의주세요.",
		order.Product, cardContent,
	)
	sendTelegram(order.UserID, notifyMsg)

	return nil
}

func sendOrderCompletionNotification(userID int64, product, cardContent string) {
	text := fmt.Sprintf(
		"🎁 *상품 지급 완료!*\n\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"+
			"📦 **상품명**: %s\n"+
			"🎫 **카드정보**:\n`%s`\n"+
			"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"+
			"✅ 주문이 성공적으로 완료되었습니다!\n"+
			"🙏 이용해 주셔서 감사합니다.\n\n"+
			"💡 문의사항이 있으시면 고객센터를 이용해주세요.",
		product, cardContent,
	)
	sendTelegram(userID, text)
}

// 고급 통계 및 리포트 기능들
func generateDetailedReport(startDate, endDate string) (map[string]interface{}, error) {
	report := make(map[string]interface{})

	var result struct {
		TotalSales  float64
		TotalOrders int64
	}

	// 기간별 총 매출 및 주문 수
	err := db.Model(&Order{}).
		Where("timestamp BETWEEN ? AND ?", startDate, endDate).
		Select("COALESCE(SUM(amount), 0) as total_sales, COUNT(*) as total_orders").
		Scan(&result).Error
	if err != nil {
		return nil, err
	}

	var completedOrders int64
	err = db.Model(&Order{}).
		Where("timestamp BETWEEN ? AND ? AND status = ?", startDate, endDate, "완료").
		Count(&completedOrders).Error
	if err != nil {
		return nil, err
	}

	categorySales := make(map[string]float64)
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	for _, category := range categories {
		var sales sql.NullFloat64
		err := db.Model(&Order{}).
			Where("timestamp BETWEEN ? AND ? AND product LIKE ?", startDate, endDate, category+"%").
			Select("SUM(amount)").
			Scan(&sales).Error
		if err != nil {
			return nil, err
		}
		if sales.Valid {
			categorySales[category] = sales.Float64
		} else {
			categorySales[category] = 0
		}
	}

	var newUsers int64
	err = db.Model(&User{}).
		Where("last_seen BETWEEN ? AND ?", startDate, endDate).
		Count(&newUsers).Error
	if err != nil {
		return nil, err
	}

	completionRate := 0.0
	if result.TotalOrders > 0 {
		completionRate = float64(completedOrders) / float64(result.TotalOrders) * 100
	}

	report["period"] = fmt.Sprintf("%s ~ %s", startDate, endDate)
	report["total_sales"] = result.TotalSales
	report["total_orders"] = result.TotalOrders
	report["completed_orders"] = completedOrders
	report["completion_rate"] = completionRate
	report["category_sales"] = categorySales
	report["new_users"] = newUsers

	return report, nil
}

func showDetailedReportMenu(uid, chatID int64, messageID int) {
	endDate := time.Now().Format("2006-01-02")
	startDate := time.Now().AddDate(0, 0, -7).Format("2006-01-02")

	report, err := generateDetailedReport(startDate, endDate)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 리포트 생성 실패")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("📊 상세 리포트 (%s)\n\n", report["period"])
	text += fmt.Sprintf("총 매출: %.4f USDT\n", report["total_sales"])
	text += fmt.Sprintf("총 주문: %d건\n", report["total_orders"])
	text += fmt.Sprintf("완료 주문: %d건\n", report["completed_orders"])
	text += fmt.Sprintf("완료율: %.1f%%\n", report["completion_rate"])
	text += fmt.Sprintf("신규 유저: %d명\n", report["new_users"])

	text += "\n📈 카테고리별 매출:\n"
	categorySales, ok := report["category_sales"].(map[string]float64)
	if ok {
		for category, sales := range categorySales {
			if sales > 0 {
				text += fmt.Sprintf("%s: %.4f USDT\n", category, sales)
			}
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "월간 리포트", CallbackData: ptr("admin_monthly_report")}},
			{{Text: "연간 리포트", CallbackData: ptr("admin_yearly_report")}},
			{{Text: "🔙", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

func validateAdminAccess(userID int64) bool {
	adminUserIDStr := os.Getenv("ADMIN_USER_ID")
	if adminUserIDStr == "" {
		return false
	}

	adminUserID, err := strconv.ParseInt(adminUserIDStr, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID 변환 실패: %v", err)
		return false
	}

	return userID == adminUserID
}

func logAdminAction(userID int64, action string) {
	log.Printf("[ADMIN] User %d performed action: %s", userID, action)
}

// 상품 코드 유효성 검사 함수
func validateProductCode(productCode string) error {
	validProducts := getAllValidProductCodes()
	for _, valid := range validProducts {
		if productCode == valid {
			return nil
		}
	}
	return fmt.Errorf("유효하지 않은 상품 코드: %s", productCode)
}

func getAllValidProductCodes() []string {
	codes := []string{}
	for _, products := range cardCategories {
		for _, prod := range products {
			codes = append(codes, prod.Code)
		}
	}
	return codes
}

// 알림 및 모니터링 기능들
func sendSystemAlert(message string) {
	adminUserID := os.Getenv("ADMIN_USER_ID")
	if adminUserID == "" {
		return
	}

	adminID, err := strconv.ParseInt(adminUserID, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID 변환 실패: %v", err)
		return
	}

	if err := sendTelegram(adminID, "🚨 시스템 알림: "+message); err != nil {
		log.Printf("시스템 알림 전송 실패: %v", err)
	}
}

func monitorSystemHealth() {
	ticker := time.NewTicker(5 * time.Minute)
	go func() {
		for range ticker.C {
			health := checkSystemHealth()

			// 데이터베이스 상태 체크
			if health["database"] != "ok" {
				sendSystemAlert("데이터베이스 연결 오류")
			}

			// 메모리 사용량 체크
			memoryMB := health["memory_mb"].(float64)
			if memoryMB > 500 {
				sendSystemAlert(fmt.Sprintf("메모리 사용량 높음: %.2f MB", memoryMB))
			}
		}
	}()
}

// 고급 사용자 관리 기능들
func getUserDetailedInfo(userID int64) (map[string]interface{}, error) {
	info := make(map[string]interface{})

	// 사용자 기본 정보
	var user User
	err := db.Where("user_id = ?", userID).First(&user).Error
	if err != nil {
		return nil, err
	}

	// 주문 내역
	orders, err := getUserOrders(userID)
	if err != nil {
		return nil, err
	}

	// 잔액 정보
	balance, err := getUserBalance(userID)
	if err != nil {
		return nil, err
	}

	// 사용된 카드
	cards, err := getUsedCards(userID)
	if err != nil {
		return nil, err
	}

	info["user"] = user
	info["orders"] = orders
	info["balance"] = balance
	info["used_cards"] = cards
	info["total_spent"] = calculateTotalSpent(orders)
	info["order_count"] = len(orders)

	return info, nil
}

func calculateTotalSpent(orders []Order) float64 {
	total := 0.0
	for _, order := range orders {
		if order.Status == "완료" {
			total += order.Amount
		}
	}
	return total
}

// 고급 재고 관리 기능들
func getStockAnalytics() (map[string]interface{}, error) {
	analytics := make(map[string]interface{})

	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}

	for _, category := range categories {
		// 총 재고
		var totalStock int64
		db.Model(&StockCard{}).Where("category = ?", category).Count(&totalStock)

		// 사용된 재고
		var usedStock int64
		db.Model(&StockCard{}).Where("category = ? AND used = ?", category, true).Count(&usedStock)

		// 사용 가능한 재고
		availableStock := totalStock - usedStock

		// 사용률
		usageRate := 0.0
		if totalStock > 0 {
			usageRate = float64(usedStock) / float64(totalStock) * 100
		}

		analytics[category] = map[string]interface{}{
			"total":      totalStock,
			"used":       usedStock,
			"available":  availableStock,
			"usage_rate": usageRate,
		}
	}

	return analytics, nil
}

func showStockAnalyticsMenu(uid, chatID int64, messageID int) {
	analytics, err := getStockAnalytics()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "❌ 재고 분석 실패")
		bot.Request(msg)
		return
	}

	text := "📊 재고 분석\n\n"

	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	for _, category := range categories {
		if data, ok := analytics[category].(map[string]interface{}); ok {
			text += fmt.Sprintf("%s:\n", category)
			text += fmt.Sprintf("  총 재고: %d개\n", int(data["total"].(int64)))
			text += fmt.Sprintf("  사용됨: %d개\n", int(data["used"].(int64)))
			text += fmt.Sprintf("  사용가능: %d개\n", int(data["available"].(int64)))
			text += fmt.Sprintf("  사용률: %.1f%%\n\n", data["usage_rate"].(float64))
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{
				tgbotapi.NewInlineKeyboardButtonData("재고 추가", "admin_add_stock"),
				tgbotapi.NewInlineKeyboardButtonData("재고 정리", "admin_cleanup_stock"),
			},
			{
				tgbotapi.NewInlineKeyboardButtonData("🔙", "admin_menu"),
			},
		},
	}
	bot.Request(msg)
}

// 재고 추가 명령어 처리
func handleAddStockCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있는 명령어입니다.")
		return
	}

	text := `📦 재고 추가

재고를 추가하려면 다음 형식으로 메시지를 보내주세요:

📝 형식: 카테고리:상품명:내용

• CARD:HK카드:1234-5678-9012-3456
• CARD:국외결제:9876-5432-1098-7654
• MEMBERSHIP:넷플릭스:user@email.com:pass123

지원 카테고리:
• CARD (카드)
• MEMBERSHIP (멤버십)
• ESIM (이심)
• VPS (가상서버)
• ACCOUNT (계정)

사진과 함께 보내면 자동으로 등록됩니다! 📸`

	sendTelegram(uid, text)
}

// 관리자 재고 상세보기
func showAdminStockDetail(uid, chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(uid, "❌ 상품 상세 정보를 불러올 수 없습니다.")
		return
	}

	var stocks []StockCard
	if err := db.Where("name = ?", product.Name).Find(&stocks).Error; err != nil {
		sendTelegram(uid, "❌ 재고 정보를 불러올 수 없습니다.")
		return
	}

	text := fmt.Sprintf(
		"📋 <b>상품 상세</b>\n\n"+
			"• 이름: %s\n"+
			"• 가격: %.2f USDT\n"+
			"• 재고 수량: %d\n\n"+
			"----- 재고 목록 -----\n",
		product.Name, product.Price, len(stocks),
	)

	for i, stock := range stocks {
		usedStr := "사용 가능"
		if stock.Used {
			usedStr = "사용됨"
		}
		text += fmt.Sprintf("%d. %s (%s)\n", i+1, stock.Content, usedStr)
		if i >= 20 { // 너무 길면 20개까지만 표시
			text += "...\n(더 많은 재고가 있습니다.)"
			break
		}
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	editMsg.ParseMode = "HTML"
	if _, err := bot.Send(editMsg); err != nil {
		log.Printf("showAdminStockDetail 메시지 수정 실패: %v", err)
	}
}

// 관리자 재고 삭제 메뉴
func showAdminStockDeleteMenu(uid, chatID int64, msgID int, productID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "ACCOUNT"}

	text := "🗑️ 재고 삭제\n\n삭제할 카테고리를 선택하세요:\n\n"

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	btnCount := 0

	for _, category := range categories {
		stockCount, err := getCardStock(category)
		if err != nil {
			continue
		}

		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s (%d개)", category, stockCount),
			fmt.Sprintf("del_stock_%s", category),
		)
		currentRow = append(currentRow, btn)
		btnCount++

		if btnCount%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}

	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("🔙 재고메뉴", "admin_inventory"),
	))

	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("재고 삭제 메뉴 수정 실패: %v", err)
	}
}

// 카테고리별 재고 삭제 처리
func handleDeleteStockCategory(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "del_stock_")

	// 삭제 전 확인 메시지
	stockCount, err := getCardStock(category)
	if err != nil {
		sendTelegram(uid, "❌ 재고 조회 실패")
		bot.Request(tgbotapi.NewCallback(cb.ID, "조회 실패"))
		return
	}

	text := fmt.Sprintf("⚠️ 정말로 %s 카테고리의 모든 재고(%d개)를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다!", category, stockCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("✅ 삭제 확인", fmt.Sprintf("confirm_del_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("❌ 취소", "admin_del_stock"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("삭제 확인 메뉴 수정 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 확인"))
}

// 유틸리티 함수
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// 재고 삭제 확인 처리
func handleConfirmDeleteStock(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// 관리자 권한 확인
	if !isAdmin(uid) {
		sendTelegram(uid, "❌ 관리자만 사용할 수 있는 기능입니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "권한 없음"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "confirm_del_")

	// 실제 삭제 실행
	var deletedCount int64
	result := db.Where("category = ?", category).Delete(&StockCard{})
	if result.Error != nil {
		log.Printf("재고 삭제 실패: %v", result.Error)
		sendTelegram(uid, "❌ 재고 삭제 중 오류가 발생했습니다.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 실패"))
		return
	}

	deletedCount = result.RowsAffected

	// 성공 메시지
	text := fmt.Sprintf("✅ %s 카테고리의 재고 %d개가 성공적으로 삭제되었습니다.", category, deletedCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("🔙 재고메뉴", "admin_inventory"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("삭제 완료 메뉴 수정 실패: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "삭제 완료"))
}
