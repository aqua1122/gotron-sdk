package main

import (
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/google/uuid"
	"github.com/skip2/go-qrcode"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	db       *gorm.DB
	mu       sync.Mutex
	adminIDs = []int64{6647879650}
	//processedOrders           = map[uint]bool{}
	// processedOrdersMu         sync.Mutex
	mySuperAdminID        int64 = 6647879650
	waitingForImage       map[int64]bool
	verificationAnswers   = make(map[int64]int)
	verifiedUsers         = make(map[int64]bool)
	lastAlertedCategories = make(map[string]time.Time)
	//lastReplyMsgID                  int
	userMessageIDs        = map[int64][]int{}
	pendingSupportQueue   = make(map[int64]time.Time)
	activeSupportSessions = make(map[int64]int64)
	userSelectedProduct   = map[int64]string{}
	//pendingStockImageID             = make(map[int64]string)
	pendingWalletInput              = make(map[int64]bool)
	userLanguages                   = make(map[int64]string)
	pendingStockInput               = make(map[int64]string)
	pendingStockInputBuffer         = make(map[int64]string)
	startTime                       = time.Now()
	selectedCategory                = make(map[int64]string)
	tronGridAPIKey                  = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract               = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
	walletReceiveAddress            = os.Getenv("WALLET_RECEIVE_ADDRESS")
	unmatchedAdminChatID      int64 = 6647879650
	pendingAddProductCategory       = make(map[int64]string)
	processedTxsMu            sync.RWMutex
	adminChatID               int64 = 6647879650
	userReplyKeyboardMsgID          = make(map[int64]int)
	processedTxs                    = make(map[string]bool)
	pendingEditProduct              = map[int64]int{}
	pendingAdminInput               = make(map[int64]bool)
	pendingStockInputNotified       = make(map[int64]bool)
	pendingBroadcastInput           = make(map[int64]bool)
	pendingDepositInput             = make(map[int64]bool)
	pendingDepositAmount            = make(map[int64]float64)
)

var vpsProductMap = map[string]struct {
	Name  string
	Price float64
}{
	"vps1": {"KVM - E1", 70.0},
	"vps2": {"KVM - E2", 90.0},
	"vps3": {"KVM - T1", 120.0},
	"vps4": {"KVM - T2", 150.0},
	"vps5": {"ë§ì¶¤ ì œì‘", 1}, // ê°€ê²©ì€ 0ì´ê±°ë‚˜ ë³„ë„ ì²˜ë¦¬
}

var productCategories = []string{
	"VPS", "ACCOUNT", "ë©¤ë²„ì‹­", "ESIM", "CARD",
}

type UserWallet struct {
	UserID  int64  `gorm:"primaryKey"`
	Address string `gorm:"type:varchar(64);not null;uniqueIndex"`
}

var validGrades = map[string]bool{
	"bronze":  true,
	"silver":  true, // ìˆ˜ì •: silvedb.Where("categoryr" â†’ "silver"
	"gold":    true,
	"diamond": true,
	"vip":     true,
}

var bot *tgbotapi.BotAPI

// categoryMapì— VPS í¬í•¨ ë° ID ë§ì¶¤
var categoryMap = map[string]uint{
	"VPS":     1,
	"ESIM":    2,
	"ACCOUNT": 3, // ì´ ë¶€ë¶„ì´ 3ì´ì–´ì•¼ í•©ë‹ˆë‹¤
	"ë©¤ë²„ì‹­":     4,
	"CARD":    5,
}

var categoryOrder = []string{
	"VPS",
	"ACCOUNT",
	"ë©¤ë²„ì‹­",
	"ESIM",
	"CARD",
}

var productOrder = map[string][]string{
	"VPS":     {"KVM - E1", "KVM - E2", "KVM - T1", "KVM - T2", "ë§ì¶¤ ì œì‘"},
	"ACCOUNT": {"TG 1ë…„", "TG 2ë…„", "ì§§ì€ ë²ˆí˜¸"},
	"ë©¤ë²„ì‹­":     {"TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”", "TG í”„ë¦¬ë¯¸ì—„ 1ë…„", "YT í”„ë¦¬ë¯¸ì—„ 1ë…„"},
	"ESIM":    {"5G DATA", "KOREA|HK", "NO KYC"},
	"CARD":    {"êµ­ë‚´ê²°ì œ(HK)", "êµ­ì™¸ê²°ì œ", "í•­ê³µê¶Œ"},
}

// cardCategories ë§µì— VPS ì¶”ê°€
var cardCategories = map[string]map[string]Product{
	"VPS": {
		"KVM - E1": {Code: "vps1", Price: 70, Description: "CPU: 4ì½”ì–´, RAM: 4GB, ì €ì¥ê³µê°„: 100GB NVMe, ê°€ê²©: 70 USDT"},
		"KVM - E2": {Code: "vps2", Price: 90, Description: "CPU: 4ì½”ì–´, RAM: 6GB, ì €ì¥ê³µê°„: 140GB NVMe, ê°€ê²©: 90 USDT"},
		"KVM - T1": {Code: "vps3", Price: 120, Description: "CPU: 8ì½”ì–´, RAM: 16GB, ì €ì¥ê³µê°„: 160GB NVMe, ê°€ê²©: 120 USDT"},
		"KVM - T2": {Code: "vps4", Price: 150, Description: "CPU: 12ì½”ì–´, RAM: 24GB, ì €ì¥ê³µê°„: 256GB NVMe, ê°€ê²©: 150 USDT"},
		"ë§ì¶¤ ì œì‘":    {Code: "vps5", Price: 1, Description: "ë§ì¶¤í˜•ì€ ìµœì†Œ 3ê°œì›” ë¶€í„°, ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´, ì›í•˜ëŠ” ì˜µì…˜ì— ë§ì¶° ì œì‘"},
	},
	"ACCOUNT": {
		"TG 1ë…„": {Code: "tgid1", Price: 8},
		"TG 2ë…„": {Code: "tgid2", Price: 20},
		"ì§§ì€ ë²ˆí˜¸": {Code: "tgid3", Price: 60},
	},
	"ë©¤ë²„ì‹­": {
		"TG í”„ë¦¬ë¯¸ì—„ 3ê°œì›”": {Code: "tp3", Price: 17},
		"TG í”„ë¦¬ë¯¸ì—„ 1ë…„":  {Code: "tp12", Price: 45},
		"YT í”„ë¦¬ë¯¸ì—„ 1ë…„":  {Code: "yp12", Price: 45},
	},
	"ESIM": {
		"5G DATA":  {Code: "es1", Price: 70},
		"KOREA|HK": {Code: "es2", Price: 999},
		"NO KYC":   {Code: "es3", Price: 999},
	},
	"CARD": {
		"êµ­ë‚´ê²°ì œ(HK)": {Code: "card1", Price: 10},
		"êµ­ì™¸ê²°ì œ":     {Code: "card2", Price: 10},
		"í•­ê³µê¶Œ":      {Code: "card3", Price: 10},
	},
}

// ===== ëª¨ë¸(ì¤‘ë³µ ì œê±°, ëª¨ë“  í…Œì´ë¸”/êµ¬ì¡°ì²´) =====
type StockCard struct {
	ID          uint64 `gorm:"primaryKey"`
	Category    string `gorm:"type:varchar(100);index:idx_category"`
	Name        string `gorm:"type:text"`
	Content     string `gorm:"type:text"`
	Used        bool
	UsedBy      int64
	OrderID     int64
	PhotoFileID string `gorm:"type:text"` // ì—†ìœ¼ë©´ ì¶”ê°€
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type ProductCategory struct {
	ID           uint `gorm:"primaryKey"`
	Name        string `gorm:"unique"`
	DisplayOrder int
}

type MonitoringWallet struct {
	UserID  int64
	Address string
	// í•„ìš”í•˜ë©´ ë” ì¶”ê°€
}

type dummyDB struct{}

type Category struct {
	ID   uint   `gorm:"primaryKey"`
	Name string `gorm:"unique;not null"` // ì¹´í…Œê³ ë¦¬ëª…(ì˜ˆ: "ê³„ì •", "ì—ë„ˆì§€" ë“±)
}

type Quiz struct {
	Question string
	Answer   int
	Options  []int
}

type TronDeposit struct {
	Amount float64
	TxID   string
	// ... í•„ìš”ì‹œ ì¶”ê°€
}

type ChatConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Result struct {
	Error        error
	RowsAffected int64
}

type User struct {
	ID            uint      `gorm:"primaryKey;autoIncrement"`
	UserID        int64     `gorm:"uniqueIndex"`
	UserName      string    `gorm:"column:user_name"`
	Nickname      string    `gorm:"column:nickname"`
	ChatID        int64     `gorm:"column:chat_id"`
	LastSeen      time.Time `gorm:"column:last_seen"`
	JoinedAt      time.Time `gorm:"column:joined_at"`
	Grade         string    `gorm:"type:varchar(20)"`
	DepositWallet string
}

type Transaction struct {
	TransactionID  string `json:"transaction_id"`
	From           string `json:"from"`
	To             string `json:"to"`
	Value          string `json:"value"`
	BlockTimestamp int64  `json:"block_timestamp"`
	Confirmations  int    `json:"confirmations"`
}

type TronGridResponse struct {
	Data  []Transaction `json:"data"`
	Total int           `json:"total"`
}

type TronTransaction struct {
	TxID      string `json:"transaction_id"`
	From      string `json:"from"`
	To        string `json:"to"`
	AmountStr string `json:"value"` // ì†Œìˆ˜ì  ê³ ë ¤ í•„ìš” (string íƒ€ì…ìœ¼ë¡œ ë°›ìŒ)
	Timestamp int64  `json:"block_timestamp"`
}

type Deposit struct {
	TxID   string
	Amount float64
	Time   time.Time
}

type ChatInfoConfig struct {
	ChatID             int64
	SuperGroupUsername string
}

type Order struct {
	ID          uint `gorm:"primaryKey"`
	UserID      int64
	Product     string
	Amount      float64
	Status      string `gorm:"type:varchar(255);index"`
	ExpectedAmt float64
	CardInfo    string  `gorm:"type:text"`
	TxID        *string `gorm:"type:varchar(255);index"`
	Timestamp   time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserBalance struct {
	UserID  int64 `gorm:"primaryKey"`
	Balance float64
}

type Visitor struct {
	UserID   int64          `gorm:"column:user_id"`
	UserName sql.NullString `gorm:"column:user_name"`
	LastSeen time.Time      `gorm:"column:last_seen"`
}

type WalletMap struct {
	ID          uint   `gorm:"primaryKey"`
	UserID      int64  `gorm:"uniqueIndex"`
	Wallet      string `gorm:"size:100"`
	Username    string `gorm:"size:100"`
	ProductName string
	Product     string // ì˜ˆ: Product
	UpdatedAt   time.Time
}

type Wallet struct {
	ID        uint   `gorm:"primaryKey"`
	UserID    int64  `gorm:"index"`
	Address   string `gorm:"size:100;uniqueIndex"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserActivityLog struct {
	UserID     int64     `gorm:"column:user_id"`
	Username   string    `gorm:"column:username"`
	Nickname   string    `gorm:"column:nickname"`
	LastActive time.Time `gorm:"column:last_active"`
}

type Inventory struct {
	ID          uint `gorm:"primaryKey"`
	Category    string
	ProductName string
	Stock       int64
	UpdatedAt   time.Time
}

type SalesStats struct {
	Date       string `gorm:"primaryKey"`
	TotalSales float64
	TotalCount int64
	Count      int64 // ì¶”ê°€
	SalesCount int64 // ì¶”ê°€
}

type Admin struct {
	ID     uint  `gorm:"primaryKey"`
	UserID int64 `gorm:"uniqueIndex"`
}

type Product struct {
	ID          uint    `gorm:"primaryKey"`
	Code        string  `gorm:"unique;not null"`
	Name        string  `gorm:"not null"`
	Price       float64 `gorm:"not null"`
	Description string
	ImageURL    string
	Stock       int
	Active      bool
	Category    string `gorm:"type:varchar(64);index"`
	CategoryID  uint
}

type SimpleProduct struct {
	Code  string
	Price float64
}

type NgrokTunnel struct {
	PublicURL string `json:"public_url"`
}

type NgrokAPIResponse struct {
	Tunnels []struct {
		Name      string `json:"name"`
		PublicURL string `json:"public_url"`
		Proto     string `json:"proto"`
	} `json:"tunnels"`
}

const timeFormat = "2006-01-02 15:04:05"

func init() {
	tronGridAPIKey = os.Getenv("TRONGRID_API_KEY")
	usdtTRC20Contract = os.Getenv("USDT_TRC20_CONTRACT")
	walletReceiveAddress = os.Getenv("WALLET_RECEIVE_ADDRESS")
	if tronGridAPIKey == "" {
		log.Fatal("âŒ TRONGRID_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	if usdtTRC20Contract == "" {
		log.Fatal("âŒ USDT_TRC20_CONTRACT í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	if walletReceiveAddress == "" {
		log.Fatal("âŒ WALLET_RECEIVE_ADDRESS í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
}

func getNgrokPublicURL(apiEndpoint string) (string, error) {
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(apiEndpoint)
	if err != nil {
		return "", fmt.Errorf("ngrok API ìš”ì²­ ì‹¤íŒ¨: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("ngrok API ì‘ë‹µ ì½”ë“œ %d", resp.StatusCode)
	}

	var data NgrokAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", fmt.Errorf("ngrok API JSON ë””ì½”ë”© ì‹¤íŒ¨: %w", err)
	}

	for _, tunnel := range data.Tunnels {
		if strings.HasPrefix(tunnel.PublicURL, "https") {
			return tunnel.PublicURL, nil
		}
	}

	return "", fmt.Errorf("ngrok https í„°ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
}

func addVPSProducts() error {
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		return fmt.Errorf("VPS ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	products := []Product{
		{Code: "vps1", Name: "KVM - E1", Description: "CPU: 4ì½”ì–´, RAM: 4GB, ì €ì¥ê³µê°„: 100GB NVMe, ê°€ê²©: 70 USDT", Price: 70, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps2", Name: "KVM - E2", Description: "CPU: 4ì½”ì–´, RAM: 6GB, ì €ì¥ê³µê°„: 140GB NVMe, ê°€ê²©: 90 USDT", Price: 90, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps3", Name: "KVM - T1", Description: "CPU: 8ì½”ì–´, RAM: 16GB, ì €ì¥ê³µê°„: 160GB NVMe, ê°€ê²©: 120 USDT", Price: 120, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps4", Name: "KVM - T2", Description: "CPU: 12ì½”ì–´, RAM: 24GB, ì €ì¥ê³µê°„: 256GB NVMe, ê°€ê²©: 150 USDT", Price: 150, CategoryID: vpsCategoryID, Active: true},
		{Code: "vps5", Name: "ë§ì¶¤ ì œì‘", Description: "ë§ì¶¤í˜• ì‚¬ì–‘ ì œê³µ, ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´, ì•ˆì •ì„±ê³¼ ì„±ëŠ¥ ìš°ì„ ", Price: 0, CategoryID: vpsCategoryID, Active: true},
	}

	// DBì— ê° ìƒí’ˆ ì¶”ê°€
	for _, p := range products {
		var existing Product
		err := db.Where("code = ?", p.Code).First(&existing).Error
		if errors.Is(err, gorm.ErrRecordNotFound) {
			if err := db.Create(&p).Error; err != nil {
				return fmt.Errorf("ìƒí’ˆ %s ì¶”ê°€ ì‹¤íŒ¨: %w", p.Name, err)
			}
		} else if err != nil {
			return fmt.Errorf("ìƒí’ˆ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
		}
	}

	return nil
}

func initBotWithWebhook() (*tgbotapi.BotAPI, error) {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		return nil, fmt.Errorf("í…”ë ˆê·¸ë¨ ë´‡ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
	}

	var err error

	bot, err := tgbotapi.NewBotAPI(token)
	if err != nil {
		return nil, fmt.Errorf("í…”ë ˆê·¸ë¨ ë´‡ ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	ngrokAPI := "http://127.0.0.1:4040/api/tunnels"
	publicURL, err := getNgrokPublicURL(ngrokAPI)
	if err != nil {
		log.Printf("ngrok URL ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		publicURL = os.Getenv("WEBHOOK_URL")
		if publicURL == "" {
			return nil, fmt.Errorf("ì›¹í›… URLì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤")
		}
	}

	webhookURL := fmt.Sprintf("%s/webhook", publicURL)
	log.Printf("ì›¹í›… URL ì„¤ì •: %s", webhookURL)

	webhook, err := tgbotapi.NewWebhook(webhookURL)
	if err != nil {
		return nil, fmt.Errorf("ì›¹í›… ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	_, err = bot.Request(webhook)
	if err != nil {
		return nil, fmt.Errorf("ì›¹í›… ë“±ë¡ ì‹¤íŒ¨: %w", err)
	}

	log.Println("ì›¹í›… ë“±ë¡ ì™„ë£Œ")

	return bot, nil
}

func generateAdditionQuiz() Quiz {
	rand.Seed(time.Now().UnixNano())
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b

	options := []int{answer}
	// ì˜¤ë‹µ 2ê°œ ìƒì„± (ì •ë‹µê³¼ ì¤‘ë³µ ì•ˆë˜ê²Œ)
	for len(options) < 3 {
		opt := rand.Intn(19) + 2 // ê°€ëŠ¥í•œ í•© ë²”ìœ„ 2~20
		if opt != answer && !contains(options, opt) {
			options = append(options, opt)
		}
	}

	// ì˜µì…˜ ì„ê¸°
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	question := fmt.Sprintf("%d + %d = ?", a, b)
	return Quiz{
		Question: question,
		Answer:   answer,
		Options:  options,
	}
}

func contains(arr []int, val int) bool {
	for _, v := range arr {
		if v == val {
			return true
		}
	}
	return false
}

func generateCaptcha() (int, int, int) {
	a := rand.Intn(10) + 1 // 1~10
	b := rand.Intn(10) + 1
	answer := a + b
	return a, b, answer
}

func getVPSProductInfo(key string) (string, float64, bool) {
	product, exists := vpsProductMap[key]
	if !exists {
		return "", 0, false
	}
	return product.Name, product.Price, true
}

func sendVerificationChallenge(uid int64, chatID int64) {
	// ë¬¸ì œ ìƒì„± (ì˜ˆ: ê°„ë‹¨í•œ ë§ì…ˆ)
	a := rand.Intn(10) + 1
	b := rand.Intn(10) + 1
	answer := a + b

	// ìœ ì €ë³„ ì •ë‹µ ì €ì¥ (ì „ì—­ë§µ ë˜ëŠ” DBì— ì €ì¥í•´ì•¼ í•¨)
	verificationAnswers[uid] = answer

	msgText := "<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n" +
		"ğŸ”’ <b>PRIVATE ACCESS ONLY</b>\n\n" +
		"ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\n" +
		"ì•„ë˜ ë¬¸ì œë¥¼ í’€ì–´ ì¸ì¦ì„ í•˜ì„¸ìš”.\n\n" +
		fmt.Sprintf("ë¬¸ì œ: <b>%d + %d = ?</b>\n\n", a, b) +
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>"

	// ë‹µë³€ ë²„íŠ¼ 3ê°œ (ì •ë‹µ í¬í•¨ ëœë¤ ë°°ì¹˜)
	options := generateAnswerOptions(answer)
	var buttons []tgbotapi.InlineKeyboardButton
	for _, opt := range options {
		data := fmt.Sprintf("verify_%d", opt)
		buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", opt), data))
	}
	kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(buttons...))

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

func generateAnswerOptions(answer int) []int {
	var options []int
	options = append(options, answer)

	// ì •ë‹µê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ ë‘ ê°œì˜ ì˜¤ë‹µ ìƒì„±
	for len(options) < 3 {
		delta := rand.Intn(5) + 1 // 1~5 ë²”ìœ„
		wrong := answer + delta
		if rand.Intn(2) == 0 {
			wrong = answer - delta
		}
		// ì¤‘ë³µ ë°©ì§€
		exists := false
		for _, opt := range options {
			if opt == wrong {
				exists = true
				break
			}
		}
		if !exists && wrong >= 0 {
			options = append(options, wrong)
		}
	}

	// ëœë¤ ìˆœì„œë¡œ ì„ê¸°
	rand.Shuffle(len(options), func(i, j int) {
		options[i], options[j] = options[j], options[i]
	})

	return options
}

// ì¸ì¦ ì½œë°± ì²˜ë¦¬ í•¨ìˆ˜
func handleVerificationResponse(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	data := cb.Data

	if !strings.HasPrefix(data, "verify_") {
		return
	}

	// ì„ íƒí•œ ë‹µ ì¶”ì¶œ
	selectedStr := strings.TrimPrefix(data, "verify_")
	selected, err := strconv.Atoi(selectedStr)
	if err != nil {
		sendTelegram(uid, "âŒ ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.")
		return
	}

	correctAnswer, ok := verificationAnswers[uid]
	if !ok {
		sendTelegram(uid, "âŒ ì¸ì¦ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
		return
	}

	if selected == correctAnswer {
		accessMsg := "<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n" +
			"âœ… <b>Access Granted</b> âœ…\n\n" +
			"ğŸ”“ <b>Verification was successful</b>\n" +
			"ì ‘ê·¼ ê¶Œí•œì´ í—ˆìš©ë˜ì—ˆìŠµë‹ˆë‹¤.\n" +
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"
		sendTelegram(uid, accessMsg)
		markUserVerified(uid)            // ì¸ì¦ ìƒíƒœ ì €ì¥
		delete(verificationAnswers, uid) // ì¸ì¦ ë¬¸ì œ ì‚­ì œ

		// ì¸ì¦ ì„±ê³µ í›„ ë©”ë‰´ ìë™ í˜¸ì¶œ
		showMenu(uid, "", chatID)
	} else {
		failMsg := "<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n" +
			"âŒ <b>Verification Failed</b> âŒ\n\n" +
			"ì„ íƒí•œ ë‹µë³€ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.\n" +
			"ì•„ë˜ ë¬¸ì œë¥¼ ë‹¤ì‹œ í’€ì–´ ì£¼ì„¸ìš”.\n\n" +
			"ì§€ì†ë  ê²½ìš° ì°¨ë‹¨ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n" +
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"
		sendTelegram(uid, failMsg)
		delete(verificationAnswers, uid)
		sendVerificationChallenge(uid, chatID) // ë¬¸ì œ ì¬ì¶œì œ
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "ë‹µë³€ ì²˜ë¦¬ë¨"))
}

func sendCategoryAlert(category string) {
	now := time.Now()
	lastAlertedCategories[category] = now
	// ì•Œë¦¼ ì²˜ë¦¬ ì½”ë“œ...
}

func handleProductSelection(uid int64, productCode string) {
	userSelectedProduct[uid] = productCode
	// ì´í›„ ì£¼ë¬¸ í™•ì¸ ë©”ì‹œì§€ ë³´ë‚´ê¸° ë“± ì‘ì—… ìˆ˜í–‰
}

func saveStockWithImage(uid int64, inputText, photoFileID string) error {
	lines := strings.Split(strings.TrimSpace(inputText), "\n")
	for _, line := range lines {
		parts := strings.SplitN(line, ":", 3)
		if len(parts) != 3 {
			return fmt.Errorf("ì˜ëª»ëœ ì…ë ¥ í˜•ì‹: %s", line)
		}
		category := strings.TrimSpace(parts[0])
		name := strings.TrimSpace(parts[1])
		codes := strings.Split(parts[2], ",")
		for _, code := range codes {
			code = strings.TrimSpace(code)

			// StockCard êµ¬ì¡°ì²´ë¡œ ì €ì¥
			stockCard := StockCard{
				Category:    category,
				Name:        name,
				Content:     code,
				Used:        false,
				PhotoFileID: photoFileID,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
			}

			// StockCardë¥¼ DBì— ì €ì¥
			if err := db.Create(&stockCard).Error; err != nil {
				return err
			}
		}
	}
	return nil
}

func checkTronUSDTDeposits(address string) ([]Transaction, error) {
	apiKey := tronGridAPIKey // ì „ì—­ë³€ìˆ˜ ë˜ëŠ” í™˜ê²½ë³€ìˆ˜ì—ì„œ ë°›ì•„ì˜¤ì„¸ìš”
	if apiKey == "" {
		return nil, fmt.Errorf("íŠ¸ë¡ ê·¸ë¦¬ë“œ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
	}

	usdtTRC20Contract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 ë©”ì¸ë„· ì£¼ì†Œ

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=20&contract_address=%s", address, usdtTRC20Contract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	client := &http.Client{Timeout: 10 * time.Second}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result TronGridResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

func processDeposits() {
	// ê°ì‹œí•  ì§€ê°‘ ì£¼ì†Œ (ë³´í†µ ì„œë¹„ìŠ¤ ì§€ê°‘)
	address := walletReceiveAddress

	txs, err := checkTronUSDTDeposits(address)
	if err != nil {
		log.Printf("íŠ¸ë¡ ê·¸ë¦¬ë“œ ì…ê¸ˆ ë‚´ì—­ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return
	}

	for _, tx := range txs {
		log.Printf("ì…ê¸ˆ íŠ¸ëœì­ì…˜: ID=%s, From=%s, To=%s, Value=%s, Confirmations=%d", tx.TransactionID, tx.From, tx.To, tx.Value, tx.Confirmations)
		// ì¤‘ë³µ ì²˜ë¦¬ ì—¬ë¶€ ê²€ì‚¬, DB ì—…ë°ì´íŠ¸ ë“± ì¶”ê°€ êµ¬í˜„ í•„ìš”
	}
}

func (d *dummyDB) Create(value interface{}) *Result {
	log.Printf("[DB] ì£¼ë¬¸ ì €ì¥ë¨: %+v", value) // valueë¥¼ ì§ì ‘ ì‚¬ìš©
	return &Result{Error: nil}
}

type dummyResult struct {
	Error error
}

func isValidGrade(grade string) bool {
	return validGrades[strings.ToLower(grade)]
}

func getCardCategoriesFromDB() ([]ProductCategory, error) {
	var categories []ProductCategory
	err := db.Find(&categories).Error
	return categories, err
}

func showCategoryMenu(uid, chatID int64, messageID int) {
	log.Printf("[showCategoryMenu] uid: %d, chatID: %d, messageID: %d", uid, chatID, messageID)

	categories, err := getCardCategoriesFromDB()
	if err != nil || len(categories) == 0 {
		sendTelegram(chatID, "âŒ ì¹´í…Œê³ ë¦¬ ë¡œë”© ì‹¤íŒ¨ ë˜ëŠ” ì¹´í…Œê³ ë¦¬ ì—†ìŒ")
		log.Printf("[showCategoryMenu] ì¹´í…Œê³ ë¦¬ ë¡œë”© ì˜¤ë¥˜: %v", err)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, cat := range categories {
		callbackData := "cardcat_" + cat.Name
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(cat.Name, callbackData),
		))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ›’ êµ¬ë§¤ ê°€ëŠ¥í•œ ìƒí’ˆ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”:")
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}

	if _, err := bot.Send(msg); err != nil {
		log.Printf("[showCategoryMenu] ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func markUserVerified(uid int64) {
	verifiedUsers[uid] = true
}

func isUserVerified(uid int64) bool {
	return verifiedUsers[uid]
}

func getAllMonitoringWallets() ([]MonitoringWallet, error) {
	// êµ¬í˜„
	return nil, nil
}

func doSomething() error {
	num := 10
	if num > 5 {
		return nil
	}
	return errors.New("ì²˜ë¦¬ ì•ˆë¨")
}

func showAdminMenu(uid, chatID int64, messageID int) {
	// ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
	status := getStatusReport()

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.")
		return
	}

	text := "ğŸ‘‘ ê´€ë¦¬ì ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤. ğŸ‘‘\n\n" + status

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ìƒí’ˆê´€ë¦¬", "admin_inventory"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“† ì£¼ê°„í†µê³„", "weekly_stats"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸªª íšŒì›ëª©ë¡", "admin_member_menu"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‘¥ ë°©ë¬¸ìì¡°íšŒ", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š í†µê³„ë³´ê¸°", "admin_stats"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ì£¼ë¬¸ë‚´ì—­", "admin_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âš™ï¸ ì„¤ì •", "showAdminSettings"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”§ ê³ ê¸‰ê´€ë¦¬", "admin_advanced"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func getStatusReport() string {
	now := time.Now().Format("2006-01-02 15:04:05")

	// DB ìƒíƒœëŠ” í•­ìƒ OKë¡œ ê°€ì • (dummy)
	dbOK := true

	// ë”ë¯¸ê°’: í•„ìš”ì‹œ ì „ì—­ ë³€ìˆ˜/ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ê°¯ìˆ˜ êµ¬í•˜ê¸°
	orderCount := int64(1) // ë¯¸ì²˜ë¦¬ ì£¼ë¬¸ ì˜ˆì‹œ
	cardStock := int64(10) // ë‚¨ì€ ì¬ê³  ì˜ˆì‹œ
	userCount := int64(5)  // ê°€ì…ì ìˆ˜ ì˜ˆì‹œ

	uptime := time.Since(startTime).Truncate(time.Second).String()

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return fmt.Sprintf(
		"<b>ğŸ“Š BOT STATUS</b>\nâ° ì„œë²„ì‹œê°„: %s\nğŸŸ¢ DBìƒíƒœ: %s\nğŸ›’ ë¯¸ì²˜ë¦¬: %d\nğŸ’³ ì¬ê³ : %d\nğŸ™‹ ê°€ì…ì: %d\nâ± ì—…íƒ€ì„: %s\nğŸ’¾ ë©”ëª¨ë¦¬: %.2fMB",
		now,
		map[bool]string{true: "OK", false: "ì˜¤ë¥˜"}[dbOK],
		orderCount,
		cardStock,
		userCount,
		uptime,
		float64(m.Alloc)/1024/1024,
	)
}

func initDB() {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		os.Getenv("MYSQL_USER"),
		os.Getenv("MYSQL_PASSWORD"),
		os.Getenv("MYSQL_HOST"),
		os.Getenv("MYSQL_PORT"),
		os.Getenv("MYSQL_DB"),
	)

	var err error
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Error), // ì—ëŸ¬ë§Œ ì¶œë ¥
	})
	if err != nil {
		log.Fatalf("DB ì—°ê²° ì‹¤íŒ¨: %v", err)
	}
	log.Println("âœ… DB ì—°ê²° ì„±ê³µ")

	// ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜
	if err := db.AutoMigrate(&UserBalance{}, &StockCard{}, &Order{}); err != nil {
		log.Fatalf("âŒ DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %v", err)
	}
	log.Println("âœ… DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ")
}

func getAdminChatID() int64 {
	return adminChatID
}

func handleWebhook(c *gin.Context) {
	var update tgbotapi.Update

	// 1. JSON ë°”ì¸ë”© ì‹œë„
	if err := c.ShouldBindJSON(&update); err != nil {
		log.Printf("ì›¹í›… JSON ë°”ì¸ë”© ì‹¤íŒ¨: %v", err)
		c.JSON(400, gin.H{"status": "bad request"})
		return
	}

	// 2. ë°”ì¸ë”© ì„±ê³µ ì‹œ ë¡œê·¸ ì¶œë ¥ ë° ì²˜ë¦¬
	log.Printf("[handleWebhook] update: %+v", update)
	processUpdate(update)

	// 3. ì²˜ë¦¬ ì™„ë£Œ ì‘ë‹µ
	c.JSON(200, gin.H{"status": "ok"})
}

func handleWalletRegister(chatID, uid int64, addr string) {
	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		sendTelegram(chatID, "ìœ ì € ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}
	user.DepositWallet = addr
	if err := db.Save(&user).Error; err != nil {
		sendTelegram(chatID, "ì§€ê°‘ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
	} else {
		sendTelegram(chatID, "ì…ê¸ˆ ì§€ê°‘ì´ ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!")
	}
}

func setWebhook(bot *tgbotapi.BotAPI, url string) error {
	webhookConfig, err := tgbotapi.NewWebhook(url)
	if err != nil {
		return err
	}
	_, err = bot.Request(webhookConfig)
	return err
}

// ì˜ˆì‹œ: íŠ¹ì • ê¸°ê°„, íŠ¹ì • ì¹´í…Œê³ ë¦¬ ë§¤ì¶œ í•©ê³„ ì¡°íšŒ í•¨ìˆ˜
func getSalesSum(startDate, endDate, category string) (float64, error) {
	var total sql.NullFloat64

	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		startDate, endDate, category+"%",
	).Scan(&total).Error
	if err != nil {
		log.Printf("ë§¤ì¶œ í•©ê³„ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return 0, err
	}

	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULLì¸ ê²½ìš° 0 ë°˜í™˜
}

func initBot() {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	var err error
	bot, err = tgbotapi.NewBotAPI(token)
	if err != nil {
		log.Fatalf("âŒ í…”ë ˆê·¸ë¨ ë´‡ ìƒì„± ì‹¤íŒ¨: %v", err)
	}
	log.Printf("ğŸ¤– ë´‡ ì‹œì‘ë¨: @%s", bot.Self.UserName)

	webhookURL := os.Getenv("WEBHOOK_URL")
	if webhookURL != "" {
		if err := setWebhook(bot, webhookURL); err != nil {
			log.Fatalf("âŒ ì›¹í›… ì„¤ì • ì‹¤íŒ¨: %v", err)
		}
		log.Printf("âœ… ì›¹í›… ì„¤ì • ì™„ë£Œ: %s", webhookURL)
	} else {
		log.Println("âš ï¸ WEBHOOK_URL í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ì›¹í›… ì„¤ì •í•˜ì§€ ì•ŠìŒ")
	}
}

func migrateDB() {
	err := db.AutoMigrate(&UserActivityLog{})
	if err != nil {
		log.Fatalf("DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: %v", err)
	}
	log.Println("DB ë§ˆì´ê·¸ë ˆì´ì…˜ ì„±ê³µ")
}

func processUpdate(update tgbotapi.Update) {
	if update.CallbackQuery != nil {
		handleCallback(update.CallbackQuery) // ê¸°ì¡´ handleCallbackQuery ëŒ€ì‹  handleCallback í˜¸ì¶œ
	} else if update.Message != nil {
		handleMessage(update.Message)
	} else {
		log.Printf("ì²˜ë¦¬í•˜ì§€ ì•ŠëŠ” ì—…ë°ì´íŠ¸ íƒ€ì…: %+v", update)
	}
}

func showProductMenu(category string, chatID int64, messageID int) {
	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	count := 0

	// ê³ ì • ìƒí’ˆ ìˆœì„œëŒ€ë¡œ ë²„íŠ¼ ìƒì„±
	for _, pname := range productOrder[category] {
		product, ok := cardCategories[category][pname]
		if !ok {
			continue // ìƒí’ˆëª…ì´ ì‹¤ì œ ë°ì´í„°ì— ì—†ìœ¼ë©´ ê±´ë„ˆëœ€
		}
		btn := tgbotapi.NewInlineKeyboardButtonData(
			pname,
			"prod_"+product.Code,
		)
		currentRow = append(currentRow, btn)
		count++
		if count%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}
	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_catmenu"),
	))

	msgText := "<b>ìƒí’ˆì„ ì„ íƒí•˜ì„¸ìš”.</b>"

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
}

func addUserBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", userID).Error
	if err != nil { // ì”ì•¡ ê¸°ë¡ ì—†ìœ¼ë©´ ì‹ ê·œ ìƒì„±
		balance = UserBalance{
			UserID:  userID,
			Balance: amount,
		}
		return db.Create(&balance).Error
	}
	balance.Balance += amount
	return db.Save(&balance).Error
}

func sendReplyKeyboard(uid, chatID int64) error {
	// ì´ì „ ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ë©”ì‹œì§€ ì‚­ì œ (ìˆìœ¼ë©´)
	if msgID, ok := userReplyKeyboardMsgID[uid]; ok && msgID != 0 {
		delMsg := tgbotapi.DeleteMessageConfig{
			ChatID:    chatID,
			MessageID: msgID,
		}
		if _, err := bot.Request(delMsg); err != nil {
			log.Printf("ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ì´ì „ ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨: %v", err)
		}
	}

	// ìƒˆ ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ë©”ì‹œì§€ ì „ì†¡
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ë‚´ ì •ë³´"),
			tgbotapi.NewKeyboardButton("ì—ë„ˆì§€"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ì£¼ë¬¸ë‚´ì—­"),
			tgbotapi.NewKeyboardButton("ê³ ê°ì„¼í„°"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	msg := tgbotapi.NewMessage(chatID, " ") // ë¹ˆ í…ìŠ¤íŠ¸
	msg.ReplyMarkup = replyKeyboard

	sentMsg, err := bot.Send(msg)
	if err != nil {
		return err
	}

	userReplyKeyboardMsgID[uid] = sentMsg.MessageID
	return nil
}

func showMenu(uid int64, username string, chatID int64) {
	if username == "" {
		username = "unknown"
	}

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	isAdminUser := isAdmin(uid)

	introMsg := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b> : <code>%d</code>\n"+
			"ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b> : %s\n"+
			"â°  : <code>%s</code>\n"+
			"ë“±ê¸‰ : %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n",
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	if isAdminUser {
		introMsg += "\n<b>ê¶Œí•œ: ê´€ë¦¬ì</b>\n"
	}

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdminUser {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("showMenu ì¸íŠ¸ë¡œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	if err := sendReplyKeyboard(uid, chatID); err != nil {
		log.Printf("showMenu ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func handleCategorySelect(uid int64, cat string, chatID int64, msgID int) {
	selectedCategory[uid] = cat // ì´ ìœ ì €ì˜ í˜„ì¬ ì¹´í…Œê³ ë¦¬ ì„ íƒ ì €ì¥

	// "ì¹´í…Œê³ ë¦¬ë³„ ìƒí’ˆëª©ë¡" ë©”ë‰´ ë³´ì—¬ì£¼ê¸°
	showProductListMenuByCategory(chatID, msgID, cat)
}

func handleStart(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	username := msg.From.UserName

	var user User
	err := db.Where("user_id = ?", uid).First(&user).Error
	if err != nil {
		user = User{UserID: uid, UserName: username, Grade: "bronze"}
	}

	emoji := getGradeEmoji(user.Grade)

	displayName := user.UserName
	if displayName == "" {
		displayName = user.Nickname
	}
	if displayName == "" {
		displayName = "unknown"
	}

	introMsg := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b> : <code>%d</code>\n"+
			"ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b> : %s\n"+
			"â°  : <code>%s</code>\n"+
			"ë“±ê¸‰ : %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n",
		user.UserID, html.EscapeString(displayName), time.Now().Format("2006-01-02 15:04"), emoji,
	)

	isAdminUser := isAdmin(uid)

	var menu tgbotapi.InlineKeyboardMarkup
	if isAdminUser {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
			),
		)
	} else {
		menu = tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ìƒí’ˆëª©ë¡", "menu_products"),
				tgbotapi.NewInlineKeyboardButtonData("ê°€ìƒì„œë²„", "menu_vps"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ì½”ì¸ìŠ¤ì™‘", "menu_swap"),
				tgbotapi.NewInlineKeyboardButtonURL("WEB 3", "https://aquashop.top"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â“ FAQ", "menu_help"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸŒ LANGUAGE", "showLanguageMenu"),
			),
		)
	}

	// 1. ì¸íŠ¸ë¡œ ë©”ì‹œì§€ + ì¸ë¼ì¸ í‚¤ë³´ë“œ ì „ì†¡
	menuMsg := tgbotapi.NewMessage(chatID, introMsg)
	menuMsg.ParseMode = "HTML"
	menuMsg.ReplyMarkup = menu
	if _, err := bot.Send(menuMsg); err != nil {
		log.Printf("ì¸íŠ¸ë¡œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		return
	}

	// 2. ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ì „ì†¡ (ë¹ˆ í…ìŠ¤íŠ¸)
	replyKeyboard := tgbotapi.NewReplyKeyboard(
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ë‚´ ì •ë³´"),
			tgbotapi.NewKeyboardButton("ì—ë„ˆì§€"),
		),
		tgbotapi.NewKeyboardButtonRow(
			tgbotapi.NewKeyboardButton("ì£¼ë¬¸ë‚´ì—­"),
			tgbotapi.NewKeyboardButton("ê³ ê°ì„¼í„°"),
		),
	)
	replyKeyboard.ResizeKeyboard = true

	replyMsg := tgbotapi.NewMessage(chatID, "PING ğŸ›œ") // ë¹ˆ ë¬¸ìì—´ë¡œ í…ìŠ¤íŠ¸ ì—†ì´ í‚¤ë³´ë“œë§Œ í‘œì‹œ
	replyMsg.ReplyMarkup = replyKeyboard
	if _, err := bot.Send(replyMsg); err != nil {
		log.Printf("ë¦¬í”Œë¼ì´ í‚¤ë³´ë“œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì”ì•¡ ì¡°íšŒ í•¨ìˆ˜
func handleBalanceCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	var userBal UserBalance
	err := db.Where("user_id = ?", uid).First(&userBal).Error
	balance := 0.0
	if err == nil {
		balance = userBal.Balance
	}
	reply := fmt.Sprintf(
		"ğŸ‘¤ : <code>%d</code>\n\nğŸ’° ì”ì•¡ : %.3f USDT\n\nì…ê¸ˆì€ /ì…ê¸ˆ ì•ˆë‚´ ë©”ë‰´ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.",
		uid, balance,
	)
	sendTelegram(uid, reply)
}

// ê´€ë¦¬ì ì—¬ë¶€ íŒë‹¨ í•¨ìˆ˜
func isAdmin(userID int64) bool {
	// ê´€ë¦¬ì ID ëª©ë¡
	adminIDs := []int64{
		mySuperAdminID, // ìŠˆí¼ ê´€ë¦¬ì
		// ë‹¤ë¥¸ ê´€ë¦¬ì ID ì¶”ê°€ ê°€ëŠ¥
	}

	// ê´€ë¦¬ì ID ëª©ë¡ì— userIDê°€ ìˆëŠ”ì§€ í™•ì¸
	for _, id := range adminIDs {
		if userID == id {
			return true
		}
	}

	return false
}

func saveUserToDB(uid int64, username string, chatID int64) error {
	var user User
	result := db.Where("user_id = ?", uid).First(&user)
	if errors.Is(result.Error, gorm.ErrRecordNotFound) {
		user = User{
			UserID:   uid,
			UserName: username,
			ChatID:   chatID,
			Grade:    "bronze",
			JoinedAt: time.Now(),
			LastSeen: time.Now(),
		}
		return db.Create(&user).Error
	} else if result.Error != nil {
		return result.Error
	}
	user.UserName = username
	user.ChatID = chatID
	user.LastSeen = time.Now()
	return db.Save(&user).Error
}

func convertUsersToActivityLogs(users []User) []UserActivityLog {
	logs := make([]UserActivityLog, len(users))
	for i, u := range users {
		logs[i] = UserActivityLog{
			UserID:     u.UserID,
			Username:   u.UserName,
			Nickname:   u.Nickname,
			LastActive: u.LastSeen,
		}
	}
	return logs
}

// ìƒí’ˆ ëª©ë¡ (ì¹´í…Œê³ ë¦¬ë³„, ì˜ˆì‹œ)
func showProductList(chatID int64, messageID int, category string, callbackID string) {
	products, ok := cardCategories[category]
	if !ok {
		sendTelegram(chatID, "âŒ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤.")
		return
	}
	rows := [][]tgbotapi.InlineKeyboardButton{}
	for _, prod := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s - %.3f USDT", prod.Name, prod.Price),
			"prod_"+prod.Code,
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "menu_products")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))
	edit := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("ğŸ“¦ %s ìƒí’ˆ ëª©ë¡", strings.Title(category)))
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Send(edit)
	bot.Request(tgbotapi.NewCallback(callbackID, "ìƒí’ˆ ëª©ë¡ í‘œì‹œ"))
}

func sendOrEditMessage(chatID int64, messageID int, text string, markup interface{}) {
	if messageID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		if kb, ok := markup.(tgbotapi.InlineKeyboardMarkup); ok {
			msg.ReplyMarkup = kb
		}
		bot.Send(msg)
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
		edit.ParseMode = "HTML"
		if kb, ok := markup.(tgbotapi.InlineKeyboardMarkup); ok {
			edit.ReplyMarkup = &kb
		} else {
			edit.ReplyMarkup = nil
		}
		bot.Send(edit)
	}
}

func RoundFloat(val float64, precision int) float64 {
	ratio := math.Pow(10, float64(precision))
	return math.Round(val*ratio) / ratio
}

func showVPSMenu(uid, chatID int64, messageID int) {
	// 1. 'VPS' ì¹´í…Œê³ ë¦¬ ID ê°€ì ¸ì˜¤ê¸°
	vpsCategoryID, err := getCategoryIDByName("VPS")
	if err != nil {
		sendTelegram(uid, "âŒ VPS ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	// 2. í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ í™œì„± ìƒí’ˆ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
	var products []Product
	err = db.Where("category_id = ? AND active = 1", vpsCategoryID).Find(&products).Error
	if err != nil || len(products) == 0 {
		sendTelegram(uid, "âŒ VPS ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	// 3. ë²„íŠ¼ í–‰ ë°°ì—´ ìƒì„± (2ê°œì”© ë°°ì¹˜)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(products); i += 2 {
		if i+1 < len(products) {
			row := tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(products[i].Name, fmt.Sprintf("prod_%d", products[i].ID)),
				tgbotapi.NewInlineKeyboardButtonData(products[i+1].Name, fmt.Sprintf("prod_%d", products[i+1].ID)),
			)
			rows = append(rows, row)
		} else {
			// ë§ˆì§€ë§‰ì— í™€ìˆ˜ê°œì¸ ê²½ìš° í•œ ê°œë§Œ ë²„íŠ¼ ìƒì„±
			row := tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData(products[i].Name, fmt.Sprintf("prod_%d", products[i].ID)),
			)
			rows = append(rows, row)
		}
	}

	// 4. ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ì¶”ê°€
	backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë©”ë‰´ë¡œ ê°€ê¸°", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	// 5. ë©”ì‹œì§€ í¸ì§‘ ë° ì „ì†¡
	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ–¥ï¸ VPS|ê°€ìƒì„œë²„ ëª©ë¡\n\nì›í•˜ëŠ” ì‚¬ì–‘ì„ ì„ íƒí•˜ì„¸ìš”.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showVPSMenu ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
	}
}

func showLanguageMenu(uid, chatID, messageID int64) {
	text := "ğŸŒ ì–¸ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš” / Select Language"
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡°ğŸ‡·", "lang_ko"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡ºğŸ‡¸", "lang_en"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‡¨ğŸ‡³", "lang_zh"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main"),
		),
	)

	if messageID == 0 {
		msg := tgbotapi.NewMessage(chatID, text)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("showLanguageMenu ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	} else {
		edit := tgbotapi.NewEditMessageText(chatID, int(messageID), text)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showLanguageMenu ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
		}
	}
}

func handleLanguageSelection(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID

	var selectedLang string

	switch cb.Data {
	case "lang_ko":
		selectedLang = "ko"
	case "lang_en":
		selectedLang = "en"
	case "lang_zh":
		selectedLang = "zh"
	case "go_main":
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
		return
	default:
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤."))
		return
	}

	// ì–¸ì–´ ì €ì¥ í•¨ìˆ˜ í˜¸ì¶œ
	setUserLanguage(uid, selectedLang)

	// ì‘ë‹µ ë° ë©”ë‰´ ë‹¤ì‹œ í‘œì‹œ
	bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸŒ ì–¸ì–´ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."))
	showMenu(uid, cb.From.UserName, chatID)
}

func setUserLanguage(userID int64, lang string) {
	userLanguages[userID] = lang
}

func someCallbackHandler(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ìˆ˜ì •ëœ ë©”ì‹œì§€ ë‚´ìš©ì…ë‹ˆë‹¤.")
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
	}
}

func setUserLang(uid int64, lang string) error {
	// ì˜ˆì‹œ: ìœ ì € í…Œì´ë¸”ì´ ìˆê³  lang í•„ë“œê°€ ìˆë‹¤ë©´
	err := db.Model(&User{}).Where("id = ?", uid).Update("lang", lang).Error
	return err
}

func showSupportMenu(uid, chatID, messageID int64) {
	msgText := " ğŸ‘¤ ê³ ê°ì„¼í„° ë©”ë‰´ì…ë‹ˆë‹¤.\n\n ë¬¸ì˜ ë²„íŠ¼ì„ ëˆ„ë¥¸í›„ ëŒ€ê¸° í•´ì£¼ì„¸ìš”."
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ì‹¤ì‹œê°„ ë¬¸ì˜", "support_request"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main"),
		),
	)

	photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.ch.jpeg"))
	photo.Caption = msgText
	photo.ReplyMarkup = kb

	if _, err := bot.Send(photo); err != nil {
		log.Printf("ê³ ê°ì„¼í„° ë©”ë‰´(ì´ë¯¸ì§€) ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func getUserWallet(uid int64) string {
	var wallet UserWallet
	if err := db.Where("uid = ?", uid).First(&wallet).Error; err != nil {
		log.Printf("[ì§€ê°‘ì¡°íšŒ] uid: %d â†’ ì¡°íšŒ ì‹¤íŒ¨: %v", uid, err)
		return ""
	}
	log.Printf("[ì§€ê°‘ì¡°íšŒ] uid: %d â†’ ì§€ê°‘ì£¼ì†Œ: %s", uid, wallet.Address)
	return wallet.Address
}

func updateWalletUsername(uid int64, username string) {
	var wm WalletMap
	if err := db.Where("user_id = ?", uid).First(&wm).Error; err == nil {
		if wm.Username != username && username != "" {
			wm.Username = username
			db.Save(&wm)
		}
	}
}

func isDepositProcessed(txID string) bool {
	processedTxsMu.RLock()
	defer processedTxsMu.RUnlock()
	return processedTxs[txID]
}

func markDepositProcessed(txID string) {
	processedTxsMu.Lock()
	defer processedTxsMu.Unlock()
	processedTxs[txID] = true
}

func callTronGridAPI() {
	// íŠ¸ë¡ ê·¸ë¦¬ë“œ API í˜¸ì¶œ í•¨ìˆ˜ ì‹¤ì œ êµ¬í˜„ í•„ìš”
}

func handleUserActivityCommand(uid, chatID int64, page int) {
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
		return
	}

	const pageSize = 10
	offset := (page - 1) * pageSize
	var logs []UserActivityLog
	if err := db.Order("timestamp DESC").Offset(offset).Limit(pageSize).Find(&logs).Error; err != nil {
		sendTelegram(uid, "ë°©ë¬¸ì ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}
	if len(logs) == 0 {
		sendTelegram(uid, "ë°©ë¬¸ì ëª©ë¡ì´ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var total int64
	if err := db.Model(&UserActivityLog{}).Count(&total).Error; err != nil {
		sendTelegram(uid, "ì´ ë°©ë¬¸ì ìˆ˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	totalPages := int((total + pageSize - 1) / pageSize)
	msgText := formatUserActivitiesMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	msg := tgbotapi.NewMessage(chatID, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ë°©ë¬¸ì ê¸°ë³¸ ì •ë³´ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ (User íƒ€ì…)
func getUserListByPage(page int, pageSize int) ([]User, error) {
	offset := (page - 1) * pageSize
	var users []User
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

func formatUserListMessage(users []User, page, totalPages int) string {
	const pageSize = 10
	if len(users) == 0 {
		return "<b>ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(ì—†ìŒ)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}
		lastSeen := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\nìµœê·¼ ì ‘ì†: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			(i+1)+(page-1)*pageSize, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

func showUserListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, err := getUserListByPage(page, 10)
	if err != nil {
		sendTelegram(uid, "âŒ ë°©ë¬¸ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}
	var total int64
	err = db.Model(&User{}).Count(&total).Error
	if err != nil {
		// ì—ëŸ¬ ì²˜ë¦¬
		return // ë˜ëŠ” ì ì ˆí•œ ë°˜í™˜
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func formatUserActivityListMessage(logs []UserActivityLog, page, totalPages int) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	if len(logs) == 0 {
		sb.WriteString("ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.\n")
		return sb.String()
	}
	for _, act := range logs {
		lastActive := "(ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(ì—†ìŒ)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ ì‚¬ìš©ìID: %d / @%s / ë‹‰ë„¤ì„: %s\n  ìµœê·¼í™œë™: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			act.UserID, username, nickname, lastActive,
		))
	}
	return sb.String()
}

func showUserActivityListPage(cb *tgbotapi.CallbackQuery, page int) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	const pageSize = 10

	logs, total, err := getUserActivityListByPage(page, pageSize)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë°©ë¬¸ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨"))
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatUserActivityListMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("í˜ì´ì§€ %d ë¡œ ì´ë™", page)))
}

// í™œë™ ë¡œê·¸ ê¸°ë°˜ ë°©ë¬¸ì ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ (UserActivityLog íƒ€ì…)
func getUserActivityListByPage(page, pageSize int) ([]UserActivityLog, int64, error) {
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&UserActivityLog{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	var logs []UserActivityLog
	err := db.Order("timestamp DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&logs).Error

	return logs, total, err
}

// ë°©ë¬¸ì í˜ì´ì§€ ì „í™˜ ì½œë°± ì²˜ë¦¬ í•¨ìˆ˜
func handleVisitorPageCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	pageStr := strings.TrimPrefix(cb.Data, "visitors_page_")
	page, err := strconv.Atoi(pageStr)
	if err != nil || page < 1 {
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì˜ëª»ëœ í˜ì´ì§€ ë²ˆí˜¸ì…ë‹ˆë‹¤."))
		return
	}

	totalPages, err := getUserActivityTotalPages(10)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "í˜ì´ì§€ ê³„ì‚° ì‹¤íŒ¨"))
		return
	}

	visitors, err := getUserActivities(page, 10)
	if err != nil {
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë°©ë¬¸ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨"))
		return
	}

	var logs []UserActivityLog
	for _, u := range visitors {
		logs = append(logs, UserActivityLog{
			UserID:     u.UserID,
			Username:   u.UserName,
			Nickname:   u.Nickname,
			LastActive: u.LastSeen,
		})
	}

	msgText := formatUserActivitiesMessage(logs, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, fmt.Sprintf("í˜ì´ì§€ %d ë¡œ ì´ë™", page)))
}

// ì‚¬ìš©ì í™œë™ ë¡œê·¸ ì¡°íšŒ ë° í˜ì´ì§•
func getUserActivities(page, pageSize int) ([]User, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	err := db.Order("last_seen DESC").Offset(offset).Limit(pageSize).Find(&users).Error
	return users, err
}

// ì‚¬ìš©ì í™œë™ ì´ í˜ì´ì§€ ìˆ˜ ê³„ì‚°
// ì´ ë°©ë¬¸ì ìˆ˜ ê¸°ë°˜ ì´ í˜ì´ì§€ ê³„ì‚°
func getUserActivityTotalPages(pageSize int) (int, error) {
	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return 0, err
	}
	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	return totalPages, nil
}

func getCategoryIDByName(name string) (uint, error) {
	var cat Category
	err := db.Where("name = ?", name).First(&cat).Error
	if err != nil {
		return 0, err
	}
	return cat.ID, nil
}

func getGradeEmoji(grade string) string {
	switch grade {
	case "bronze":
		return "ğŸ¥‰"
	case "silver":
		return "ğŸ¥ˆ"
	case "gold":
		return "ğŸ¥‡"
	case "diamond":
		return "ğŸ’"
	case "vip":
		return "ğŸ‘‘"
	case "":
		return "â”" // ë“±ê¸‰ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°
	default:
		return "ğŸ¥‰"
	}
}

func updateUserLastSeen(user *tgbotapi.User) {
	err := db.Exec(`
		INSERT INTO users (user_id, username, nickname, last_seen)
		VALUES (?, ?, ?, NOW())
		ON DUPLICATE KEY UPDATE
			username = VALUES(username),
			nickname = VALUES(nickname),
			last_seen = NOW()
	`, user.ID, user.UserName, user.FirstName).Error

	if err != nil {
		log.Printf("updateUserLastSeen ì—ëŸ¬: %v", err)
	}
}

// showEnergyMenu í•¨ìˆ˜ ìˆ˜ì •ë³¸
func showEnergyMenu(uid int64, chatID int64, messageID int) {
	msgText := `<b>ğŸª« USDT ì†¡ê¸ˆ ìˆ˜ìˆ˜ë£Œ 80% ì ˆê°</b>

65K ì—ë„ˆì§€=<b>2.5TRX</b> (ì „ì†¡ 1íšŒ) 
ì˜ˆ:<b>10TRX</b> = 260K ì—ë„ˆì§€ (3~4íšŒ)

â± ì „ì†¡í›„ 10ì´ˆ ì´ë‚´ ì—ë„ˆì§€ í• ë‹¹

â¬‡ï¸ <b>ê²°ì œ ì£¼ì†Œ</b> â¬‡ï¸
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
<code>TDFfED6MK7hj6a9GXJMG3emXdd3b6XtHPn</code>
<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>
â¬†ï¸<b> ì£¼ì†Œ í´ë¦­ ì‹œ ìë™ ë³µì‚¬</b> â¬†ï¸

â³ ì—ë„ˆì§€ëŠ” 1ì‹œê°„ í›„ ìë™ ì†Œë©¸
âš ï¸ USDT ì—†ëŠ” ìƒˆ ì§€ê°‘ìœ¼ë¡œ ì†¡ê¸ˆ 
130K ì—ë„ˆì§€ (5 TRX) í•„ìš”í•˜ë‹ˆ
ì†¡ê¸ˆ ì „ ìˆ˜ìˆ˜ë£Œ í™•ì¸ í•„ìˆ˜

<b>ì£¼ì†Œ ë³€ê²½ì‹œ ë´‡ì´ ìë™ì•ŒëŒ</b>

ğŸš¨ 
íŒë§¤ìê°€ ë¶ˆë¶„ëª…í•œ ì‹œê°„ì§§ì€ 
ì—ë„ˆì§€ëŠ” ì‚¬ìš©X 10ë¶„ ì—ë„ˆì§€ëŠ” ì‹œê°„ì´
ì´‰ë°•í•´ ì£¼ì†Œë¥¼ ë³µì‚¬í•˜ì—¬ ì „ì†¡í•˜ëŠ” 
ì½”ì¸ íŠ¹ì„±ìƒ ì˜¤ì†¡ê¸ˆì´ ìì£¼ì¼ì–´ë‚˜ëŠ”ë° 
í”¼í•´ë³µêµ¬ ë¶ˆê°€ íŒë§¤ì²˜ ê¼­ í™•ì¸í›„ êµ¬ë§¤
í•´ì™¸ì—ì„  ì˜¤ì†¡ê¸ˆ ìœ¼ë¡œ ë§ˆì§„ì„ ë´…ë‹ˆë‹¤.
ì§€ê°‘ ì£¼ì†Œë¡ì— ì£¼ì†Œë¥¼ ì €ì¥í•˜ì„¸ìš”.`

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageCaption(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("showEnergyMenu ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v, ìƒˆ ë©”ì‹œì§€ë¡œ ëŒ€ì²´ ì „ì†¡ ì‹œë„", err)
			// í¸ì§‘ ì‹¤íŒ¨ ì‹œ ìƒˆ ë©”ì‹œì§€ ì „ì†¡
			photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("tg.trx.jpeg"))
			photoMsg.Caption = msgText
			photoMsg.ParseMode = "HTML"
			photoMsg.ReplyMarkup = kb
			if _, err := bot.Send(photoMsg); err != nil {
				log.Printf("showEnergyMenu ì‚¬ì§„+ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
			}
		}
	} else {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath("/home/minho/epusdt/images/energy_image.jpeg"))
		photoMsg.Caption = msgText
		photoMsg.ParseMode = "HTML"
		photoMsg.ReplyMarkup = kb

		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("showEnergyMenu ì‚¬ì§„+ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func getUserDisplayName(uid int64) string {
	var user User
	if err := db.First(&user, "user_id = ?", uid).Error; err == nil {
		if user.UserName != "" {
			return user.UserName
		}
		return user.Nickname
	}
	return "unknown"
}

func generateWalletAddress() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return fmt.Sprintf("T%x", bytes), nil
}

func showBalanceMenu(uid int64, chatID int64, messageID int) {
	username := getUserDisplayName(uid)
	var balance UserBalance
	err := db.First(&balance, "user_id = ?", uid).Error
	if err != nil {
		log.Printf("ì‚¬ìš©ì ì”ì•¡ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		balance.Balance = 0.0
		balance.UserID = uid
	}

	// ğŸ‘‡ ë“±ê¸‰ ì´ëª¨ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì¶”ê°€!
	gradeEmoji := "â”"
	var user User
	if err := db.Where("user_id = ?", uid).First(&user).Error; err == nil {
		gradeEmoji = getGradeEmoji(user.Grade)
	}

	msgText := fmt.Sprintf(
		"ğŸªªë‚´ ì •ë³´\n"+
			"ğŸ†” ê³ ìœ ë²ˆí˜¸: <code>%d</code>\n"+
			"ğŸ‘¤ ìœ ì €ë„¤ì„: <b>%s</b>\n"+
			"ğŸ•’: <b>%s</b>\n"+
			"ë“±ê¸‰: %s\n\n"+
			"ğŸ¦: <b>%.3f USDT</b>",
		uid, username, time.Now().Format("2006-01-02 15:04"), gradeEmoji, balance.Balance,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’² ì”ì•¡ì¶©ì „", "show_deposit_menu"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ§¾ ì£¼ë¬¸ë‚´ì—­", "handle_show_orders"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "go_main"),
		),
	)

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		if _, err := bot.Send(edit); err != nil {
			log.Printf("ì”ì•¡ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		if _, err := bot.Send(msg); err != nil {
			log.Printf("ì”ì•¡ ë©”ë‰´ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func sendDepositMenuNewMessage(uid int64) {
	text := "<b>ì¶©ì „ ê¸ˆì•¡ì„ ì„ íƒí•˜ì„¸ìš”</b>\n\n" +
		"ì›í•˜ëŠ” ê¸ˆì•¡ ë²„íŠ¼ì„ ëˆ„ë¥´ê±°ë‚˜, ì•„ë˜ì— ì§ì ‘ USDT ê¸ˆì•¡ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”."

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("10 USDT", "deposit_amount_10"),
			tgbotapi.NewInlineKeyboardButtonData("50 USDT", "deposit_amount_50"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("100 USDT", "deposit_amount_100"),
			tgbotapi.NewInlineKeyboardButtonData("ì§ì ‘ ì…ë ¥", "deposit_custom"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "balance_menu"),
		),
	)

	msg := tgbotapi.NewMessage(uid, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = kb
	bot.Send(msg)
}

/*
	func handlePhotoMessage(msg *tgbotapi.Message) {
		uid := int64(msg.From.ID)

		mu.Lock()
		waiting := waitingForImage[uid]
		mu.Unlock()

		if !waiting {
			sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
			return
		}

		photos := msg.Photo
		if len(photos) == 0 {
			sendTelegram(uid, "â—ï¸ ì‚¬ì§„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.")
			return
		}
		photo := photos[len(photos)-1]

		mu.Lock()
		pendingStockImageID[uid] = photo.FileID
		waitingForImage[uid] = false
		mu.Unlock()

		mu.Lock()
		stockInput := pendingStockInputBuffer[uid]
		mu.Unlock()

		err := saveStockWithImage(uid, stockInput, photo.FileID)
		if err != nil {
			log.Printf("ì¬ê³  ì €ì¥ ì‹¤íŒ¨ uid=%d err=%v", uid, err)
			sendTelegram(uid, "âŒ ì¬ê³  ë“±ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
			return
		}

		sendTelegram(uid, "âœ… ì¬ê³ ê°€ ì‚¬ì§„ê³¼ í•¨ê»˜ ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.")

		mu.Lock()
		delete(pendingStockInputBuffer, uid)
		delete(pendingStockImageID, uid)
		mu.Unlock()
	}
*/
func saveUserWallet(userID int64, wallet, username string) error {
	var wm WalletMap
	err := db.Where("user_id = ?", userID).First(&wm).Error
	if err == nil {
		wm.Wallet = wallet
		wm.Username = username
		if err := db.Save(&wm).Error; err != nil {
			log.Printf("saveUserWallet: DB ì €ì¥ ì‹¤íŒ¨ userID=%d, err=%v", userID, err)
			return err
		}
		return nil
	}
	if errors.Is(err, gorm.ErrRecordNotFound) {
		wm = WalletMap{
			UserID:   userID,
			Wallet:   wallet,
			Username: username,
		}
		if err := db.Create(&wm).Error; err != nil {
			log.Printf("saveUserWallet: DB ìƒì„± ì‹¤íŒ¨ userID=%d, err=%v", userID, err)
			return err
		}
		return nil
	}
	log.Printf("saveUserWallet: DB ì¡°íšŒ ì‹¤íŒ¨ userID=%d, err=%v", userID, err)
	return err
}

func handleOrder(productCode string, uid, chatID, messageID int64) error {
	var prodName string
	var price float64
	found := false
	for _, prods := range cardCategories {
		for name, prod := range prods {
			if prod.Code == productCode {
				prodName = name
				price = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}

	if !found {
		sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return fmt.Errorf("ìƒí’ˆ ì •ë³´ ì—†ìŒ")
	}

	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        nil, // NULLë¡œ ì„¤ì •
	}
	if err := db.Create(&order).Error; err != nil {
		sendTelegram(uid, "âŒ ì£¼ë¬¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		log.Printf("handleOrder: ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨ userID=%d, err=%v", uid, err)
		return fmt.Errorf("ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	uniqueAmt := price + float64(order.ID)/1000.0 // newOrder â†’ order
	uniqueAmt = math.Floor(uniqueAmt*1000) / 1000

	if err := db.Model(&order).Update("expected_amt", uniqueAmt).Error; err != nil { // newOrder â†’ order
		log.Printf("handleOrder: ExpectedAmt ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ orderID=%d, err=%v", order.ID, err)
	}

	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		coinAddr = "TRON-USDT-ì…ê¸ˆì£¼ì†Œ"
	}
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID) // newOrder â†’ order
	if err := generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", coinAddr, uniqueAmt), qrPath); err != nil {
		log.Printf("QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨: %v", err)
	}

	msgText := fmt.Sprintf(
		"ğŸ›’ <b>ì£¼ë¬¸ ì ‘ìˆ˜ ì™„ë£Œ</b>\n\n"+
			"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\n ìƒí’ˆëª…: <b>%s</b>\n ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
			"(ì†Œìˆ˜ì ê¹Œì§€ ì •í™•í•˜ê²Œ, QR ì½”ë“œ í™œìš© ê¶Œì¥)\n20ë¶„ ë‚´ ë¯¸ì…ê¸ˆì‹œ ìë™ì·¨ì†Œ ë©ë‹ˆë‹¤.",
		order.ID, prodName, uniqueAmt, // newOrder â†’ order
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì£¼ë¬¸ì·¨ì†Œ", fmt.Sprintf("cancel_order_%d", order.ID)), // newOrder â†’ order
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("handleOrder: ê²°ì œ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ userID=%d, err=%v", uid, err)
	} else {
		userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)
	}

	if qrPath != "" {
		photoMsg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photoMsg.Caption = fmt.Sprintf(
			"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•í•œ ê¸ˆì•¡</b>ì„ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n<code>%s</code>\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\nì£¼ì†Œ í´ë¦­ì‹œ ë³µì‚¬ ë©ë‹ˆë‹¤.",
			coinAddr,
		)
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("handleOrder: QR ì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡ ì‹¤íŒ¨ userID=%d, err=%v", uid, err)
		}
	}

	go func(orderID uint, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
			ord.Status = "ìë™ì·¨ì†Œ"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("handleOrder: ì£¼ë¬¸ ìë™ì·¨ì†Œ ì €ì¥ ì‹¤íŒ¨ orderID=%d, err=%v", orderID, err)
				return
			}
			sendTelegram(userID, fmt.Sprintf("âŒ ì£¼ë¬¸ #%d 20ë¶„ ë‚´ ë¯¸ì…ê¸ˆìœ¼ë¡œ ìë™ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.", orderID))
		}
	}(order.ID, uid) // newOrder â†’ order

	return nil
}

func createOrderAndUpdateBalance(userID int64, prodName string, price float64, txID string) error {
	return db.Transaction(func(tx *gorm.DB) error {
		txIDPtr := &txID // string í¬ì¸í„° ìƒì„±

		order := Order{
			UserID:      userID,
			Product:     prodName,
			Amount:      price,
			Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
			TxID:        txIDPtr,
		}
		if err := tx.Create(&order).Error; err != nil {
			return err
		}

		if err := tx.Model(&UserBalance{}).Where("user_id = ?", userID).
			Update("balance", gorm.Expr("balance + ?", price)).Error; err != nil {
			return err
		}
		return nil
	})
}

func showDepositConfirm(uid, chatID int64, messageID int, amount float64) {
	amountStr := fmt.Sprintf("%.3f", amount)
	encodedAmount := base64.StdEncoding.EncodeToString([]byte(amountStr))
	callbackData := "confirm_deposit_" + encodedAmount

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœ… í™•ì¸", callbackData),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "show_deposit_menu"),
		),
	)
	text := fmt.Sprintf("ğŸ’¸ <b>%.3f USDT</b> ì¶©ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", amount)
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ì…ê¸ˆ ì£¼ì†Œ ë° QRì½”ë“œ ì•ˆë‚´
func showDepositAddress(uid, chatID int64, messageID int, amount float64) {
	addr, err := getWalletAddress(uid)
	if err != nil || addr == "" {
		sendTelegram(chatID, "â—ï¸ ì…ê¸ˆ ì§€ê°‘ì´ ë“±ë¡ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.\n\në¨¼ì € <b>/ì…ê¸ˆì§€ê°‘ë“±ë¡ [ì§€ê°‘ì£¼ì†Œ]</b> ëª…ë ¹ì–´ë¡œ ë“±ë¡í•´ ì£¼ì„¸ìš”.")
		return
	}

	var username string
	if err := db.Model(&User{}).Select("username").Where("user_id = ?", uid).Take(&username).Error; err != nil {
		username = "-"
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf(
			"ğŸ†” <b>ê³ ìœ ë²ˆí˜¸</b>: <code>%d</code>\n"+
				"ğŸ‘¤ <b>ìœ ì €ë„¤ì„</b>: %s\n\n"+
				"ğŸ’² <b>ì…ê¸ˆ ì•ˆë‚´</b>\n"+
				"ì…ê¸ˆ ì£¼ì†Œ: <code>%s</code>\n"+
				"ì…ê¸ˆ ê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
				"ì…ê¸ˆ ì™„ë£Œ í›„, ìë™ìœ¼ë¡œ ì”ì•¡ì´ ì¶©ì „ë©ë‹ˆë‹¤.",
			uid, username, addr, amount,
		),
	)
	editMsg.ParseMode = "HTML"

	if _, err = bot.Send(editMsg); err != nil {
		log.Printf("ë©”ì‹œì§€ í¸ì§‘ ì‹¤íŒ¨: %v", err)
	}

	qrFilename := fmt.Sprintf("./qrcodes/wallet_%d_%d.png", uid, time.Now().UnixNano())
	qrData := fmt.Sprintf("%s?amount=%.3f", addr, amount)

	if err := generateWalletQRCode(qrData, qrFilename); err == nil {
		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrFilename))
		photo.Caption = fmt.Sprintf(
			"ğŸ’³ <b>ì…ê¸ˆì£¼ì†Œ QR</b> (%.3f USDT)\n\n<code>%s</code>",
			amount, addr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("showDepositAddress: QRì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡ ì‹¤íŒ¨ chatID=%d err=%v", chatID, err)
		}
	} else {
		log.Printf("showDepositAddress: QR ìƒì„± ì‹¤íŒ¨ err=%v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ìƒì„¸ ëª©ë¡ í‘œì‹œ í•¨ìˆ˜ ì˜ˆì‹œ
func showAdminStockList(chatID int64, messageID int) {
	// TODO: DBì—ì„œ ì¬ê³  ëª©ë¡ ì¡°íšŒ í›„ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ë˜ëŠ” ë©”ì‹œì§€ í¸ì§‘ìœ¼ë¡œ ì¶œë ¥
	msgText := "ğŸ“‹ ì¬ê³  ìƒì„¸ ëª©ë¡ (ì˜ˆì‹œ)\n- ìƒí’ˆA: 10ê°œ\n- ìƒí’ˆB: 5ê°œ\n- ìƒí’ˆC: 0ê°œ\n"
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì¬ê³  ìƒì„¸ ëª©ë¡ ì¶œë ¥ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ì‚­ì œ ì•ˆë‚´ í•¨ìˆ˜ ì˜ˆì‹œ
func promptStockDeletion(chatID int64) {
	msgText := "ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\nì‚­ì œí•  ì¬ê³  í•­ëª© ì½”ë“œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ì¶”ê°€ ì•ˆë‚´ í•¨ìˆ˜ ì˜ˆì‹œ
func promptStockAddition(chatID int64) {
	msgText := "â• ì¬ê³  ì¶”ê°€ ê¸°ëŠ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\nì¶”ê°€í•  ì¬ê³  í•­ëª© ì •ë³´ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
	msg := tgbotapi.NewMessage(chatID, msgText)
	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì¬ê³  ì¶”ê°€ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ í•¨ìˆ˜ ì˜ˆì‹œ
func showAdminMainMenu(chatID int64, messageID int) {
	msgText := "ğŸ‘‘ ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ì…ë‹ˆë‹¤."
	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ë©”ì¸ ë©”ë‰´ ì¶œë ¥ ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ í‘œì‹œ
func showAdminStockMenuSimple(chatID int64, messageID int) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ìƒì„¸ ë³´ê¸°", "admin_stock_list")},
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ", "admin_stock_delete")},
		{tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³  ì¶”ê°€", "admin_stock")},
		{tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu")},
	}

	if messageID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, messageID, "ê´€ë¦¬ìë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.")
		edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
		if _, err := bot.Send(edit); err != nil {
			log.Printf("ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
		}
	} else {
		msg := tgbotapi.NewMessage(chatID, "ê´€ë¦¬ìë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.")
		msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(rows...)
		if _, err := bot.Send(msg); err != nil {
			log.Printf("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func showAdminSettings(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ê´€ë¦¬ì ì¶”ê°€", "admin_add"),
			tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ê³µì§€", "admin_notice"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "í™˜ê²½ì„¤ì • âš™ï¸")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ìˆ˜ì • ë©”ë‰´ ì‹¤íŒ¨: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨")); callbackErr != nil {
			log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

func showAdminVisitorMenu(chatID int64, messageID int, callbackID string) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“… ë‹¹ì¼ ë°©ë¬¸ì", "admin_list_visitors_today"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“† ì „ì²´ ë°©ë¬¸ì", "admin_list_visitors"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ‘¥ ë°©ë¬¸ì ì¡°íšŒ ë©”ë‰´")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
		if _, callbackErr := bot.Request(tgbotapi.NewCallback(callbackID, "ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨")); callbackErr != nil {
			log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", callbackErr)
		}
		return
	}

	if _, err := bot.Request(tgbotapi.NewCallback(callbackID, "")); err != nil {
		log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

// í†µê³„ ë°ì´í„° ì¡°íšŒ (ìƒˆë¡œìš´ ë²„ì „)
func getDailyStatsNew() (SalesStats, error) {
	today := time.Now().Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func handleListStockCommand(msg *tgbotapi.Message) {
	// ê´€ë¦¬ììš© ì¬ê³  ëª©ë¡ ì¶œë ¥ (ê°„ë‹¨ ì˜ˆì‹œ)
	sendTelegram(int64(msg.From.ID), "ğŸ“¦ ì¬ê³  ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.")
}

func handleAddAdminCommand(msg *tgbotapi.Message) {
	// ê´€ë¦¬ì ì¶”ê°€ ì²˜ë¦¬ (ì˜ˆì‹œ)
	sendTelegram(int64(msg.From.ID), "ğŸ‘¤ ê´€ë¦¬ì ì¶”ê°€ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.")
}

func handleCancelOrderCommand(msg *tgbotapi.Message) {
	// ì£¼ë¬¸ ì·¨ì†Œ ì²˜ë¦¬ (ì˜ˆì‹œ)
	sendTelegram(int64(msg.From.ID), "âŒ ì£¼ë¬¸ ì·¨ì†Œ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.")
}

func formatUserActivitiesMessage(activities []UserActivityLog, page, totalPages int) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	if len(activities) == 0 {
		sb.WriteString("ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.\n")
		return sb.String()
	}
	for _, act := range activities {
		lastActive := "(ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(ì—†ìŒ)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ ì‚¬ìš©ìID: %d / @%s / ë‹‰ë„¤ì„: %s\n  ìµœê·¼í™œë™: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			act.UserID, username, nickname, lastActive,
		))
	}
	return sb.String()
}

func createUserActivityKeyboard(page, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	var topButtons []tgbotapi.InlineKeyboardButton

	if page > 1 {
		topButtons = append(topButtons, tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸", fmt.Sprintf("visitors_page_%d", page-1)))
	}
	if page < totalPages {
		topButtons = append(topButtons, tgbotapi.NewInlineKeyboardButtonData("â¡ï¸", fmt.Sprintf("visitors_page_%d", page+1)))
	}

	if len(topButtons) > 0 {
		rows = append(rows, topButtons) // ìƒë‹¨ 2ê°œ ë²„íŠ¼ í•œ ì¤„
	}

	// ë§ˆì§€ë§‰ ì¤„ì— 'ë’¤ë¡œê°€ê¸°' ë²„íŠ¼ ì¶”ê°€
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "admin_menu"),
	))

	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

// ì™¸ë¶€ ì‹œìŠ¤í…œì— ì½œë°± URL ë“±ë¡ ìš”ì²­
func notifyExternalSystem(url string) error {
	reqBody := strings.NewReader(`{"callback_url":"` + url + `"}`)

	req, err := http.NewRequest("POST", "https://external.api/register", reqBody)
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", "Bearer "+os.Getenv("EPUSDT_API_TOKEN"))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("ì™¸ë¶€ API ë“±ë¡ ì‹¤íŒ¨, ìƒíƒœì½”ë“œ: %d, ì‘ë‹µ: %s", resp.StatusCode, string(body))
	}

	return nil
}

// .env íŒŒì¼ì— ngrok ë° ê´€ë ¨ URL ìë™ ì—…ë°ì´íŠ¸
func updateEnvNgrokURL(envPath, newURL string) error {
	data, err := os.ReadFile(envPath)
	if err != nil {
		return err
	}

	lines := strings.Split(string(data), "\n")
	updates := map[string]string{
		"NGROK_URL":         "NGROK_URL=" + newURL,
		"WEBHOOK_URL":       "WEBHOOK_URL=" + newURL + "/webhook",
		"EPUSDT_API_URL":    "EPUSDT_API_URL=" + newURL + "/api/notify/set",
		"EPUSDT_NOTIFY_URL": "EPUSDT_NOTIFY_URL=" + newURL + "/epusdt_notify",
	}

	keysUpdated := make(map[string]bool)
	var newLines []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			newLines = append(newLines, line)
			continue
		}
		parts := strings.SplitN(trimmed, "=", 2)
		key := parts[0]
		if val, ok := updates[key]; ok && !keysUpdated[key] {
			newLines = append(newLines, val)
			keysUpdated[key] = true
		} else {
			newLines = append(newLines, line)
		}
	}

	// ìƒˆë¡œ ì¶”ê°€í•  í‚¤ë“¤ ì¶”ê°€
	for key, val := range updates {
		if !keysUpdated[key] {
			newLines = append(newLines, val)
		}
	}

	output := strings.Join(newLines, "\n") + "\n"
	return os.WriteFile(envPath, []byte(output), 0644)
}

// [3] íŠ¸ë¡  ì…ê¸ˆì²´í¬ â†’ ì£¼ë¬¸ìƒì„±/ì”ì•¡ê°±ì‹  ì²˜ë¦¬ ì „ì²´ í•¨ìˆ˜
func checkTronDeposits() {
	walletList, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì§€ê°‘ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return
	}

	for _, wallet := range walletList {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì…ê¸ˆ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
			continue
		}

		for _, deposit := range deposits {
			amount := deposit.Amount // float64
			txID := deposit.TxID     // string
			productName := "ë¯¸ë§¤ì¹­ì…ê¸ˆ"   // ìƒí’ˆë§¤ì¹­ í•„ìš”ì‹œ ë¡œì§ ì¶”ê°€

			err := createOrderAndUpdateBalance(wallet.UserID, productName, amount, txID)
			if err != nil {
				log.Printf("[ì£¼ë¬¸ì²˜ë¦¬] ì‹¤íŒ¨: %v", err)
				continue
			}
		}
	}
}

func answerCallbackQuery(callbackID, text string) {
	callback := tgbotapi.NewCallback(callbackID, text)
	if _, err := bot.Request(callback); err != nil {
		log.Printf("CallbackQuery ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

func processTronTransaction(tx TronTransaction) {
	processedTxsMu.Lock()
	if processedTxs[tx.TxID] {
		processedTxsMu.Unlock()
		return
	}
	processedTxs[tx.TxID] = true
	processedTxsMu.Unlock()

	// ì´ë¯¸ ì²˜ë¦¬ëœ TX í™•ì¸
	var existing Order
	if err := db.Where("tx_id = ?", tx.TxID).First(&existing).Error; err == nil {
		return
	}

	amount, err := strconv.ParseFloat(tx.AmountStr, 64)
	if err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì…ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨ txid=%s, value=%s", tx.TxID, tx.AmountStr)
		return
	}

	var order Order
	err = db.Where("expected_amt = ? AND status = ?", amount, "ì…ê¸ˆëŒ€ê¸°ì¤‘").First(&order).Error
	if err != nil {
		err = db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.001, amount+0.001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").First(&order).Error
	}
	if err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: amount=%.3f", amount)
		createUnmatchedOrder(amount, tx)
		return
	}

	// ì£¼ë¬¸ì— TXID ì„¤ì • ë° ì €ì¥
	setOrderTxID(&order, tx.TxID)
	if err := db.Save(&order).Error; err != nil {
		log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
		return
	}

	// ì”ì•¡ì¶©ì „ ìƒí’ˆì¸ ê²½ìš° ì”ì•¡ë§Œ ì¶©ì „ í›„ ì¢…ë£Œ
	if order.Product == "ì”ì•¡ì¶©ì „" {
		if err := addUserBalance(order.UserID, order.Amount); err != nil {
			sendTelegram(order.UserID, "âŒ ì”ì•¡ ì¶©ì „ ì‹¤íŒ¨! ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.")
			log.Printf("[ì”ì•¡ì¶©ì „] ì˜¤ë¥˜: %v", err)
		} else {
			sendTelegram(order.UserID, fmt.Sprintf("âœ… %.3f USDT ì”ì•¡ì´ ì¶©ì „ë˜ì—ˆìŠµë‹ˆë‹¤!", order.Amount))
		}
		return
	}

	// ì‚¬ìš©ì, ê´€ë¦¬ì ì•Œë¦¼
	userMsg := fmt.Sprintf(
		"ğŸŸ¢ *ì…ê¸ˆ í™•ì¸ ì™„ë£Œ!*\n\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ“‹ ì£¼ë¬¸ë²ˆí˜¸: #%d\n"+
			"ğŸ“¦ ìƒí’ˆëª…: %s\n"+
			"ğŸ’° ì…ê¸ˆê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— íŠ¸ëœì­ì…˜: `%s`\n"+
			"â° í™•ì¸ì‹œê°„: %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"âœ… ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n"+
			"ğŸš€ ìƒí’ˆì´ ê³§ ìë™ìœ¼ë¡œ ì§€ê¸‰ë©ë‹ˆë‹¤.",
		order.ID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	msg := tgbotapi.NewMessage(order.UserID, userMsg)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	adminMsg := fmt.Sprintf(
		"ğŸŸ¢ *ì…ê¸ˆ í™•ì¸ (ë§¤ì¹­ë¨)*\n\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ“‹ ì£¼ë¬¸ë²ˆí˜¸: #%d\n"+
			"ğŸ‘¤ ìœ ì €ë„¤ì„: %d\n"+
			"ğŸ“¦ ìƒí’ˆ: %s\n"+
			"ğŸ’° ê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— TxID: `%s`\n"+
			"â° ì‹œê°„: %s\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"âœ… ìë™ ì¹´ë“œ ì§€ê¸‰ ì²˜ë¦¬ ì¤‘...",
		order.ID, order.UserID, order.Product, amount, tx.TxID, time.Now().Format(timeFormat),
	)
	adminMsgObj := tgbotapi.NewMessage(unmatchedAdminChatID, adminMsg)
	adminMsgObj.ParseMode = "HTML"
	bot.Send(adminMsgObj)

	// ìë™ ì¹´ë“œ ì§€ê¸‰ ë¹„ë™ê¸° ì²˜ë¦¬
	go func(orderID uint, userID int64, txID string) {
		if err := processOrderWithValidation(orderID, txID); err != nil {
			log.Printf("[ìë™ì§€ê¸‰] ì‹¤íŒ¨ orderID=%d, err=%v", orderID, err)
			msg := tgbotapi.NewMessage(userID, "âŒ ì§€ê¸‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê³ ê°ì„¼í„°ë¡œ ë¬¸ì˜í•˜ì„¸ìš”.")
			bot.Send(msg)
		}
	}(order.ID, order.UserID, tx.TxID)
}

// TxID ì„¤ì • ë³´ì¡° í•¨ìˆ˜ (sql.NullString íƒ€ì…ì— ëŒ€ì‘)
func setOrderTxID(order *Order, txID string) {
	order.TxID = &txID // âœ… string ê°’ë§Œ í• ë‹¹
}

func toFixed3(f float64) float64 {
	return math.Floor(f*1000) / 1000
}

// Telegram ë©”ì‹œì§€ ì „ì†¡ (ì—ëŸ¬ ë¡œê¹… í¬í•¨)
func notifySend(chatID int64, msg string) {
	if err := sendTelegram(chatID, msg); err != nil {
		log.Printf("Telegram ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ (chatID=%d): %v", chatID, err)
	}
}

// í•œ ë²ˆì— 10ëª…ì”©, í˜ì´ì§€ë„¤ì´ì…˜ ì§€ì›
func getAllUsers() ([]User, error) {
	var users []User
	if err := db.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

// ì „ì²´ ìœ ì € ìˆ˜ ì¹´ìš´íŠ¸
func getUserCount() (int64, error) {
	var count int64
	err := db.Model(&User{}).Count(&count).Error
	return count, err
}

func showAdminAllUsersMenu(chatID int64, messageID int, page int) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	users, err := getUsersByPage(pageSize, offset)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì „ì²´ ìœ ì € ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ë” ì´ìƒ ì¡°íšŒí•  ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤.")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("ğŸ‘¥ ì „ì²´ ìœ ì € (Page %d)\n\n", page)
	var rows [][]tgbotapi.InlineKeyboardButton
	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(ë‹‰ë„¤ì„ì—†ìŒ)"
		}
		username := user.UserName
		if username == "" {
			username = "ì—†ìŒ"
		}
		text += fmt.Sprintf("%d. <b>%s</b> <code>%d</code> @%s - %s\n", i+1, nickname, user.UserID, username, user.LastSeen.Format("01-02 15:04"))
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s", nickname),
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// í˜ì´ì§• ë²„íŠ¼
	var navigation []tgbotapi.InlineKeyboardButton
	if page > 1 {
		navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ì´ì „", fmt.Sprintf("admin_all_users_page_%d", page-1)))
	}
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ìë©”ë‰´", "admin_menu"))
	navigation = append(navigation, tgbotapi.NewInlineKeyboardButtonData("â¡ï¸ ë‹¤ìŒ", fmt.Sprintf("admin_all_users_page_%d", page+1)))

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(navigation...))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	msg.ParseMode = "HTML"
	bot.Request(msg)
}

func showAdminCategoryMenu(chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	var rows [][]tgbotapi.InlineKeyboardButton

	// 2ê°œì”© ë²„íŠ¼ì„ ë¬¶ì–´ í•œ í–‰(row)ì— ì¶”ê°€
	for i := 0; i < len(categories); i += 2 {
		end := i + 2
		if end > len(categories) {
			end = len(categories)
		}
		var row []tgbotapi.InlineKeyboardButton
		for _, cat := range categories[i:end] {
			var callbackData string
			if cat == "VPS" {
				callbackData = "menu_vps" // VPSëŠ” ë³„ë„ ë©”ë‰´ë¡œ ì—°ê²°
			} else {
				callbackData = "admin_cat_" + cat
			}
			btn := tgbotapi.NewInlineKeyboardButtonData(cat, callbackData)
			row = append(row, btn)
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ì ë©”ë‰´", "admin_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ“‚ìƒí’ˆìˆ˜ì • ì¹´í…Œê³ ë¦¬ ì„ íƒ")
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// ì¹´í…Œê³ ë¦¬ëª…(category)ìœ¼ë¡œ ìƒí’ˆ ì¡°íšŒ
func showAdminProductListByCategory(chatID int64, messageID int, category string) {
	var products []Product

	err := db.Where("category = ?", category).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID,
			fmt.Sprintf("â—ï¸ [%s] ì¹´í…Œê³ ë¦¬ì— ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.\nìƒˆ ìƒí’ˆì„ ì¶”ê°€í•´ ì£¼ì„¸ìš”.", category))
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_prod_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¹´í…Œê³ ë¦¬ë¡œ", "admin_category_menu"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID,
		fmt.Sprintf("ğŸ“¦ [%s] ìƒí’ˆ ëª©ë¡\nìƒí’ˆì„ ì„ íƒí•˜ì„¸ìš”.", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// ë¯¸ë§¤ì¹­ ì…ê¸ˆ ì£¼ë¬¸ ìƒì„± ë° ê´€ë¦¬ì ì•Œë¦¼
func createUnmatchedOrder(amount float64, tx TronTransaction) {
	unmatchedMsg := fmt.Sprintf(
		"ğŸŸ¢ *ë¯¸ë§¤ì¹­ ì…ê¸ˆ ê°ì§€*\n\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"+
			"ğŸ’° ê¸ˆì•¡: %.3f USDT\n"+
			"ğŸ”— íŠ¸ëœì­ì…˜: `%s`\n"+
			"â° ì‹œê°„: %s\n"+
			"ğŸ“¤ ë³´ë‚¸ì£¼ì†Œ: `%s`\n"+
			"ğŸ“¥ ë°›ì€ì£¼ì†Œ: `%s`\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"+
			"â“ ìƒíƒœ: ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤\n"+
			"ğŸ’¡ ì¡°ì¹˜: ìˆ˜ë™ í™•ì¸ í•„ìš”\n\n"+
			"ğŸ” ì£¼ë¬¸ë²ˆí˜¸ì™€ ê¸ˆì•¡ ë‹¤ì‹œ í™•ì¸ ë¶€íƒë“œë¦½ë‹ˆë‹¤.",
		amount, tx.TxID, time.Now().Format("2006-01-02 15:04:05"),
		tx.From, tx.To,
	)

	notifySend(unmatchedAdminChatID, unmatchedMsg)

	txID := tx.TxID
	order := Order{
		UserID:      0,
		Product:     "ë¯¸ìƒ",
		Amount:      amount,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: amount,
		TxID:        &txID, // í¬ì¸í„° í• ë‹¹
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("ë¯¸ë§¤ì¹­ ì…ê¸ˆ ì£¼ë¬¸ ì €ì¥ ì‹¤íŒ¨: %v", err)
	}
}

func updateUserGrade(userID int64, newGrade string) error {
	// 1. ë“±ê¸‰ ì—…ë°ì´íŠ¸
	err := db.Model(&User{}).Where("user_id = ?", userID).Update("grade", newGrade).Error
	if err != nil {
		log.Printf("ë“±ê¸‰ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ userID=%d, newGrade=%s, err=%v", userID, newGrade, err)
		return err
	}

	// 2. ì—…ë°ì´íŠ¸ ì„±ê³µ ì‹œ ìœ ì € ì •ë³´ ì¬ì¡°íšŒ (username, chatID í•„ìš”)
	var user User
	if err := db.Where("user_id = ?", userID).First(&user).Error; err != nil {
		log.Printf("ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ userID=%d, err=%v", userID, err)
		return nil // ë“±ê¸‰ ë³€ê²½ì€ ì„±ê³µí–ˆìœ¼ë¯€ë¡œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
	}

	username := user.UserName
	if username == "" {
		username = "unknown"
	}

	msgText := fmt.Sprintf(
		"ğŸ”” <b>íšŒì› ë“±ê¸‰ ë³€ê²½ ì•Œë¦¼</b>\n\n"+
			"ìœ ì €ë„¤ì„: <b>@%s</b> ë‹˜.\n"+
			"ë“±ê¸‰ì´ ì„±ê³µì ìœ¼ë¡œ <b>%s</b> ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"+
			"ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ê²½í—˜í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤.\n"+
			"WELCOME",
		username, newGrade,
	)

	msg := tgbotapi.NewMessage(user.ChatID, msgText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("íšŒì› ë“±ê¸‰ ë³€ê²½ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨ userID=%d: %v", userID, err)
	}

	return nil
}

// â”€â”€â”€ value(AmountStr) â†’ float64 ë³€í™˜ ìœ í‹¸ â”€â”€â”€
func parseUSDTAmount(raw string) float64 {
	val, _ := strconv.ParseFloat(raw, 64)
	return val / 1_000_000 // TRC20 USDTëŠ” ì†Œìˆ˜ì  6ìë¦¬(1 USDT == 1,000,000)
}

// â”€â”€â”€ íƒ€ì„ìŠ¤íƒ¬í”„(ms) â†’ ì‚¬ëŒì´ ì½ì„ ìˆ˜ ìˆëŠ” ë‚ ì§œ â”€â”€â”€
func formatTronTimestamp(ts int64) string {
	return time.UnixMilli(ts).Format("2006-01-02 15:04:05")
}

func getTronDeposits(address string) ([]Deposit, error) {
	apiKey := getTronGridAPIKey()
	if apiKey == "" {
		return nil, fmt.Errorf("íŠ¸ë¡ ê·¸ë¦¬ë“œ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
	}

	usdtContract := "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" // USDT TRC20 ë©”ì¸ë„· ì»¨íŠ¸ë™íŠ¸

	url := fmt.Sprintf("https://api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=50&contract_address=%s",
		address, usdtContract)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("TRON-PRO-API-KEY", apiKey)
	req.Header.Set("Accept", "application/json")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("íŠ¸ë¡ ê·¸ë¦¬ë“œ API ì‘ë‹µ ì˜¤ë¥˜: %d %s", resp.StatusCode, string(body))
	}

	var apiResp struct {
		Data []struct {
			TxID      string `json:"transaction_id"`
			Value     string `json:"value"`
			Timestamp int64  `json:"block_timestamp"`
			From      string `json:"from"`
			To        string `json:"to"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, err
	}

	var deposits []Deposit
	for _, tx := range apiResp.Data {
		if !strings.EqualFold(tx.To, address) {
			continue
		}

		amount, err := strconv.ParseFloat(tx.Value, 64)
		if err != nil {
			log.Printf("[íŠ¸ë¡ ê·¸ë¦¬ë“œ] ì…ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨ txid=%s, value=%s", tx.TxID, tx.Value)
			continue
		}
		amount = amount / 1_000_000

		deposits = append(deposits, Deposit{
			TxID:   tx.TxID,
			Amount: amount,
			Time:   time.UnixMilli(tx.Timestamp),
		})
	}
	return deposits, nil
}

func handleBroadcastInput(uid int64, text string) {
	// ì…ë ¥ ì·¨ì†Œ
	if text == "/cancel" {
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, "ì „ì²´ ê³µì§€ ì…ë ¥ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
		return
	}

	// ì „ì²´ ìœ ì € ì±„íŒ…ID ì¡°íšŒ
	var users []User
	err := db.Select("chat_id").Find(&users).Error
	if err != nil {
		sendTelegram(uid, "âŒ ì „ì²´ ìœ ì € ì¡°íšŒ ì‹¤íŒ¨")
		pendingBroadcastInput[uid] = false
		return
	}

	count := 0
	for _, user := range users {
		if user.ChatID == 0 {
			continue
		}
		_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "ğŸ“¢ <b>ê³µì§€ì‚¬í•­</b>\n\n"+text))
		if err != nil {
			log.Printf("ê³µì§€ ë°œì†¡ ì‹¤íŒ¨: chat_id=%d, error=%v", user.ChatID, err)
			continue
		}
		count++
		time.Sleep(50 * time.Millisecond) // API ì œí•œ íšŒí”¼ìš© ì¡°ì ˆ ê°€ëŠ¥
	}

	pendingBroadcastInput[uid] = false
	sendTelegram(uid, fmt.Sprintf("âœ… %dëª…ì—ê²Œ ê³µì§€ë¥¼ ë°œì†¡í–ˆìŠµë‹ˆë‹¤.", count))
}

// ì…ê¸ˆ í™•ì¸ ë° ì£¼ë¬¸ ë§¤ì¹­ ì²˜ë¦¬ (ê°„ê²° ë¡œê·¸ ë²„ì „)
func processTronDeposits() {
	wallets, err := getAllMonitoringWallets()
	if err != nil {
		log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] ì§€ê°‘ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		return
	}

	log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] %dê°œ ì§€ê°‘ ëª¨ë‹ˆí„°ë§ ì‹œì‘", len(wallets))

	var (
		totalDeposits  int
		matchedCount   int
		unmatchedCount int
	)

	for _, wallet := range wallets {
		deposits, err := getTronDeposits(wallet.Address)
		if err != nil {
			log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] %s... ì…ê¸ˆ ì¡°íšŒ ì‹¤íŒ¨: %v", wallet.Address[:10], err)
			continue
		}
		totalDeposits += len(deposits)

		for _, deposit := range deposits {
			if isDepositProcessed(deposit.TxID) {
				continue
			}

			// ì£¼ë¬¸ ë§¤ì¹­ í™•ì¸
			var existingOrder Order
			matchErr := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
				deposit.Amount-0.0001, deposit.Amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
				First(&existingOrder).Error

			if matchErr == nil {
				matchedCount++
				log.Printf("[ì…ê¸ˆë§¤ì¹­] ì£¼ë¬¸ #%d, ê¸ˆì•¡: %.3f USDT, TxID: %.8s...", existingOrder.ID, deposit.Amount, deposit.TxID)
			} else {
				unmatchedCount++
				// log.Printf("[ë¯¸ë§¤ì¹­ì…ê¸ˆ] %.3f USDT (TxID: %.8s...)", deposit.Amount, deposit.TxID)
			}

			processTronTransaction(TronTransaction{
				TxID:      deposit.TxID,
				From:      "", // í•„ìš”ì‹œ ì±„ìš°ê¸°
				To:        wallet.Address,
				AmountStr: fmt.Sprintf("%f", deposit.Amount),
				Timestamp: deposit.Time.UnixMilli(),
			})
			markDepositProcessed(deposit.TxID)
		}
	}

	// ìµœì¢… ìš”ì•½
	if totalDeposits > 0 {
		log.Printf("[ì…ê¸ˆëª¨ë‹ˆí„°ë§] ìš”ì•½: ì´ %dê±´ | ë§¤ì¹­ %d | ë¯¸ë§¤ì¹­ %d", totalDeposits, matchedCount, unmatchedCount)
	}
}

// ì…ê¸ˆ ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
func startDepositMonitoring() {
	go func() {
		ticker := time.NewTicker(40 * time.Second)
		defer ticker.Stop()
		log.Println("ğŸ” ì…ê¸ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘... (40ì´ˆ ê°„ê²©)")
		for {
			processTronDeposits()
			<-ticker.C
		}
	}()
}

func sendTelegram(chatID int64, text string) error {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML" // Markdown -> HTML ë³€ê²½
	_, err := bot.Send(msg)
	if err != nil {
		log.Printf("í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		return err
	}
	return nil
}

func handleCoinPayment(cb *tgbotapi.CallbackQuery, uid int64, chatID int64, orderID uint64) {
	productCode := strings.TrimPrefix(cb.Data, "pay_coin_")

	// ìƒí’ˆ ì½”ë“œë¡œ ì´ë¦„/ê°€ê²© ì°¾ê¸°
	var prodName string
	var basePrice float64
	found := false
	for _, cats := range cardCategories {
		for name, prod := range cats {
			if prod.Code == productCode {
				prodName = name
				basePrice = prod.Price
				found = true
				break
			}
		}
		if found {
			break
		}
	}
	if !found {
		sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ì •ë³´ ì—†ìŒ"))
		return
	}

	coinAddr := os.Getenv("COIN_PAYMENT_ADDR")
	if coinAddr == "" {
		log.Println("âš ï¸ COIN_PAYMENT_ADDR í™˜ê²½ë³€ìˆ˜ ì„¤ì • ì•ˆë¨")
		sendTelegram(uid, "âŒ ê²°ì œ ì£¼ì†Œê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.")
		return
	}
	// 1. ì£¼ë¬¸ ìƒì„± (ì„ì‹œ ê¸ˆì•¡, DB PK í™•ë³´)
	order := Order{
		UserID:      uid,
		Product:     prodName,  // ìƒí’ˆ ì´ë¦„ ë˜ëŠ” ì½”ë“œ
		Amount:      basePrice, // ì„ì‹œë¡œ basePrice ì‚¬ìš©
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: basePrice,
		Timestamp:   time.Now(),
	}
	if err := db.Create(&order).Error; err != nil {
		log.Printf("ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: %v", err)
		return
	}

	// 2. ì£¼ë¬¸ë³„ ê³ ìœ  ê²°ì œê¸ˆì•¡ ìƒì„± (ì£¼ë¬¸ID ê¸°ë°˜, ì†Œìˆ˜ì  ì…‹ì§¸ìë¦¬ ë‚´ë¦¼)
	uniqueAmt := toFixed3(basePrice + float64(order.ID)/1000.0)
	order.Amount = uniqueAmt
	order.ExpectedAmt = uniqueAmt
	if err := db.Save(&order).Error; err != nil {
		log.Printf("ì£¼ë¬¸ ê¸ˆì•¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
	}

	// 3. QRì½”ë“œ ìƒì„±
	qrPath := fmt.Sprintf("./qrcodes/deposit_%d.png", order.ID)
	if err := generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", coinAddr, uniqueAmt), qrPath); err != nil {
		log.Printf("QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨: %v", err)
	}

	// 4. ì£¼ë¬¸ ì•ˆë‚´ ë©”ì‹œì§€
	msgText := fmt.Sprintf(
		"ğŸ›’ <b>ì£¼ë¬¸ ì ‘ìˆ˜ ì™„ë£Œ</b>\n\n"+
			"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\nâ€¢ ìƒí’ˆëª…: <b>%s</b>\nâ€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
			"(ì†Œìˆ˜ì ê¹Œì§€ ì •í™•í•˜ê²Œ, QR ì½”ë“œ í™œìš© ê¶Œì¥)\n20ë¶„ ë‚´ ë¯¸ì…ê¸ˆì‹œ ìë™ì·¨ì†Œ ë©ë‹ˆë‹¤.",
		order.ID, prodName, uniqueAmt,
	)
	msg := tgbotapi.NewMessage(uid, msgText)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì£¼ë¬¸ì·¨ì†Œ", fmt.Sprintf("cancel_order_%d", order.ID)),
		),
	)
	sent, err := bot.Send(msg)
	if err != nil {
		log.Printf("ì£¼ë¬¸ ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
	userMessageIDs[uid] = append(userMessageIDs[uid], sent.MessageID)

	// 5. QRì½”ë“œ ì•ˆë‚´ ì´ë¯¸ì§€ ì „ì†¡ (ParseMode=HTML)
	if qrPath != "" {
		photo := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(qrPath))
		photo.Caption = fmt.Sprintf(
			"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•í•œ ê¸ˆì•¡</b>ì„ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n<code>%s</code>\n<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\nì£¼ì†Œ í´ë¦­ì‹œ ë³µì‚¬ ë©ë‹ˆë‹¤.",
			coinAddr,
		)
		photo.ParseMode = "HTML"
		if _, err := bot.Send(photo); err != nil {
			log.Printf("QR ì½”ë“œ ì´ë¯¸ì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}

	// 6. 20ë¶„ ë¯¸ì…ê¸ˆ ìë™ì·¨ì†Œ ì²˜ë¦¬ (ê³ ë£¨í‹´)
	go func(orderID uint, userID int64) {
		time.Sleep(20 * time.Minute)
		var ord Order
		if err := db.First(&ord, orderID).Error; err == nil && ord.Status == "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
			ord.Status = "ìë™ì·¨ì†Œ"
			if err := db.Save(&ord).Error; err != nil {
				log.Printf("ì£¼ë¬¸ ìë™ì·¨ì†Œ ì €ì¥ ì‹¤íŒ¨: %v", err)
			}
			sendTelegram(userID, fmt.Sprintf("âŒ ì£¼ë¬¸ #%d 20ë¶„ ë‚´ ë¯¸ì…ê¸ˆìœ¼ë¡œ ìë™ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.", orderID))
		}
	}(order.ID, uid)

	bot.Send(tgbotapi.NewCallback(cb.ID, "ì£¼ë¬¸ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤."))
}

// ì „ì²´ ë°©ë¬¸ì ì¡°íšŒ (ì¤‘ë³µ ì—†ì´ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡ ë“±)
func getAllVisitors() ([]Visitor, error) {
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen FROM (
			SELECT user_id, user_name, last_seen,
				ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_seen DESC) as rn
			FROM users
		) t
		WHERE rn = 1
		ORDER BY last_seen DESC
	`).Scan(&visitors).Error
	return visitors, err
}

func getVisitorsByDate(date time.Time) ([]Visitor, error) {
	start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	end := start.Add(24 * time.Hour)
	var visitors []Visitor
	err := db.Raw(`
		SELECT user_id, user_name, last_seen
		FROM users
		WHERE last_seen BETWEEN ? AND ?
		ORDER BY last_seen DESC
	`, start, end).Scan(&visitors).Error
	return visitors, err
}

func handleAdminListVisitors(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
		return
	}

	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil {
		log.Printf("[handleAdminListVisitors] DB ì¡°íšŒ ì‹¤íŒ¨: %v", err)
		sendTelegram(uid, "âŒ DB ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
		return
	}
	if len(activities) == 0 {
		log.Printf("[handleAdminListVisitors] ì¡°íšŒ ê²°ê³¼ ì—†ìŒ")
		sendTelegram(uid, "âŒ ì „ì²´ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë°©ë¬¸ì ì—†ìŒ")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ì „ì²´ ë°©ë¬¸ì (ìµœì‹  50ëª…)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}
		lastActive := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n  ìµœê·¼ í™œë™: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

	sendTelegram(uid, sb.String())
}

func createDepositOrder(userID int64, amount float64) error {
	// ìƒí’ˆëª…/ê°€ê²© ë“±ì€ ì…ê¸ˆì „ìš© ì£¼ë¬¸ì´ë©´ ëª…í™•í•˜ê²Œ ê³ ì •
	prodName := "USDT ì¶©ì „"
	price := amount

	order := Order{
		UserID:      userID,
		Product:     prodName,
		Amount:      price,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
	}

	// orderë¡œ ë°”ë¡œ ìƒì„±, ì´í›„ order.ID í™œìš©
	if err := db.Create(&order).Error; err != nil {
		return err
	}

	addr := os.Getenv("COIN_PAYMENT_ADDR")
	qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
	_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

	msgText := fmt.Sprintf(
		"ğŸ’¸ <b>ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</b>\n\n"+
			"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•íˆ <code>%.3f USDT</code></b>ë¥¼ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n\n"+
			"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\n"+
			"â€¢ ì…ê¸ˆì£¼ì†Œ: <code>%s</code>\n"+
			"â€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
			"(QRì½”ë“œë¡œ ì†¡ê¸ˆ ê°€ëŠ¥, ì†Œìˆ˜ì ê¹Œì§€ ì •í™•íˆ!)",
		amount, order.ID, addr, amount,
	)

	msg := tgbotapi.NewMessage(userID, msgText)
	msg.ParseMode = "HTML"
	bot.Send(msg)

	photo := tgbotapi.NewPhoto(userID, tgbotapi.FilePath(qrPath))
	photo.Caption = "QRì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê¸ˆì•¡ì´ ìë™ ì§€ì •ë©ë‹ˆë‹¤."
	photo.ParseMode = "HTML"
	bot.Send(photo)

	return nil
}
func sendTelegramHTML(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func handleAdminListVisitorsToday(uid int64) {
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
		return
	}

	today := time.Now().Format("2006-01-02")

	var visitors []UserActivityLog
	err := db.Where("DATE(last_active) = ?", today).Order("last_active DESC").Find(&visitors).Error
	if err != nil || len(visitors) == 0 {
		sendTelegram(uid, "âŒ ì˜¤ëŠ˜ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë°©ë¬¸ì ì—†ìŒ")
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ“… ì˜¤ëŠ˜ ë°©ë¬¸ì ëª©ë¡</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, v := range visitors {
		username := v.Username
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}
		nickname := v.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}
		lastActive := v.LastActive.Format("15:04")

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n  ìµœê·¼ í™œë™: %s\n\n",
			i+1, v.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

	sendTelegram(uid, sb.String())
}

func showAdminProductDetail(chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(chatID, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	stockCount, err := getCardStock(product.Name)
	if err != nil {
		stockCount = 0
	}

	text := fmt.Sprintf(
		"ğŸ“„ <b>ìƒí’ˆ ìƒì„¸</b>\n\n"+
			"â€¢ ì´ë¦„: %s\n"+
			"â€¢ ê°€ê²©: %.2f USDT\n"+
			"â€¢ ì„¤ëª…: %s\n"+
			"â€¢ ì¬ê³ : %d\n",
		product.Name, product.Price, product.Description, stockCount,
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", fmt.Sprintf("admin_add_stock_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“¦ ì¬ê³ ëª©ë¡", fmt.Sprintf("admin_stock_list_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœï¸ ìƒí’ˆìˆ˜ì •", fmt.Sprintf("admin_edit_product_%d", product.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ ìƒí’ˆì‚­ì œ", fmt.Sprintf("admin_delete_product_%d", product.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ìƒí’ˆëª©ë¡", fmt.Sprintf("admin_cat_back_%d", product.CategoryID)),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func showTodayVisitorsMenu(chatID int64, messageID int) {
	// ì˜¤ëŠ˜ ë‚ ì§œ 00:00 ~ 23:59 ê¸°ì¤€
	today := time.Now().Format("2006-01-02")
	var users []User
	// last_seen ë˜ëŠ” last_login ì¹¼ëŸ¼ ê¸°ì¤€ (ì¹¼ëŸ¼ ì´ë¦„ì— ë§ê²Œ ìˆ˜ì •)
	err := db.Where("DATE(last_seen) = ?", today).Order("last_seen DESC").Find(&users).Error
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì˜¤ëŠ˜ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	if len(users) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "ì˜¤ëŠ˜ ë°©ë¬¸ìê°€ ì—†ìŠµë‹ˆë‹¤.")
		bot.Request(msg)
		return
	}

	text := "ğŸ‘€ <b>ì˜¤ëŠ˜ ë°©ë¬¸ì (ìµœì‹ ìˆœ)</b>\n\n"
	for i, u := range users {
		text += fmt.Sprintf("%d. <code>%d</code> @%s (%s)\n",
			i+1, u.UserID, u.UserName, u.LastSeen.Format("15:04"))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ë©”ì¸ìœ¼ë¡œ", "admin_visitor_menu"),
		),
	)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

// QRì½”ë“œ ìƒì„± í•¨ìˆ˜
func generateWalletQRCode(data string, filename string) error {
	if data == "" {
		log.Println("QRì½”ë“œ ìƒì„± ìŠ¤í‚µ: ì£¼ì†Œ(ë°ì´í„°) ì—†ìŒ")
		return fmt.Errorf("QRì½”ë“œ ìƒì„± ì‹¤íŒ¨: ì…ë ¥ ë°ì´í„° ì—†ìŒ")
	}

	// íŒŒì¼ ì €ì¥ ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
	dir := filepath.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		log.Printf("QRì½”ë“œ ì €ì¥ í´ë” ìƒì„± ì‹¤íŒ¨: %v", err)
		return fmt.Errorf("QRì½”ë“œ í´ë” ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	// QRì½”ë“œ íŒŒì¼ ìƒì„±
	if err := qrcode.WriteFile(data, qrcode.Medium, 256, filename); err != nil {
		log.Printf("QRì½”ë“œ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: %v", err)
		return fmt.Errorf("QRì½”ë“œ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: %w", err)
	}

	return nil // ì„±ê³µ
}

func findMatchingOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: %.6f", amount)
	}
	return &order, nil
}

// íŠ¸ë¡ ê·¸ë¦¬ë“œ API í‚¤ ê°€ì ¸ì˜¤ê¸°
func getTronGridAPIKey() string {
	apiKey := os.Getenv("TRONGRID_API_KEY")
	if apiKey == "" {
		log.Println("âš ï¸ TRONGRID_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	return apiKey
}

// amountì— ê·¼ì ‘í•œ 'ì…ê¸ˆëŒ€ê¸°ì¤‘' ìƒíƒœ ì£¼ë¬¸ ì¡°íšŒ (ì˜¤ì°¨ Â±0.0001 í—ˆìš©)
func matchOrderByAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?", amount-0.0001, amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: %.6f", amount)
	}
	return &order, nil
}

// ë°©ë¬¸ì í˜ì´ì§€ë³„ ì¡°íšŒ (í•œ í˜ì´ì§€ì— 10ëª…)
func getVisitorsByPage(page int) ([]User, error) {
	const pageSize = 10
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	return getUsersByPage(pageSize, offset)
}

func showAllVisitorsMenu(chatID int64, messageID int) {
	var activities []UserActivityLog
	err := db.Order("last_active DESC").Limit(50).Find(&activities).Error
	if err != nil || len(activities) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì „ì²´ ë°©ë¬¸ì ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë°©ë¬¸ì ì—†ìŒ")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ì „ì²´ ë°©ë¬¸ì (ìµœì‹  50ëª…)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, act := range activities {
		username := act.Username
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}
		lastActive := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n  ìµœê·¼ í™œë™: %s\n\n",
			i+1, act.UserID, nickname, username, lastActive,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ë©”ì¸ìœ¼ë¡œ", "admin_visitor_menu"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

func formatUserActivitiesMessagePaged(activities []UserActivityLog, page, pageSize int) string {
	total := len(activities)
	start := (page - 1) * pageSize
	if start >= total {
		return "ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."
	}

	end := start + pageSize
	if end > total {
		end = total
	}

	totalPages := (total + pageSize - 1) / pageSize

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ìµœê·¼ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))

	for _, act := range activities[start:end] {
		lastActive := "(ì—†ìŒ)"
		if !act.LastActive.IsZero() {
			lastActive = act.LastActive.Format("2006-01-02 15:04")
		}
		username := act.Username
		if username == "" {
			username = "(ì—†ìŒ)"
		}
		nickname := act.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ ì‚¬ìš©ìID: %d / @%s / ë‹‰ë„¤ì„: %s\n  ìµœê·¼í™œë™: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			act.UserID, username, nickname, lastActive,
		))
	}

	return sb.String()
}

func showAdminBroadcastMenu(chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ“¢ ì „ì²´ê³µì§€\n\nëª¨ë“  íšŒì›ì—ê²Œ ë³´ë‚¼ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\nì·¨ì†Œ: /cancel")
	bot.Request(msg)
	// ì…ë ¥ ëŒ€ê¸° ìƒíƒœ ì„¸íŒ…ì€ handleCallbackì—ì„œ ì²˜ë¦¬
}

// íŠ¸ë¡  ì…ê¸ˆ íŠ¸ëœì­ì…˜ê³¼ ì£¼ë¬¸ ë§¤ì¹­ í•¨ìˆ˜ ì˜ˆì‹œ
func matchOrderByDepositAmount(amount float64) (*Order, error) {
	var order Order
	err := db.Where("expected_amt BETWEEN ? AND ? AND status = ?",
		amount-0.0001, amount+0.0001, "ì…ê¸ˆëŒ€ê¸°ì¤‘").
		First(&order).Error
	if err != nil {
		return nil, fmt.Errorf("ë§¤ì¹­ë˜ëŠ” ì£¼ë¬¸ ì—†ìŒ: %.6f", amount)
	}
	return &order, nil
}

// ë°©ë¬¸ì ëª©ë¡ í˜ì´ì§€ë„¤ì´ì…˜ ì¸ë¼ì¸ í‚¤ë³´ë“œ ìƒì„±
func getVisitorPaginationKeyboard(currentPage, totalPages int) tgbotapi.InlineKeyboardMarkup {
	var buttons []tgbotapi.InlineKeyboardButton

	// ë’¤ë¡œê°€ê¸° ë²„íŠ¼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë’¤ë¡œê°€ê¸°", "admin_visitor_menu")

	// ì´ì „/ë‹¤ìŒ í˜ì´ì§€ ë²„íŠ¼
	if currentPage > 1 {
		buttons = append(buttons,
			tgbotapi.NewInlineKeyboardButtonData("â¬…ï¸ ì´ì „", fmt.Sprintf("visitor_page_%d", currentPage-1)),
		)
	}
	if currentPage < totalPages {
		buttons = append(buttons,
			tgbotapi.NewInlineKeyboardButtonData("ë‹¤ìŒ â¡ï¸", fmt.Sprintf("visitor_page_%d", currentPage+1)),
		)
	}

	// í˜„ì¬ í˜ì´ì§€ í‘œì‹œ ë²„íŠ¼ (í´ë¦­ ë¶ˆê°€ìš©)
	pageBtn := tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("í˜ì´ì§€ %d/%d", currentPage, totalPages), "noop")

	// ë²„íŠ¼ ë°°ì—´ êµ¬ì„± (ë’¤ë¡œê°€ê¸° ë³„ë„ ì¤„ë¡œ)
	row1 := []tgbotapi.InlineKeyboardButton{backBtn}
	row2 := []tgbotapi.InlineKeyboardButton{pageBtn}
	row2 = append(row2, buttons...)

	return tgbotapi.NewInlineKeyboardMarkup(row1, row2)
}

// ë°©ë¬¸ì í˜ì´ì§€ ì¡°íšŒ ë° ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
func showVisitorListPage(uid, chatID int64, messageID int, page int) {
	const pageSize = 10

	users, total, err := getVisitors(page, pageSize)
	if err != nil {
		sendTelegram(uid, "âŒ ë°©ë¬¸ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
	msgText := formatVisitorListMessage(users, page, totalPages)
	kb := getVisitorPaginationKeyboard(page, totalPages)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, msgText)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &kb
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë°©ë¬¸ì ëª©ë¡ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func formatVisitorListMessage(users []User, page, totalPages int) string {
	if len(users) == 0 {
		return "<b>ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</b>"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡ (í˜ì´ì§€ %d / %d)</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n", page, totalPages))
	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "(ì—†ìŒ)"
		} else {
			username = "@" + username
		}
		nickname := u.Nickname
		if nickname == "" {
			nickname = "(ì´ë¦„ ì—†ìŒ)"
		}
		lastSeen := "(ì•Œ ìˆ˜ ì—†ìŒ)"
		if !u.LastSeen.IsZero() {
			lastSeen = u.LastSeen.Format("2006-01-02 15:04")
		}

		sb.WriteString(fmt.Sprintf(
			"%d. <code>%d</code> / <b>%s</b> / <i>%s</i>\nìµœê·¼ ì ‘ì†: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
			(i+1)+(page-1)*10, u.UserID, nickname, username, lastSeen,
		))
	}
	return sb.String()
}

// ìœ ì €IDë¡œ ë“±ë¡ëœ íŠ¸ë¡ (USDT) ì§€ê°‘ ì£¼ì†Œ ì¡°íšŒ
func getWalletAddress(uid int64) (string, error) {
	var walletMap WalletMap
	err := db.Where("user_id = ?", uid).First(&walletMap).Error
	if err != nil || walletMap.Wallet == "" {
		return "", fmt.Errorf("ë“±ë¡ëœ ì§€ê°‘ ì—†ìŒ")
	}
	return walletMap.Wallet, nil
}

func handleAdminMonthlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "ğŸ“Š ì›”ê°„ ë¦¬í¬íŠ¸\n\n" +
		"â€¢ ì´ ë§¤ì¶œ: 1,000,000 USDT\n" +
		"â€¢ ì´ ì£¼ë¬¸ ìˆ˜: 1500ê±´\n" +
		"â€¢ ì¸ê¸° ìƒí’ˆ: VPS 1ê°œì›”\n" +
		"â€¢ ì‹ ê·œ ê°€ì…ì: 200ëª…\n\n" +
		"ğŸ“… í•´ë‹¹ ë‹¬ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì›”ê°„ ë¦¬í¬íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "ì›”ê°„ ë¦¬í¬íŠ¸ í‘œì‹œ"))
}

func handleAdminYearlyReport(uid, chatID int64, messageID int, callbackID string) {
	reportText := "ğŸ“Š ì—°ê°„ ë¦¬í¬íŠ¸\n\n" +
		"â€¢ ì´ ë§¤ì¶œ: 12,000,000 USDT\n" +
		"â€¢ ì´ ì£¼ë¬¸ ìˆ˜: 18,000ê±´\n" +
		"â€¢ ì¸ê¸° ìƒí’ˆ: VPS 1ë…„\n" +
		"â€¢ ì‹ ê·œ ê°€ì…ì: 2,500ëª…\n\n" +
		"ğŸ“… í•´ë‹¹ ì—°ë„ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

	msg := tgbotapi.NewEditMessageText(chatID, messageID, reportText)
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ì—°ê°„ ë¦¬í¬íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(callbackID, "ì—°ê°„ ë¦¬í¬íŠ¸ í‘œì‹œ"))
}

// ê´€ë¦¬ìì—ê²Œ ìƒí’ˆëª…/ê°€ê²© ì…ë ¥ ìš”ì²­
func promptEditProduct(uid, chatID int64, msgID int, productID int) {
	// DBì—ì„œ ìƒí’ˆ ì •ë³´ ì¡°íšŒ
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}
	// ì„ì‹œë¡œ ìˆ˜ì • ëŒ€ê¸°ìƒíƒœ ì €ì¥ (uidë³„ productID)
	pendingEditProduct[uid] = productID

	msg := tgbotapi.NewEditMessageText(chatID, msgID, fmt.Sprintf(
		"ğŸ”§ <b>ìƒí’ˆ ì •ë³´ ìˆ˜ì •</b>\n\n"+
			"í˜„ì¬ ì´ë¦„: <code>%s</code>\ní˜„ì¬ ê°€ê²©: <b>%.2f USDT</b>\n\n"+
			"ìˆ˜ì •í•  <b>ì´ë¦„:ê°€ê²©</b>ì„ ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.\n"+
			"(ì˜ˆì‹œ: <code>%s:%.2f</code>)", prod.Name, prod.Price, prod.Name, prod.Price))
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func foo(cb *tgbotapi.CallbackQuery) {
	log.Println(cb.Data)
}

func myFunc(cb *tgbotapi.CallbackQuery) {
	log.Println(cb.Data)
}

func sendCaptchaChallenge(chatID int64, a, b, correctAnswer int) {
	text := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ”’<b>PRIVATE ACCESS ONLY</b>\n"+
			"ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.\n"+
			"ì•„ë˜ ë¬¸ì œë¥¼ í’€ì–´ í•´ì œ í•˜ì„¸ìš”.\n\n"+
			"<b>%d + %d = ?</b>\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>",
		a, b,
	)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer), fmt.Sprintf("verify_%d", correctAnswer)),
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer+1), fmt.Sprintf("verify_%d", correctAnswer+1)),
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%d", correctAnswer-1), fmt.Sprintf("verify_%d", correctAnswer-1)),
		),
	)

	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = markup
	bot.Send(msg)
}

func handlePhotoMessage(msg *tgbotapi.Message) {
	// ì‚¬ì§„ ë©”ì‹œì§€ ì²˜ë¦¬ ë¡œì§
}

func handleMessage(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)
	chatID := msg.Chat.ID
	text := strings.TrimSpace(msg.Text)

	if len(msg.Photo) > 0 {
		handlePhotoMessage(msg)
		return
	}

	username := ""
	if msg.From != nil {
		username = msg.From.UserName
	}
	isAdminUser := isAdmin(uid)

	if !verifiedUsers[uid] {
		a, b, ans := generateCaptcha()
		verificationAnswers[uid] = ans
		sendCaptchaChallenge(chatID, a, b, ans)
		return
	}

	if pendingBroadcastInput[uid] {
		if text == "/cancel" {
			pendingBroadcastInput[uid] = false
			sendTelegram(uid, "ì „ì²´ ê³µì§€ ì…ë ¥ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			return
		}
		var users []User
		err := db.Select("chat_id").Find(&users).Error
		if err != nil {
			sendTelegram(uid, "âŒ ì „ì²´ ìœ ì € ì¡°íšŒ ì‹¤íŒ¨")
			pendingBroadcastInput[uid] = false
			return
		}
		successCount := 0
		for _, user := range users {
			if user.ChatID == 0 {
				continue
			}
			_, err := bot.Send(tgbotapi.NewMessage(user.ChatID, "ğŸ“¢ [ê³µì§€]\n\n"+text))
			if err == nil {
				successCount++
			}
			time.Sleep(30 * time.Millisecond)
		}
		pendingBroadcastInput[uid] = false
		sendTelegram(uid, fmt.Sprintf("âœ… ì´ %dëª…ì—ê²Œ ê³µì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤.", successCount))
		return
	}

	if pid, ok := pendingEditProduct[uid]; ok {
		if text == "ì·¨ì†Œ" || text == "ë‚˜ê°€ê¸°" || text == "/cancel" {
			delete(pendingEditProduct, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "âŒ ìƒí’ˆ ì¶”ê°€ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showCategoryMenu(uid, chatID, 0)
			return
		}
		if pid == 0 {
			delete(pendingEditProduct, uid)
			cat, ok := selectedCategory[uid]
			if !ok || cat == "" {
				sendTelegram(uid, "âŒ ë¨¼ì € ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”!")
				return
			}
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.\nì˜ˆì‹œ: ìƒˆìƒí’ˆëª…:9.99")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price <= 0 {
				sendTelegram(uid, "âŒ ê°€ê²©ì€ ìˆ«ì(1 ì´ìƒ)ë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
				return
			}
			categoryID, ok := categoryMap[cat]
			if !ok {
				sendTelegram(uid, "âŒ ì˜ëª»ëœ ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤.")
				return
			}
			code := uuid.New().String()
			prod := Product{
				Code:       code,
				Name:       name,
				Price:      price,
				Active:     true,
				CategoryID: categoryID,
			}
			if err := db.Create(&prod).Error; err != nil {
				sendTelegram(uid, fmt.Sprintf("âŒ ìƒí’ˆ ì¶”ê°€ ì‹¤íŒ¨: %v", err))
				return
			}
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("âœ… ìƒˆ ìƒí’ˆ '%s' (%.2f USDT) ì¶”ê°€ ì™„ë£Œ! [ì¹´í…Œê³ ë¦¬: %s]", name, price, cat))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}

		if pid != 0 {
			delete(pendingEditProduct, uid)
			parts := strings.SplitN(text, ":", 2)
			if len(parts) != 2 {
				sendTelegram(uid, "âŒ ì…ë ¥ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.\n(ì˜ˆì‹œ: ìƒí’ˆëª…:9.99)")
				return
			}
			name := strings.TrimSpace(parts[0])
			price, err := strconv.ParseFloat(strings.TrimSpace(parts[1]), 64)
			if err != nil || price < 0.01 {
				sendTelegram(uid, "âŒ ê°€ê²©ì€ 0.01 ì´ìƒ ìˆ«ìë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
				return
			}
			var prod Product
			if err := db.First(&prod, pid).Error; err != nil {
				sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
				return
			}
			cat := ""
			for k, v := range categoryMap {
				if v == prod.CategoryID {
					cat = k
					break
				}
			}
			if err := db.Model(&Product{}).Where("id = ?", pid).
				Updates(map[string]interface{}{"name": name, "price": price}).Error; err != nil {
				sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ ìˆ˜ì • ì‹¤íŒ¨! ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.")
			} else {
				sendTelegram(uid, fmt.Sprintf("âœ… ìƒí’ˆì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ë¦„: %s\nê°€ê²©: %.2f", name, price))
			}
			showProductListMenuByCategory(chatID, 0, cat)
			return
		}
	}

	if pidStr, ok := pendingStockInput[uid]; ok {
		productID, _ := strconv.Atoi(pidStr)
		var prod Product
		if err := db.First(&prod, productID).Error; err != nil {
			sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
			return
		}
		if !pendingStockInputNotified[uid] {
			sendTelegram(uid, fmt.Sprintf("ğŸ”¹ [%s] ìƒí’ˆì— ì¬ê³  ì½”ë“œë¥¼ ë¶™ì—¬ë„£ê±°ë‚˜ ì…ë ¥í•˜ì„¸ìš”.\nì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", prod.Name))
			pendingStockInputNotified[uid] = true
		}

		if text == "ì·¨ì†Œ" || text == "ë‚˜ê°€ê¸°" || text == "/cancel" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, "âŒ ì¬ê³  ì¶”ê°€ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
			showCategoryMenu(uid, chatID, 0)
			return
		}

		lines := strings.Split(text, "\n")
		var added int
		for _, line := range lines {
			code := strings.TrimSpace(line)
			if code == "" || code == "ì™„ë£Œ" {
				continue
			}
			stock := StockCard{
				Name:    prod.Name,
				Content: code,
				Used:    false,
			}
			if err := db.Create(&stock).Error; err == nil {
				added++
			}
		}
		if strings.Contains(text, "ì™„ë£Œ") || text == "ì™„ë£Œ" {
			delete(pendingStockInput, uid)
			delete(pendingStockInputNotified, uid)
			removeKb := tgbotapi.NewRemoveKeyboard(true)
			msg := tgbotapi.NewMessage(uid, fmt.Sprintf("âœ… %dê°œì˜ ì½”ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤! (ìƒí’ˆëª…: %s)", added, prod.Name))
			msg.ReplyMarkup = removeKb
			bot.Send(msg)
		} else {
			bot.Send(tgbotapi.NewMessage(uid, fmt.Sprintf("ì„ì‹œì €ì¥: [%dê°œ] ì½”ë“œê°€ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤. ê³„ì† ë¶™ì—¬ë„£ê±°ë‚˜ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", added)))
		}
		return
	}

	if pendingDepositInput[uid] {
		amount, err := strconv.ParseFloat(text, 64)
		if err != nil || amount < 1 {
			sendTelegram(uid, "âŒ 1 USDT ì´ìƒ, ì˜¬ë°”ë¥¸ ìˆ«ìë§Œ ì…ë ¥í•´ ì£¼ì„¸ìš”.")
			return
		}
		delete(pendingDepositInput, uid)

		prodName := "USDT ì¶©ì „"
		price := amount

		order := Order{
			UserID:      uid,
			Product:     prodName,
			Amount:      price,
			Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
			ExpectedAmt: price,
			Timestamp:   time.Now(),
		}

		if err := db.Create(&order).Error; err != nil {
			sendTelegram(uid, "âŒ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨! ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
			return
		}

		addr := os.Getenv("COIN_PAYMENT_ADDR")
		qrPath := fmt.Sprintf("./qrcodes/deposit_custom_%d_%.3f.png", order.ID, amount)
		_ = generateWalletQRCode(fmt.Sprintf("%s?amount=%.3f", addr, amount), qrPath)

		msgText := fmt.Sprintf(
			"ğŸ’¸ <b>ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</b>\n\n"+
				"ì•„ë˜ ì£¼ì†Œë¡œ <b>ì •í™•íˆ <code>%.3f USDT</code></b>ë¥¼ ì…ê¸ˆí•´ ì£¼ì„¸ìš”.\n\n"+
				"â€¢ ì£¼ë¬¸ë²ˆí˜¸: <code>%d</code>\n"+
				"â€¢ ì…ê¸ˆì£¼ì†Œ: <code>%s</code>\n"+
				"â€¢ ê²°ì œê¸ˆì•¡: <b>%.3f USDT</b>\n\n"+
				"(QRì½”ë“œë¡œ ì†¡ê¸ˆ ê°€ëŠ¥, ì†Œìˆ˜ì ê¹Œì§€ ì •í™•íˆ!)",
			amount, order.ID, addr, amount,
		)
		msg := tgbotapi.NewMessage(chatID, msgText)
		msg.ParseMode = "HTML"
		bot.Send(msg)

		photo := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(qrPath))
		photo.Caption = "QRì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê¸ˆì•¡ì´ ìë™ ì§€ì •ë©ë‹ˆë‹¤."
		photo.ParseMode = "HTML"
		bot.Send(photo)
		return
	}

	if strings.HasPrefix(text, "/") {
		switch text {
		case "/start":
			handleStart(msg)
		case "/menu":
			showMenu(uid, username, chatID)
		case "/ê³µì§€":
			if isAdminUser {
				pendingBroadcastInput[uid] = true
				sendTelegram(uid, "ì „ì²´ ê³µì§€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”. ì·¨ì†Œí•˜ë ¤ë©´ /cancel ì…ë ¥")
			} else {
				sendTelegram(uid, "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")
			}
		case "/balance":
			handleBalanceCommand(msg)
		case "/addstock":
			handleAddStockCommand(msg)
		case "/ë‚´ì§€ê°‘":
			wallet := getUserWallet(uid)
			if wallet == "" {
				sendTelegram(chatID, "âŒ ë“±ë¡ëœ ì§€ê°‘ì´ ì—†ìŠµë‹ˆë‹¤. /ì§€ê°‘ë“±ë¡ ëª…ë ¹ì–´ë¡œ ì§€ê°‘ì„ ë¨¼ì € ë“±ë¡í•´ ì£¼ì„¸ìš”.")
			} else {
				sendTelegram(chatID, fmt.Sprintf("âœ… ë“±ë¡ëœ TRC20 ì§€ê°‘ ì£¼ì†Œ:\n<code>%s</code>", wallet))
			}
		default:
			log.Printf("[handleMessage] ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: %s", text)
		}
		return
	}

	switch text {
	case "ì—ë„ˆì§€":
		showEnergyMenu(uid, chatID, msg.MessageID)
		return
	case "ë‚´ ì •ë³´":
		showBalanceMenu(uid, chatID, 0)
		return
	case "ê³ ê°ì„¼í„°":
		showSupportMenu(uid, chatID, 0)
		return
	case "ì£¼ë¬¸ë‚´ì—­":
		showOrderHistoryMenu(uid, chatID, msg.MessageID)
		return
	}

	if !isAdminUser {
		log.Printf("[handleMessage] uid=%d, text=%q (ê´€ë¦¬ì ì•„ë‹˜, ë¬´ì‹œ)", uid, text)
		return
	}

	if strings.Contains(text, ":") && len(strings.Split(text, ":")) >= 3 {
		if err := saveStockWithImage(uid, text, ""); err != nil {
			sendTelegram(uid, fmt.Sprintf("âŒ ì¬ê³  ì¶”ê°€ ì‹¤íŒ¨: %v", err))
		} else {
			sendTelegram(uid, "âœ… ì¬ê³ ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!")
		}
		return
	}

	if text == "ë“±ë¡" {
		sendTelegram(uid, "âŒ ë“±ë¡í•  ì¬ê³  ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì¬ê³  ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
		return
	}

	log.Printf("[handleMessage] uid=%d, text=%q (ì²˜ë¦¬í•  ë‚´ìš© ì—†ìŒ)", uid, text)
}

func getUsersByPage(limit, offset int) ([]User, error) {
	var users []User
	err := db.Order("last_seen DESC").Limit(limit).Offset(offset).Find(&users).Error
	return users, err
}

func showOrderHistoryMenu(uid int64, chatID int64, msgID int) {
	// ìµœê·¼ ì£¼ë¬¸ 10ê°œ ì¡°íšŒ
	var orders []Order
	err := db.
		Where("user_id = ?", uid).
		Order("created_at DESC").
		Limit(10).
		Find(&orders).Error
	if err != nil {
		msg := tgbotapi.NewMessage(chatID, "âŒ ì£¼ë¬¸ ë‚´ì—­ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	if len(orders) == 0 {
		msg := tgbotapi.NewMessage(chatID, "ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	var sb strings.Builder
	sb.WriteString("ğŸ§¾ <b>ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ (ìµœëŒ€ 10ê°œ)</b>\n\n")

	for _, order := range orders {
		var txid string
		switch v := any(order.TxID).(type) {
		case sql.NullString:
			if v.Valid {
				txid = v.String
			} else {
				txid = "-"
			}
		case *string:
			if v != nil && *v != "" {
				txid = *v
			} else {
				txid = "-"
			}
		case string:
			if v != "" {
				txid = v
			} else {
				txid = "-"
			}
		default:
			txid = "-"
		}

		sb.WriteString(fmt.Sprintf(
			"â€¢ <b>ì£¼ë¬¸ë²ˆí˜¸:</b> <code>%d</code>\n"+
				"  <b>ìƒí’ˆëª…:</b> %s\n"+
				"  <b>ê¸ˆì•¡:</b> %.3f USDT\n"+
				"  <b>ìƒíƒœ:</b> %s\n"+
				"  <b>TXID:</b> %s\n"+
				"  <b>ì¼ì‹œ:</b> %s\n\n",
			order.ID,
			html.EscapeString(order.Product),
			order.Amount,
			order.Status,
			txid,
			order.CreatedAt.Format("2006-01-02 15:04"),
		))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë’¤ë¡œê°€ê¸°", "go_main"),
		),
	)

	if msgID > 0 {
		edit := tgbotapi.NewEditMessageText(chatID, msgID, sb.String())
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
	} else {
		msg := tgbotapi.NewMessage(chatID, sb.String())
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = kb
		bot.Send(msg)
	}
}

func promptAddStock(uid, chatID int64, msgID int, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}
	pendingStockInput[uid] = strconv.Itoa(productID)

	msg := tgbotapi.NewMessage(chatID, fmt.Sprintf(
		"<b>[%s]</b>  ìƒí’ˆì— ì¶”ê°€í•  ì½”ë“œ(í•œ ì¤„ì— í•˜ë‚˜ì”© ë¶™ì—¬ë„£ê¸°) ì…ë ¥!\n(ì…ë ¥ ì¢…ë£Œ: 'ì™„ë£Œ', ì·¨ì†Œ: 'ì·¨ì†Œ' ë˜ëŠ” '/cancel' ì…ë ¥\n"+
			"ì—¬ëŸ¬ ì¤„ ì…ë ¥ ê°€ëŠ¥í•˜ë©°, ë§ˆì§€ë§‰ ì¤„ì— <b>ì™„ë£Œ</b>ë¥¼ ì…ë ¥í•˜ë©´ ì €ì¥ë©ë‹ˆë‹¤.\n\n"+
			"ì˜ˆì‹œ:\n<code>1234-5678-ABCD\nQWER-8888-ZXCV\nA1B2C3D4E5F6\n...</code>\n\n(ëë‚˜ë©´ 'ì™„ë£Œ' ì…ë ¥)",
		prod.Name))
	msg.ParseMode = "HTML"
	bot.Send(msg)
}

func showProductListMenuByCategory(chatID int64, messageID int, category string) {
	var products []Product
	err := db.Where("category_id = ?", categoryMap[category]).Find(&products).Error
	if err != nil || len(products) == 0 {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.")
		bot.Send(msg)
		return
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		btn := tgbotapi.NewInlineKeyboardButtonData(p.Name, fmt.Sprintf("admin_stock_detail_%d", p.ID))
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¹´í…Œê³ ë¦¬ ëª©ë¡", "admin_inventory"),
	))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)
	msg := tgbotapi.NewEditMessageText(chatID, messageID, fmt.Sprintf("ğŸ“‹ [%s] ìƒí’ˆ ëª©ë¡", category))
	msg.ReplyMarkup = &kb
	bot.Send(msg)
}

// ë‹¨ìˆœ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
func sendSimpleMsg(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	bot.Send(msg)
}

// ìƒí’ˆ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€
func showEmptyCategoryMessage(chatID int64, messageID int, category string) {
	rows := [][]tgbotapi.InlineKeyboardButton{
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ìƒí’ˆì¶”ê°€", fmt.Sprintf("add_product_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¹´í…Œê³ ë¦¬ë¡œ", "admin_menu"),
		),
	}
	msgText := fmt.Sprintf("â—ï¸ [%s] ì¹´í…Œê³ ë¦¬ì— ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.\n[â• ìƒí’ˆì¶”ê°€]ë¡œ ìƒˆ ìƒí’ˆì„ ë“±ë¡í•˜ì„¸ìš”!", category)
	editMsgWithButtons(chatID, messageID, msgText, rows)
}

func buildProductButtons(products []Product) [][]tgbotapi.InlineKeyboardButton {
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		rows = append(rows,
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ", fmt.Sprintf("admin_add_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("â„¹ï¸ ìƒì„¸", fmt.Sprintf("admin_stock_detail_%d", p.ID)),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("âœï¸ ìˆ˜ì •", fmt.Sprintf("admin_edit_stock_%d", p.ID)),
				tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ ì‚­ì œ", fmt.Sprintf("admin_del_stock_%d", p.ID)),
			),
		)
	}
	return rows
}

// ë©”ì‹œì§€ ìˆ˜ì • + ë²„íŠ¼ ë¶™ì´ê¸° í•¨ìˆ˜
func editMsgWithButtons(chatID int64, messageID int, text string, rows [][]tgbotapi.InlineKeyboardButton) {
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "HTML"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	if _, err := bot.Send(edit); err != nil {
		log.Printf("ë©”ì‹œì§€ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func showUserGradeChangeMenu(chatID int64, msgID int, userID int64) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‰", fmt.Sprintf("admin_set_grade_%d_bronze", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥ˆ", fmt.Sprintf("admin_set_grade_%d_silver", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‡", fmt.Sprintf("admin_set_grade_%d_gold", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’", fmt.Sprintf("admin_set_grade_%d_diamond", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ëŒì•„ê°€ê¸°", "admin_user_list"),
		),
	)
	edit := tgbotapi.NewEditMessageText(chatID, msgID, "ë³€ê²½í•  ë“±ê¸‰ì„ ì„ íƒí•˜ì„¸ìš”.")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"
	bot.Send(edit)
}

func promptAddStockInput(uid int64, productID int) {
	var prod Product
	if err := db.First(&prod, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	msgText := fmt.Sprintf("â• ì¬ê³  ì¶”ê°€ - ìƒí’ˆ: <b>%s</b>\n\nì¬ê³  ì½”ë“œë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥í•´ ì£¼ì„¸ìš”.\nì™„ë£Œ ì‹œ 'ì™„ë£Œ'ë¥¼ ì…ë ¥í•˜ê±°ë‚˜ /cancel ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.", prod.Name)
	sendTelegram(uid, msgText) // ìˆ˜ì •ëœ ë¶€ë¶„

	pendingStockInput[uid] = strconv.Itoa(productID)
}

func handleCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleCallback] ì½œë°± ë°ì´í„°: %s", cb.Data)
	data := cb.Data
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID
	uid := int64(cb.From.ID)
	callbackID := cb.ID
	username := ""
	if cb.From != nil {
		username = cb.From.UserName
	}

	// VPS ìƒì„¸ ì„¤ëª…
	vpsDetails := map[string]string{
		"vps1": "<b>KVM - E1</b>\n\nâ€¢ CPU: 4ì½”ì–´\nâ€¢ RAM: 4GB\nâ€¢ ì €ì¥ê³µê°„: 100GB NVMe\nâ€¢ ê°€ê²©: 70 USDT\n\n- ë¹ ë¥¸ NVMe SSD\n- ì¼ë°˜ ì‚¬ë¬´ìš© ì í•©\n\nâ€» DMCA ìš”ì²­ì€ ë¬´ì‹œí•©ë‹ˆë‹¤.",
		"vps2": "<b>KVM - E2</b>\n\nâ€¢ CPU: 4ì½”ì–´\nâ€¢ RAM: 6GB\nâ€¢ ì €ì¥ê³µê°„: 140GB NVMe\nâ€¢ ê°€ê²©: 90 USDT\n\n- ì¤‘ê¸‰ ì‚¬ì–‘\n- ê°œë°œ ë° ì„œë¹„ìŠ¤ ìš´ì˜ ì í•©\n\nâ€» DMCA ìš”ì²­ì€ ë¬´ì‹œí•©ë‹ˆë‹¤.",
		"vps3": "<b>KVM - T1</b>\n\nâ€¢ CPU: 8ì½”ì–´\nâ€¢ RAM: 16GB\nâ€¢ ì €ì¥ê³µê°„: 160GB NVMe\nâ€¢ ê°€ê²©: 120 USDT\n\n- ê³ ë¶€í•˜ ì‘ì—… ì í•©\n- ê²Œì„ ì„œë²„ ë° ë°ì´í„° ì²˜ë¦¬\n\nâ€» DMCA ìš”ì²­ì€ ë¬´ì‹œí•©ë‹ˆë‹¤.",
		"vps4": "<b>KVM - T2</b>\n\nâ€¢ CPU: 12ì½”ì–´\nâ€¢ RAM: 24GB\nâ€¢ ì €ì¥ê³µê°„: 256GB NVMe\nâ€¢ ê°€ê²©: 150 USDT\n\n- ê³ ì„±ëŠ¥ ëŒ€ê·œëª¨ ì„œë¹„ìŠ¤ìš©\n- ìµœì í™”ëœ í•˜ë“œì›¨ì–´\n\nâ€» DMCA ìš”ì²­ì€ ë¬´ì‹œí•©ë‹ˆë‹¤.",
		"vps5": "<b>ë§ì¶¤ ì œì‘</b>\n\n- ë§ì¶¤í˜• ì‚¬ì–‘ ì œê³µ\n- ë¬¸ì˜ í›„ ê²¬ì  ì•ˆë‚´\n- ì•ˆì •ì„±ê³¼ ì„±ëŠ¥ ìš°ì„ ",
	}

	if detail, ok := vpsDetails[data]; ok {
		orderBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ›’ ì£¼ë¬¸", "order_"+data)
		backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ", "menu_vps")
		kb := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(orderBtn, backBtn))
		edit := tgbotapi.NewEditMessageText(cb.Message.Chat.ID, cb.Message.MessageID, detail)
		edit.ParseMode = "HTML"
		edit.ReplyMarkup = &kb
		bot.Send(edit)
		return
	}

	// 2. VPS ëª©ë¡ ë³´ì—¬ì£¼ê¸°
	if data == "menu_vps" {
		showVPSMenu(uid, chatID, msgID)
		return
	}
	if strings.HasPrefix(data, "admin_cat_") {
		category := strings.TrimPrefix(data, "admin_cat_")
		selectedCategory[uid] = category
		showProductListMenuByCategory(chatID, msgID, category)
		return
	}
	if data == "admin_list_stock" {
		handleListStockCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¬ê³  ëª©ë¡ ìš”ì²­ ì²˜ë¦¬ ì¤‘"))
		return
	}

	if data == "admin_add_admin" {
		handleAddAdminCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ì¶”ê°€ ìš”ì²­ ì²˜ë¦¬ ì¤‘"))
		return
	}
	if data == "admin_cancel_order" {
		handleCancelOrderCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì£¼ë¬¸ ì·¨ì†Œ ìš”ì²­ ì²˜ë¦¬ ì¤‘"))
		return
	}

	if strings.HasPrefix(data, "visitors_page_") {
		handleVisitorPageCallback(cb)
		return
	}
	if strings.HasPrefix(data, "verify_") {
		handleVerificationResponse(cb)
		return
	}
	if strings.HasPrefix(data, "admin_send_backup_") {
		fileName := strings.TrimPrefix(data, "admin_send_backup_")
		filePath := "/home/minho/backups/" + fileName
		bot.Send(tgbotapi.NewDocument(chatID, tgbotapi.FilePath(filePath)))
		return
	}
	if strings.HasPrefix(data, "admin_all_users_page_") {
		pageStr := strings.TrimPrefix(data, "admin_all_users_page_")
		page, _ := strconv.Atoi(pageStr)
		showAdminAllUsersMenu(chatID, msgID, page)
		return
	}
	if strings.HasPrefix(data, "order_") {
		productCode := strings.TrimPrefix(data, "order_")
		showOrderConfirmButtons(cb, productCode)
		return
	}
	if strings.HasPrefix(data, "add_product_") {
		cat := strings.TrimPrefix(data, "add_product_")
		selectedCategory[uid] = cat // uidë³„ë¡œ ì„ íƒ ì¹´í…Œê³ ë¦¬ ê¸°ë¡
		pendingEditProduct[uid] = 0 // ì‹ ê·œ ìƒí’ˆ ì¶”ê°€ í”Œë˜ê·¸

		cancelKb := tgbotapi.NewReplyKeyboard(
			tgbotapi.NewKeyboardButtonRow(
				tgbotapi.NewKeyboardButton("ì·¨ì†Œ"),
				tgbotapi.NewKeyboardButton("ë‚˜ê°€ê¸°"),
			),
		)

		msg := tgbotapi.NewMessage(uid, fmt.Sprintf(
			"â• [%s] ì¹´í…Œê³ ë¦¬ì— ì¶”ê°€í•  <b>ìƒí’ˆëª…:ê°€ê²©</b>ì„ ì…ë ¥í•˜ì„¸ìš”!\nì˜ˆì‹œ: ì‹ ìƒí’ˆ:9.99", cat))
		msg.ParseMode = "HTML"
		msg.ReplyMarkup = cancelKb
		bot.Send(msg)

		bot.Send(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ì¶”ê°€ ëŒ€ê¸°ì¤‘"))
		return
	}
	// ìƒí’ˆ ìƒì„¸
	if strings.HasPrefix(data, "admin_stock_detail_") {
		productID, err := strconv.Atoi(strings.TrimPrefix(data, "admin_stock_detail_"))
		if err != nil {
			sendTelegram(uid, "âŒ ìƒí’ˆ IDê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
			return
		}
		showAdminStockDetail(uid, chatID, msgID, productID)
		return
	}
	// ìƒí’ˆ ìˆ˜ì •
	if strings.HasPrefix(data, "admin_edit_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_edit_stock_"))
		promptEditProduct(uid, chatID, msgID, productID)
		return
	}
	// ìƒí’ˆ ì‚­ì œ
	if strings.HasPrefix(data, "admin_del_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_del_stock_"))
		showAdminStockDeleteMenu(uid, chatID, msgID, productID)
		return
	}
	// ì‹ ê·œ ìƒí’ˆ ì¶”ê°€ ì½œë°±
	if data == "add_product" {
		pendingEditProduct[uid] = 0 // 0ë²ˆì´ë©´ ì‹ ê·œ
		sendTelegram(uid, "â• ì¶”ê°€í•  <b>ìƒí’ˆëª…:ê°€ê²©</b>ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”!\nì˜ˆ: ì‹ ìƒí’ˆ:9.99")
		bot.Send(tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ì¶”ê°€ ëŒ€ê¸°ì¤‘"))
		return
	}
	if data == "cancel_pending_add" {
		delete(pendingEditProduct, uid)
		delete(pendingStockInput, uid)
		sendTelegram(uid, "âŒ ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
		showCategoryMenu(uid, chatID, 0)
		return
	}
	if strings.HasPrefix(data, "admin_add_stock_") {
		productID, _ := strconv.Atoi(strings.TrimPrefix(data, "admin_add_stock_"))
		promptAddStock(uid, chatID, msgID, productID)
		return
	}
	if data == "support_close" {
		// ìƒë‹´ ì„¸ì…˜ ì¢…ë£Œ (ì„¸ì…˜ map ë“±ì—ì„œ ì œê±°)
		delete(activeSupportSessions, uid)
		sendTelegram(uid, "ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì–¸ì œë“  ë‹¤ì‹œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
		// ê´€ë¦¬ìì—ê²Œë„ ì•Œë¦¼
		for _, adminID := range adminIDs {
			sendTelegram(int64(adminID), fmt.Sprintf("ìœ ì € %dì˜ ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", uid))
		}
		bot.Send(tgbotapi.NewCallback(cb.ID, "ìƒë‹´ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."))
		return
	}
	if strings.HasPrefix(data, "admin_user_detail_") {
		userIDstr := strings.TrimPrefix(data, "admin_user_detail_")
		userID, _ := strconv.ParseInt(userIDstr, 10, 64)
		showAdminUserDetailMenu(chatID, msgID, userID)
		return
	}
	if data == "check_wallet" {
		wallet := getUserWallet(uid)
		if wallet == "" {
			sendTelegram(uid, "âŒ ë“±ë¡ëœ ì§€ê°‘ì´ ì—†ìŠµë‹ˆë‹¤.")
			return
		}
		sendTelegram(uid, fmt.Sprintf("ì§€ê°‘ ì£¼ì†Œ: <code>%s</code>", wallet))
		if data == "admin_today_visitors" {
			showTodayVisitorsMenu(chatID, msgID)
			return
		}
		if data == "admin_all_visitors" {
			showAllVisitorsMenu(chatID, msgID)
			return
		}
		if data == "admin_all_users" {
			showAdminAllUsersMenu(chatID, msgID, 1) // page=1ë¶€í„° ì‹œì‘
			return
		}
		if data == "admin_advanced" {
			showAdvancedAdminMenu(uid, chatID, msgID)
			return
		}
		if data == "admin_system_health" {
			showSystemHealthMenu(uid, chatID, msgID)
			return
		}

		// ì§ì ‘ì…ë ¥(ì…ê¸ˆ custom)
		if data == "deposit_custom" {
			pendingDepositInput[uid] = true
			sendTelegram(uid, "ì›í•˜ëŠ” USDT ê¸ˆì•¡ì„ ìˆ«ìë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš” (ì˜ˆ: 23.5)")
			bot.Send(tgbotapi.NewCallback(cb.ID, "ì§ì ‘ì…ë ¥ ëŒ€ê¸°ì¤‘"))
			return
		}

		if strings.HasPrefix(data, "deposit_amount_") {
			amountStr := strings.TrimPrefix(data, "deposit_amount_")
			amount, err := strconv.ParseFloat(amountStr, 64)
			if err != nil {
				sendTelegram(chatID, "âŒ ê¸ˆì•¡ íŒŒì‹± ì‹¤íŒ¨")
				return
			}
			pendingDepositInput[uid] = false // í˜¹ì‹œ ì§ì ‘ì…ë ¥ ëŒ€ê¸° ì¤‘ì´ë¼ë©´ ì¢…ë£Œ
			// ì£¼ë¬¸ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ (ì˜ˆ: createDepositOrder(uid, amount))
			err = createDepositOrder(uid, amount)
			if err != nil {
				sendTelegram(chatID, "âŒ ì¶©ì „ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨")
				return
			}
			sendTelegram(chatID, fmt.Sprintf("âœ… %.2f USDT ì¶©ì „ ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", amount))
			return
		}

		// ë“±ê¸‰ë³€ê²½ ì½œë°±
		if strings.HasPrefix(data, "admin_set_grade_") {
			parts := strings.Split(data, "_")
			if len(parts) == 5 {
				grade := parts[3]
				targetUserID, err := strconv.ParseInt(parts[4], 10, 64)
				if err != nil {
					sendTelegram(chatID, "âŒ ì‚¬ìš©ì ID íŒŒì‹± ì‹¤íŒ¨")
					return
				}
				if !isValidGrade(grade) {
					sendTelegram(chatID, "âŒ í—ˆìš©ë˜ì§€ ì•Šì€ ë“±ê¸‰ì…ë‹ˆë‹¤.")
					return
				}
				err = updateUserGrade(targetUserID, grade)
				if err != nil {
					sendTelegram(chatID, "âŒ ë“±ê¸‰ ë³€ê²½ ì‹¤íŒ¨")
				} else {
					sendTelegram(chatID, "âœ… ë“±ê¸‰ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.")
					showAdminUserDetailMenu(chatID, msgID, targetUserID)
				}
				return
			}
		}
		if data == "go_catmenu" {
			showCategoryMenu(cb.From.ID, cb.Message.Chat.ID, cb.Message.MessageID)
			bot.Send(tgbotapi.NewCallback(cb.ID, "ì¹´í…Œê³ ë¦¬ë¡œ ì´ë™"))
			return
		}
		// "â¬…ï¸ ëª©ë¡ìœ¼ë¡œ" ì²˜ë¦¬
		if data == "admin_user_list" {
			showAdminUserListMenu(uid, chatID, msgID)
			return
		}
		// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. switch-case(ì¼ë°˜ ì½œë°±) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		switch data {
		case "show_menu":
			// detailê³¼ msgê°€ ì •ì˜ë˜ì–´ ìˆì§€ ì•Šì€ ë¬¸ì œ ìˆ˜ì •
			detail := "ë©”ë‰´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤." // detailì— ì ì ˆí•œ ê°’ì„ í• ë‹¹ (í•„ìš”ì— ë”°ë¼ ìˆ˜ì •)
			edit := tgbotapi.NewEditMessageText(cb.Message.Chat.ID, cb.Message.MessageID, detail)
			edit.ParseMode = "HTML"
			bot.Send(edit)
			showMenu(uid, username, chatID)
			return

		case "go_main":
			// ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ (ì„ íƒ)
			bot.Send(tgbotapi.NewDeleteMessage(chatID, cb.Message.MessageID))
		
			// ë©”ì¸ ë©”ë‰´ í‘œì‹œ
			showMenu(uid, cb.From.UserName, chatID)
		
			// ì½œë°± ì‘ë‹µ
			bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
			return

		case "support_request":
			// ìƒë‹´ ëŒ€ê¸°ì—´ì— ë“±ë¡ (ì˜ˆ: activeSupportSessions ë“± í™œìš©)
			pendingSupportQueue[uid] = time.Now()

			kb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("âŒ ìƒë‹´ì·¨ì†Œ", "support_cancel"),
				),
			)
			msg := tgbotapi.NewMessage(chatID, "ì‹¤ì‹œê°„ ë¬¸ì˜ê°€ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.\nìƒë‹´ì›ì´ ê³§ ì—°ë½ë“œë¦½ë‹ˆë‹¤.")
			msg.ParseMode = "HTML"
			msg.ReplyMarkup = kb
			bot.Send(msg)
			bot.Send(tgbotapi.NewCallback(cb.ID, "ê³ ê°ì„¼í„° ë¬¸ì˜ ì ‘ìˆ˜"))

			// ê´€ë¦¬ìì—ê²Œ ìƒë‹´ ìš”ì²­ ì•Œë¦¼
			for _, adminID := range adminIDs {
				adminKb := tgbotapi.NewInlineKeyboardMarkup(
					tgbotapi.NewInlineKeyboardRow(
						tgbotapi.NewInlineKeyboardButtonData("âœ… ìƒë‹´ìˆ˜ë½", fmt.Sprintf("support_accept_%d", uid)),
						tgbotapi.NewInlineKeyboardButtonData("âŒ ê±°ì ˆ", fmt.Sprintf("support_reject_%d", uid)),
					),
				)
				adminMsg := tgbotapi.NewMessage(int64(adminID),
					fmt.Sprintf("ğŸ†• [ìƒë‹´ ìš”ì²­]\nìœ ì €: <code>%d</code>\nìœ ì €ëª…: <b>%s</b>\n", uid, cb.From.UserName))
				adminMsg.ParseMode = "HTML"
				adminMsg.ReplyMarkup = adminKb
				bot.Send(adminMsg)
			}
			return
		case "support_cancel":
			// ëŒ€ê¸°ì—´ì—ì„œ ì œê±°
			delete(pendingSupportQueue, uid)
			sendTelegram(uid, "ìƒë‹´ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. ì–¸ì œë“  ë‹¤ì‹œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
			bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒë‹´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."))
			return

		case "menu_help":
			kb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" ğŸª« ENERGY ", "help_energy"),
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ†” ACCOUNT ", "help_account"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ‘¥ MEMBERS ", "help_membership"),
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ“± ESIM ", "help_esim"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ–¥ï¸  VPS/KVM ", "help_vps"),
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ”„ COINSWAP ", "help_swap"),
				),
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData(" ğŸ”™ ", "go_main"),
				),
			)
			edit := tgbotapi.NewEditMessageText(chatID, msgID, "â„¹ï¸ ì‚¬ìš©ë°©ë²• ì•ˆë‚´ ë©”ì„¸ì§€ ì˜¤ë¥˜ë° ìƒë‹´\në¬¸ì˜í•˜ê¸°ëŠ”  ì‚¬í•­ì€ ê³ ê°ì„¼í„° ì‹¤ì‹œê°„ ë¬¸ì˜ë¡œ ì—°ë½ì£¼ì„¸ìš”.")
			edit.ReplyMarkup = &kb
			edit.ParseMode = "HTML"
			bot.Send(edit)
			bot.Send(tgbotapi.NewCallback(callbackID, ""))
			return

		case "help_energy", "help_account", "help_membership", "help_esim", "help_card", "help_swap", "help_vps":
			showHelpMessage(uid, data)
			bot.Request(tgbotapi.NewCallback(cb.ID, ""))
			return

		// â”€â”€â”€â”€â”€ ê´€ë¦¬ì ë©”ë‰´ ë° í•˜ìœ„ë©”ë‰´ â”€â”€â”€â”€â”€
		case "admin_menu":
			if !isAdmin(uid) {
				sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "ê´€ë¦¬ì ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤."))
				return
			}
			showAdminMenu(uid, chatID, msgID)
			return
		case "admin_inventory":
			// 1ë‹¨ê³„: ì¹´í…Œê³ ë¦¬ ë©”ë‰´ë¶€í„° ë…¸ì¶œ
			showAdminCategoryMenu(chatID, msgID)
			return
		case "admin_add_stock":
			handleAddStockCommand(&tgbotapi.Message{From: cb.From, Chat: cb.Message.Chat})
			return
		case "admin_stock_analytics":
			showStockAnalyticsMenu(uid, chatID, msgID)
			return
		case "admin_stock_list":
			showAdminStockList(chatID, msgID) // ë³€ìˆ˜ëª… msgIDë¡œ ë³€ê²½
			return
		case "admin_stock_delete":
			promptStockDeletion(chatID) // ì¬ê³  ì‚­ì œ ì•ˆë‚´ í•¨ìˆ˜
			return
		case "admin_stock":
			promptStockAddition(chatID) // ì¬ê³  ì¶”ê°€ ì•ˆë‚´ í•¨ìˆ˜
			return
		case "admin_stats":
			showAdminStatsMenu(uid, chatID, msgID)
			return
		case "admin_orders":
			showAdminOrderListMenu(uid, chatID, msgID)
			return
		case "admin_member_menu":
			showAdminUserListMenu(uid, chatID, msgID)
			return
		case "admin_advanced":
			showAdvancedAdminMenu(uid, chatID, msgID)
			return
		case "weekly_stats":
			showDetailedReportMenu(uid, chatID, msgID)
			return
		case "showAdminSettings":
			showAdminSettings(chatID, msgID, cb.ID)
			return
		case "admin_list_visitors_today":
			// ê¶Œí•œ ì²´í¬ í¬í•¨í•´ì„œ ë°©ë¬¸ì ì˜¤ëŠ˜ ëª©ë¡ í•¨ìˆ˜ í˜¸ì¶œ
			uid := int64(cb.From.ID)
			if !isAdmin(uid) {
				sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
				return
			}
			handleAdminListVisitorsToday(uid)
			bot.Request(tgbotapi.NewCallback(cb.ID, "ë‹¹ì¼ ë°©ë¬¸ì ëª©ë¡ ì¶œë ¥"))
			return

		case "admin_list_visitors":
			uid := int64(cb.From.ID)
			if !isAdmin(uid) {
				sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
				bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
				return
			}
			handleAdminListVisitors(uid)
			bot.Request(tgbotapi.NewCallback(cb.ID, "ì „ì²´ ë°©ë¬¸ì ëª©ë¡ ì¶œë ¥"))
			return
		case "admin_add":
			sendTelegram(uid, "ğŸ‘¤ ê´€ë¦¬ì ì¶”ê°€ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.")
			bot.Request(tgbotapi.NewCallback(cb.ID, "ì¤€ë¹„ì¤‘ì…ë‹ˆë‹¤"))
			return

		// â”€â”€â”€â”€â”€ ìœ ì € ì¼ë°˜ ë©”ë‰´ â”€â”€â”€â”€â”€
		case "show_deposit_menu":
			sendDepositMenuNewMessage(uid)
			return
		case "balance_menu":
			showBalanceMenu(uid, chatID, 0)
			return
		case "show_energy":
			showEnergyMenu(uid, chatID, msgID)
			bot.Request(tgbotapi.NewCallback(cb.ID, "ì—ë„ˆì§€ ë©”ë‰´"))
			return
		default:
			// (ì—¬ê¸´ ì›ë˜ëŠ” ì•„ë¬´ ê²ƒë„ ë‘ì§€ ì•ŠëŠ” ê²ƒì´ ì •ì„!)
			log.Printf("[handleCallback] ì•Œ ìˆ˜ ì—†ëŠ” ì½œë°±: %s", data)
			bot.Request(tgbotapi.NewCallback(cb.ID, "ì§€ì›í•˜ì§€ ì•ŠëŠ” ëª…ë ¹"))
		}
		if strings.HasPrefix(data, "del_stock_") {
			handleDeleteStockCategory(cb)
			return
		}

		if strings.HasPrefix(data, "confirm_del_") {
			handleConfirmDeleteStock(cb)
			return
		}
		if strings.HasPrefix(cb.Data, "menu_") || cb.Data == "go_main" {
			handleMenuCallback(cb)
			return
		}
		if strings.HasPrefix(data, "cardcat_") {
			categoryName := strings.TrimPrefix(data, "cardcat_") // âœ… ì½œë°±ì—ì„œ ì´ë¦„ ì¶”ì¶œ
			showProductMenu(categoryName, chatID, msgID)          // âœ… ì˜¬ë°”ë¥¸ ì¸ì ì „ë‹¬
			return
		}

		if strings.HasPrefix(data, "prod_") {
			handleProductCallback(cb)
			return
		}

		if strings.HasPrefix(data, "pay_coin_") {
			orderIDStr := strings.TrimPrefix(data, "pay_coin_")     // "pay_coin_" ì œê±°
			orderID64, err := strconv.ParseUint(orderIDStr, 10, 64) // ë¬¸ìì—´ â†’ uint64 ë³€í™˜
			if err != nil {
				sendTelegram(uid, "âŒ ì£¼ë¬¸ë²ˆí˜¸ íŒŒì‹± ì‹¤íŒ¨")
				return
			}

			handleCoinPayment(cb, uid, chatID, orderID64) // í•¨ìˆ˜ì— ì •í™•í•œ ì¸ì ì „ë‹¬
			bot.Request(tgbotapi.NewCallback(cb.ID, "ì½”ì¸ ê²°ì œ ì²˜ë¦¬ ì¤‘"))
			return
		}
		if strings.HasPrefix(data, "pay_balance_") {
			orderIDStr := strings.TrimPrefix(data, "pay_balance_")
			orderID64, err := strconv.ParseUint(orderIDStr, 10, 64)
			if err != nil {
				sendTelegram(uid, "âŒ ì£¼ë¬¸ë²ˆí˜¸ íŒŒì‹± ì‹¤íŒ¨")
				return
			}
			orderID := uint(orderID64)

			err = handleBalancePayment(orderID, uid)
			if err != nil {
				sendTelegram(uid, "âŒ ì”ì•¡ ê²°ì œ ì‹¤íŒ¨: "+err.Error())
			} else {
				sendTelegram(uid, "âœ… ì”ì•¡ ê²°ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
			}

			if _, err := bot.Request(tgbotapi.NewCallback(cb.ID, "ì”ì•¡ ê²°ì œ ì²˜ë¦¬ ì¤‘")); err != nil {
				log.Printf("ì½œë°± ì‘ë‹µ ì‹¤íŒ¨: %v", err)
			}
			return
		}

		if strings.HasPrefix(data, "support_accept_") {
			targetUIDStr := strings.TrimPrefix(data, "support_accept_")
			targetUID, err := strconv.ParseInt(targetUIDStr, 10, 64)
			if err != nil {
				sendTelegram(uid, "âŒ ìƒë‹´ ëŒ€ìƒì ID íŒŒì‹± ì‹¤íŒ¨")
				return
			}

			activeSupportSessions[targetUID] = uid

			// ìƒë‹´ì¢…ë£Œ ë²„íŠ¼ í‚¤ë³´ë“œ
			closeKb := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ğŸ”š ìƒë‹´ì¢…ë£Œ", fmt.Sprintf("support_close_%d", uid)),
				),
			)
			closeKb2 := tgbotapi.NewInlineKeyboardMarkup(
				tgbotapi.NewInlineKeyboardRow(
					tgbotapi.NewInlineKeyboardButtonData("ğŸ”š ìƒë‹´ì¢…ë£Œ", fmt.Sprintf("support_close_%d", targetUID)),
				),
			)

			// ìœ ì €ì—ê²Œ ì•ˆë‚´+ìƒë‹´ì¢…ë£Œ ë²„íŠ¼
			msg := tgbotapi.NewMessage(targetUID, "âœ… ìƒë‹´ì›ì´ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤! ê¶ê¸ˆí•œ ë‚´ìš©ì„ ë©”ì‹œì§€ë¡œ ë³´ë‚´ì£¼ì„¸ìš”.\n\nìƒë‹´ì´ ëë‚˜ë©´ í•˜ë‹¨ì˜ [ìƒë‹´ì¢…ë£Œ] ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
			msg.ReplyMarkup = closeKb
			bot.Send(msg)

			// ìƒë‹´ì›(ê´€ë¦¬ì)ì—ê²Œ ì•ˆë‚´+ìƒë‹´ì¢…ë£Œ ë²„íŠ¼
			adminMsg := tgbotapi.NewMessage(uid, "ğŸ™‹â€â™‚ï¸ ìƒë‹´ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ ì €ì—ê²Œ ë‹µë³€í•´ ì£¼ì„¸ìš”.\n\nìƒë‹´ì´ ëë‚˜ë©´ [ìƒë‹´ì¢…ë£Œ]ë¥¼ ê¼­ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
			adminMsg.ReplyMarkup = closeKb2
			bot.Send(adminMsg)

			// ìƒë‹´ ì‹œì‘ ì½œë°± ì‘ë‹µ
			bot.Request(tgbotapi.NewCallback(cb.ID, "ìƒë‹´ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."))

			return
		}
	} // âœ… ì´ê±¸ ë¶™ì—¬ì£¼ì…”ì•¼ ì˜¤ë¥˜ í•´ê²°ë©ë‹ˆë‹¤.
}

// ì´ í˜ì´ì§€ ìˆ˜ ê³„ì‚° í•¨ìˆ˜ (10ëª… ë‹¨ìœ„)
func getTotalVisitorPages() int {
	var total int64
	err := db.Model(&User{}).Count(&total).Error
	if err != nil || total == 0 {
		return 1
	}
	return int((total + 9) / 10) // ì˜¬ë¦¼
}

// ë°©ë¬¸ì ëª©ë¡ ì¡°íšŒ í•¨ìˆ˜ (í˜ì´ì§• í¬í•¨)
func getVisitors(page, pageSize int) ([]User, int64, error) {
	var users []User
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	var total int64
	if err := db.Model(&User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	err := db.Order("last_seen DESC").
		Offset(offset).
		Limit(pageSize).
		Find(&users).Error
	return users, total, err
}

func checkDepositMatch(senderAddress string, amount float64) (*Order, error) {
	var order Order
	err := db.Where("sender_address = ? AND status = ?", senderAddress, "pending").First(&order).Error
	if err != nil {
		return nil, err
	}
	return &order, nil
}

func formatVisitorList(users []User) string {
	var sb strings.Builder
	sb.WriteString("<b>ğŸ‘¥ ë°©ë¬¸ì ëª©ë¡</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	for i, u := range users {
		username := u.UserName
		if username == "" {
			username = "ì—†ìŒ"
		} else {
			username = "@" + username
		}

		nickname := u.Nickname
		if nickname == "" {
			nickname = "ì´ë¦„ ì—†ìŒ"
		}

		sb.WriteString(fmt.Sprintf(
			"<b>%d.</b> <code>%d</code> â€¢ <b>%s</b> â€¢ <i>%s</i>\n\n",
			i+1, u.UserID, nickname, username,
		))
	}

	sb.WriteString("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	sb.WriteString("ğŸ” ëˆ„êµ°ì§€ ë°”ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ ë‹‰ë„¤ì„ê³¼ ì•„ì´ë”” í‘œì‹œ\n")

	return sb.String()
}

// showHelpMessage í•¨ìˆ˜ (ìˆ˜ì •ë³¸)
func showHelpMessage(uid int64, data string) {
	switch data {
	case "help_account":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ†” <b>(ACCOUNT) ìƒí’ˆ ì•ˆë‚´</b>\n\n"+
				"ê²°ì œ í™•ì¸ í›„, <b>ìë™</b> ë©”ì„¸ì§€ë¡œ ì§€ê¸‰ë©ë‹ˆë‹¤.\n"+
				"<b>ë²ˆí˜¸ | link</b> í˜•ì‹ìœ¼ë¡œ ë°œì†¡ë˜ë©° ë¡œê·¸ì¸ ğŸ”œ link ğŸ”œ 2FA í™•ì¸\n"+
				"ãƒ»<i>EX: <a href=\"https://t.me/EX_TGID\">ì§§ì€ë²ˆí˜¸</a> í¬ì»¤ë¬¸ì˜</i>\n"+
				"<i>PC ë° ëª¨ë°”ì¼ ëª¨ë‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_account ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_membership":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ‘¥ <b>(MEMBERSHIP) ì•ˆë‚´</b>\n\n"+
				"ãƒ» ê²°ì œ í›„ ë³„ë„ ë“±ë¡ ì—†ì´ <b>ì¦‰ì‹œ ì„ ë¬¼</b>ë¡œ ì „ì†¡ë©ë‹ˆë‹¤.\n"+
				"ãƒ» ê° í”Œë«í¼ ì‚¬ìš©ë²•ì€ ë©”ì„¸ì§€ì™€ í•¨ê»˜ ì•ˆë‚´ë©ë‹ˆë‹¤.\n"+
				"ãƒ» <i>ë¬¸ì˜ ì‚¬í•­ì€ ê³ ê°ì„¼í„°ë¡œ ì—°ë½ ì£¼ì„¸ìš”.</i>",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_membership ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_esim":
		photoFile := "/home/minho/epusdt/images/esim_usage.jpeg" // ì ˆëŒ€ê²½ë¡œ
		photoMsg := tgbotapi.NewPhoto(uid, tgbotapi.FilePath(photoFile))
		photoMsg.Caption = "ğŸ“± <b>(E-SIM) ì•ˆë‚´</b>\n\n" +
			"ãƒ» DATA ONLY, 5G/4G ê±±ì •X\n" +
			"ãƒ» ê²°ì œ í›„ QRì½”ë“œ ì •ë³´ê°€ ìë™ ì§€ê¸‰ë©ë‹ˆë‹¤.\n" +
			"ãƒ» ìœ„ì¹˜ ì¡°íšŒì‹œ í™ì½© í™ì½©ë²ˆí˜¸ ë¶€ì—¬.\n"
		photoMsg.ParseMode = "HTML"
		if _, err := bot.Send(photoMsg); err != nil {
			log.Printf("help_esim ì‚¬ì§„ ì „ì†¡ ì‹¤íŒ¨: %v", err)
			sendTelegram(uid, "âŒ eSIM ì•ˆë‚´ ì´ë¯¸ì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
		}

	case "help_energy":
		msgText := `<b>ğŸª« USDT ì†¡ê¸ˆ ìˆ˜ìˆ˜ë£Œ 80% ì ˆê° ğŸª«</b>
	
	ğŸ’¸ ì „ì†¡ 1íšŒë‹¹ ìˆ˜ìˆ˜ë£Œ ìµœëŒ€ ë§Œì› ì ˆê°
	
	ğŸ“Š í‰ê·  í…Œë” 100íšŒ ì†¡ê¸ˆ ì‹œ íŠ¸ë¡  ì†Œë¹„ëŸ‰ ë¹„êµ
	
	ğŸ”¹ ì¼ë°˜ ì†¡ê¸ˆ: ìµœì†Œ 1,800 ~ 2,800 TRX   
	ğŸ”¹ ì—ë„ˆì§€ ì†¡ê¸ˆ: ìµœì†Œ 250 ~ 500 TRX
	
	<b>KRW ê¸°ì¤€</b>
	ì¼ë°˜ì†¡ê¸ˆ : 670,000 ~ 1,036,000
	ì—ë„ˆì§€ì†¡ê¸ˆ : 92,500 ~ 185,000
	
	1íšŒ ì „ì†¡ì— í•„ìš”í•œ ì—ë„ˆì§€ = 65K ì—ë„ˆì§€
	
	65K ì—ë„ˆì§€ = 2.5 TRX (ì „ì†¡ 1íšŒ)  
	ì˜ˆ: 10 TRX = 260K ì—ë„ˆì§€ (3~4íšŒ)
	
	â± ì „ì†¡í•œ ì£¼ì†Œë¡œ 5ì´ˆ ì´ë‚´ ì—ë„ˆì§€ í• ë‹¹ ì™„ë£Œ
	
	â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
	
	â¬‡ï¸ <b>ê²°ì œ ì£¼ì†Œ</b> â¬‡ï¸
	
	<b><code>TDFfEdkdkdkdososlsksospzkPn</code></b>
	
	â¬†ï¸ ì£¼ì†Œ í´ë¦­ ì‹œ ìë™ ë³µì‚¬ â¬†ï¸
	
	â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
	
	â³ ì—ë„ˆì§€ëŠ” 1ì‹œê°„ í›„ ìë™ ì†Œë©¸  
	âš ï¸ USDTê°€ ì—†ëŠ” ìƒˆ ì§€ê°‘ìœ¼ë¡œ ì†¡ê¸ˆ ì‹œ  
	130K ì—ë„ˆì§€(5 TRX) ë°œìƒ ê°€ëŠ¥  
	ì†¡ê¸ˆ ì „ ìˆ˜ìˆ˜ë£Œ ê¼­ í™•ì¸`

		msg := tgbotapi.NewMessage(uid, msgText)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_energy ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_card":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ’³ <b>(CARD) ê²°ì œ ì•ˆë‚´</b>\n\n"+
				"ãƒ» ëŒ€ë¦¬ ë° VPN ê²°ì œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"+
				"ãƒ» êµ¬ë§¤ í›„ â€˜ê³ ê°ì„¼í„°' ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_card ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_swap":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ”„ <b>ìŠ¤ì™‘ ì•ˆë‚´</b>\n\n"+
				"ì½”ì¸ ìŠ¤ì™‘ ì ì‹œ ì ê²€ ì¤‘ì…ë‹ˆë‹¤.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_swap ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	case "help_vps":
		msg := tgbotapi.NewMessage(uid,
			"ğŸ–¥ï¸ <b>VPS/KVM ì•ˆë‚´</b>\n\n"+
				"ì—¬ëŸ¬ ê°€ì§€ VPS ë° KVM ì„œë²„ ì˜µì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.\n"+
				"ë” ìì„¸í•œ ë‚´ìš©ì€ ì œí’ˆ ëª©ë¡ì—ì„œ í™•ì¸í•˜ì„¸ìš”.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_vps ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}

	default:
		msg := tgbotapi.NewMessage(uid,
			"â“ í•´ë‹¹ ë„ì›€ë§ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
		)
		msg.ParseMode = "HTML"
		if _, err := bot.Send(msg); err != nil {
			log.Printf("help_default ì „ì†¡ ì‹¤íŒ¨: %v", err)
		}
	}
}

func handleBalancePayment(orderID uint, userID int64) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	if order.Status != "ì…ê¸ˆëŒ€ê¸°ì¤‘" {
		return fmt.Errorf("ì˜ëª»ëœ ì£¼ë¬¸ ìƒíƒœ: %s", order.Status)
	}

	balance, err := getUserBalance(userID)
	if err != nil {
		return fmt.Errorf("ì”ì•¡ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}
	if balance < order.Amount {
		return fmt.Errorf("ì”ì•¡ ë¶€ì¡± (ë³´ìœ : %.2f, í•„ìš”: %.2f)", balance, order.Amount)
	}

	// íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ê¶Œì¥ (ì•„ë˜ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ)
	if err := deductBalance(userID, order.Amount); err != nil {
		return fmt.Errorf("ì”ì•¡ ì°¨ê° ì‹¤íŒ¨: %w", err)
	}

	order.Status = "ì™„ë£Œ"
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
	}

	// ê´€ë¦¬ì ì•Œë¦¼
	adminChatID := getAdminChatID()
	adminMsg := fmt.Sprintf(
		"ğŸ’³ ì”ì•¡ ê²°ì œ ì™„ë£Œ\nì£¼ë¬¸ë²ˆí˜¸: %d\nì‚¬ìš©ìID: %d\nê¸ˆì•¡: %.2f USDT",
		order.ID, userID, order.Amount)
	if _, err := bot.Send(tgbotapi.NewMessage(adminChatID, adminMsg)); err != nil {
		log.Printf("ê´€ë¦¬ì ì•Œë¦¼ ì‹¤íŒ¨: %v", err)
	}

	// ìœ ì € ì•Œë¦¼
	sendTelegram(userID, fmt.Sprintf(
		"âœ… ì”ì•¡ ê²°ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\nì£¼ë¬¸ë²ˆí˜¸: %d\nê¸ˆì•¡: %.2f USDT",
		order.ID, order.Amount,
	))

	return nil
}

func handleMenuCallback(cb *tgbotapi.CallbackQuery) {
	log.Printf("[handleMenuCallback] cb.Data: %s", cb.Data)
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	switch cb.Data {
	case "menu_products":
		showCategoryMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸ›’ ìƒí’ˆ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤"))
		return

	case "menu_vps":
		showVPSMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸ’» VPS ëª©ë¡"))
		return

	case "menu_swap":
		showSwapMenu(uid, chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ğŸ”„ ì½”ì¸ êµí™˜"))
		return

	case "menu_help":
		showFAQMenu(chatID, messageID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "â„¹ï¸ ë„ì›€ë§"))
		return

	case "admin_monthly_report":
		handleAdminMonthlyReport(uid, chatID, messageID, cb.ID)
		return

	case "admin_yearly_report":
		handleAdminYearlyReport(uid, chatID, messageID, cb.ID)
		return

	case "go_main":
		showMenu(uid, cb.From.UserName, chatID)
		bot.Request(tgbotapi.NewCallback(cb.ID, "ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™"))
		return

	default:
		log.Printf("[handleMenuCallback] ì•Œ ìˆ˜ ì—†ëŠ” ë©”ë‰´: %s", cb.Data)
		bot.Request(tgbotapi.NewCallback(cb.ID, "â“ ì•Œ ìˆ˜ ì—†ëŠ” ë©”ë‰´ì…ë‹ˆë‹¤"))
		return
	}
}

func getStockCount(productName string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).
		Where("name = ? AND used = ?", productName, false).
		Count(&count).Error
	if err != nil {
		return 0, err
	}
	return count, nil
}

func showFAQMenu(chatID int64, messageID int) {
	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“Œ ì´ìš©ë°©ë²•", "faq_usage"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’³ ê²°ì œë¬¸ì˜", "faq_payment"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ë©”ì¸ìœ¼ë¡œ", "go_main"),
		),
	)

	msgText := "<b>ğŸ“– ìì£¼ ë¬»ëŠ” ì§ˆë¬¸ (FAQ)</b>\n\n" +
		"ê¶ê¸ˆí•œ ë‚´ìš©ì„ ì„ íƒí•˜ì„¸ìš”."

	edit := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, kb)
	edit.ParseMode = "HTML"
	if _, err := bot.Send(edit); err != nil {
		log.Printf("showFAQMenu ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func showSwapMenu(uid, chatID int64, messageID int) {
	swapPairs := []struct {
		display string
		data    string
	}{
		{"USDT â†’ TRX", "swap_usdt_trx"},
		{"TRX â†’ USDT", "swap_trx_usdt"},
		{"USDT â†’ ETH", "swap_usdt_eth"},
		{"ETH â†’ USDT", "swap_eth_usdt"},
		{"USDT â†’ SOL", "swap_usdt_sol"},
		{"SOL â†’ USDT", "swap_sol_usdt"},
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for i := 0; i < len(swapPairs); i += 2 {
		var row []tgbotapi.InlineKeyboardButton
		row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i].display, swapPairs[i].data))
		if i+1 < len(swapPairs) {
			row = append(row, tgbotapi.NewInlineKeyboardButtonData(swapPairs[i+1].display, swapPairs[i+1].data))
		}
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(row...))
	}

	// ë§ˆì§€ë§‰ í•œ ì¤„ì€ ë©”ë‰´ë¡œ ê°€ê¸° ë²„íŠ¼
	backBtn := tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "go_main")
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(backBtn))

	kb := tgbotapi.NewInlineKeyboardMarkup(rows...)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ”„ ì½”ì¸ ìŠ¤ì™‘ ë©”ë‰´\n ë³€ê²½í•  ì½”ì¸ì„ ì„ íƒí•˜ì„¸ìš”.[ì ê²€]")
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("showSwapMenu ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func handleCategoryCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	category := strings.TrimPrefix(cb.Data, "cardcat_")
	showProductMenu(category, chatID, messageID)
}

// ìƒí’ˆ ì½œë°± ì²˜ë¦¬
func handleProductCallback(cb *tgbotapi.CallbackQuery) {
	data := cb.Data // ì˜ˆ: "prod_vps1"
	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID

	code := strings.TrimPrefix(data, "prod_")

	for _, category := range cardCategories {
		for name, prod := range category {
			if prod.Code == code {
				text := fmt.Sprintf("<b>%s</b>\n\n%s\n\nğŸ’° ê°€ê²©: %.2f USDT", name, prod.Description, prod.Price)
				edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
				edit.ParseMode = "HTML"
				bot.Send(edit)

				// í™•ì¸ ë²„íŠ¼ ë³´ì—¬ì£¼ê¸°
				showOrderConfirmButtons(cb, code)
				return
			}
		}
	}

	bot.Send(tgbotapi.NewMessage(chatID, "âŒ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."))
}

func handleGoMainCallback(cb *tgbotapi.CallbackQuery) {
	chatID := cb.Message.Chat.ID
	uid := int64(cb.From.ID)
	username := cb.From.UserName

	showMenu(uid, username, chatID)

	// ì½œë°± ì¿¼ë¦¬ ì‘ë‹µ
	callback := tgbotapi.NewCallback(cb.ID, "ë©”ì¸ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
	if _, err := bot.Request(callback); err != nil {
		log.Printf("Callback ì‘ë‹µ ì‹¤íŒ¨: %v", err)
	}
}

func showOrderConfirmButtons(cb *tgbotapi.CallbackQuery, productCode string) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	var prodName string
	var price float64
	found := false

	// VPS ìƒí’ˆì¸ì§€ ë¨¼ì € ì²´í¬
	if vpsProd, ok := vpsProductMap[productCode]; ok {
		prodName = vpsProd.Name
		price = vpsProd.Price
		found = true
	} else {
		// ì¼ë°˜ ì¹´ë“œ ìƒí’ˆì—ì„œ ì°¾ê¸°
		for _, products := range cardCategories {
			for _, prod := range products {
				if prod.Code == productCode {
					prodName = prod.Name
					price = prod.Price
					found = true
					break
				}
			}
			if found {
				break
			}
		}
	}

	if !found {
		sendTelegram(uid, "âŒ í•´ë‹¹ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		callback := tgbotapi.NewCallback(cb.ID, "ìƒí’ˆ ì •ë³´ ì—†ìŒ")
		bot.Request(callback)
		return
	}

	// ì£¼ë¬¸ ìƒì„±
	order, err := createOrder(uid, prodName, price)
	if err != nil {
		sendTelegram(uid, "âŒ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: "+err.Error())
		return
	}

	// ë©”ì‹œì§€ í…ìŠ¤íŠ¸ êµ¬ì„±
	msgText := fmt.Sprintf(
		"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n"+
			"ğŸ›’ <b>%s</b>\n"+
			"ğŸ’° ê°€ê²©: <b>%.3f USDT</b>\n"+
			"<b>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</b>\n\n"+
			"<b>ê²°ì œìˆ˜ë‹¨ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.</b>\n",
		prodName, price,
	)

	// ì¸ë¼ì¸ ë²„íŠ¼ êµ¬ì„±
	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’¸ ì½”ì¸ ê²°ì œ", fmt.Sprintf("pay_coin_%d", order.ID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¦ ì”ì•¡ ê²°ì œ", fmt.Sprintf("pay_balance_%d", order.ID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ëŒì•„ê°€ê¸°", "go_main"),
		),
	)

	// ë©”ì‹œì§€ ìˆ˜ì • ë° ì „ì†¡
	edt := tgbotapi.NewEditMessageTextAndMarkup(chatID, messageID, msgText, markup)
	edt.ParseMode = "HTML"
	if _, err := bot.Send(edt); err != nil {
		log.Printf("âŒ ì£¼ë¬¸ í™•ì¸ ë²„íŠ¼ í‘œì‹œ ì‹¤íŒ¨: %v", err)
	}
}

func main() {
	initDB()
	migrateDB()

	// VPS ìƒí’ˆ ë“±ë¡ (ì¤‘ë³µ ë“±ë¡ ì²´í¬ í•„ìš”)
	if err := addVPSProducts(); err != nil {
		log.Fatalf("VPS ìƒí’ˆ ë“±ë¡ ì‹¤íŒ¨: %v", err)
	}

	log.SetFlags(log.LstdFlags | log.Lshortfile)
	rand.Seed(time.Now().UnixNano())
	log.Println("ğŸš€ EPUSDT ë´‡ ì‹œì‘ ì¤‘...")

	startTime := time.Now()

	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	if token == "" {
		log.Fatal("âŒ TELEGRAM_BOT_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
	}
	log.Printf("ğŸ” ë¡œë“œëœ í† í°: %s", token)

	startDepositMonitoring()

	var err error
	bot, err = initBotWithWebhook()
	if err != nil {
		log.Fatalf("âŒ ë´‡ ì´ˆê¸°í™” ì‹¤íŒ¨: %v", err)
	}
	log.Println("âœ… ë´‡ ì´ˆê¸°í™” ì™„ë£Œ")

	router := gin.Default()
	router.SetTrustedProxies(nil)

	router.POST("/webhook", handleWebhook)
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "ok", "uptime": time.Since(startTime).String()})
	})

	log.Println("ğŸŒ ì„œë²„ë¥¼ 9020 í¬íŠ¸ì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤...")
	if err := router.Run(":9020"); err != nil {
		log.Fatalf("âŒ ì„œë²„ ì‹¤í–‰ ì‹¤íŒ¨: %v", err)
	}
}

// ë¬¸ìì—´ í¬ì¸í„° ìƒì„± í•¨ìˆ˜
func ptr(s string) *string {
	return &s
}

func createOrder(uid int64, prodName string, price float64) (*Order, error) {
	emptyTxID := "" // ë¹ˆ ë¬¸ìì—´ ë³€ìˆ˜ ì„ ì–¸
	order := Order{
		UserID:      uid,
		Product:     prodName,
		Amount:      price,
		Status:      "ì…ê¸ˆëŒ€ê¸°ì¤‘",
		ExpectedAmt: price,
		Timestamp:   time.Now(),
		TxID:        &emptyTxID, // ë¹ˆ ë¬¸ìì—´ í¬ì¸í„° ì „ë‹¬
	}
	if err := db.Create(&order).Error; err != nil {
		return nil, err
	}
	return &order, nil
}

func confirmDeposit(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return err
	}

	// ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
	order.Status = "ì…ê¸ˆí™•ì¸"
	txIDCopy := txID
	order.TxID = &txIDCopy

	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// ì¹´ë“œ ìë™ ì§€ê¸‰ ë¶€ë¶„ ì œê±°ë¨
	// ì¹´ë“œ ì •ë³´ ì—…ë°ì´íŠ¸ëŠ” í•„ìš”ì— ë”°ë¼ ì§ì ‘ ì²˜ë¦¬í•˜ì„¸ìš”
	// ì˜ˆë¥¼ ë“¤ì–´, ì¹´ë“œ ì •ë³´ ì—†ì´ ìƒíƒœë§Œ ì™„ë£Œ ì²˜ë¦¬í•  ê²½ìš°:

	order.Status = "ì™„ë£Œ"
	if err := db.Save(&order).Error; err != nil {
		return err
	}

	// ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì—ëŸ¬ ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ë¦¬í„´ì€ ì•ˆí•¨)
	if err := sendTelegram(order.UserID, fmt.Sprintf("âœ… ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\nìƒí’ˆ: %s\n", order.Product)); err != nil {
		log.Printf("ì‚¬ìš©ì ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}

	return nil
}

// ì”ì•¡ í™•ì¸
func getUserBalance(userID int64) (float64, error) {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// ì”ì•¡ì´ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™”
			balance = UserBalance{UserID: userID, Balance: 0}
			db.Create(&balance)
			return 0, nil
		}
		return 0, err
	}
	return balance.Balance, nil
}

// ì”ì•¡ ì°¨ê°
func deductBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		return err
	}

	if balance.Balance < amount {
		return fmt.Errorf("ì”ì•¡ ë¶€ì¡±")
	}

	balance.Balance -= amount
	return db.Save(&balance).Error
}

// ì”ì•¡ ì¶”ê°€
func addBalance(userID int64, amount float64) error {
	var balance UserBalance
	err := db.Where("user_id = ?", userID).First(&balance).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			balance = UserBalance{UserID: userID, Balance: amount}
			return db.Create(&balance).Error
		}
		return err
	}

	balance.Balance += amount
	return db.Save(&balance).Error
}

// ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ
func getUserOrders(userID int64) ([]Order, error) {
	var orders []Order
	err := db.Where("user_id = ?", userID).Order("timestamp desc").Find(&orders).Error
	return orders, err
}

// ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
func updateOrderStatus(orderID uint, status string) error {
	return db.Model(&Order{}).Where("id = ?", orderID).Update("status", status).Error
}

// ì¹´ë“œ ì¬ê³  í™•ì¸
func getCardStock(category string) (int64, error) {
	var count int64
	err := db.Model(&StockCard{}).Where("category = ? AND used = ?", category, false).Count(&count).Error
	return count, err
}

// ì‚¬ìš©ëœ ì¹´ë“œ ì¡°íšŒ
func getUsedCards(userID int64) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("used_by = ?", userID).Find(&cards).Error
	return cards, err
}

// í†µê³„ ë°ì´í„° ì¡°íšŒ
func updateDailyStats(amount float64) error {
	today := time.Now().Format("2006-01-02")

	var stats SalesStats
	err := db.Where("date = ?", today).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: today, TotalSales: amount, TotalCount: 1, Count: 1, SalesCount: 1}
			return db.Create(&stats).Error
		}
		return err
	}

	stats.TotalSales += amount
	stats.TotalCount++
	stats.Count++
	stats.SalesCount++

	return db.Save(&stats).Error
}

func handleCreateTransaction(c *gin.Context) {
	var req struct {
		UserID      int64   `json:"user_id"`
		ProductCode string  `json:"product_code"`
		Amount      float64 `json:"amount"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "ì˜ëª»ëœ ìš”ì²­"})
		return
	}

	// ì£¼ë¬¸ ìƒì„±
	order, err := createOrder(req.UserID, req.ProductCode, req.Amount)
	if err != nil {
		c.JSON(500, gin.H{"error": "ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨"})
		return
	}

	// ì§€ê°‘ ì£¼ì†Œ ìƒì„±
	walletAddress, err := generateWalletAddress()
	if err != nil {
		c.JSON(500, gin.H{"error": "ì§€ê°‘ ìƒì„± ì‹¤íŒ¨"})
		return
	}

	c.JSON(200, gin.H{
		"order_id": order.ID,
		"address":  walletAddress,
		"amount":   req.Amount,
	})
}

func showAdminStockMenu(uid, chatID int64, messageID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	text := "ğŸ“¦ ì¬ê³  í˜„í™©\n\n"
	totalStock := int64(0)

	for _, category := range categories {
		count, err := getCardStock(category)
		if err != nil {
			text += fmt.Sprintf("âŒ %s: ì¡°íšŒ ì‹¤íŒ¨\n", category)
		} else {
			text += fmt.Sprintf("âœ… %s: %dê°œ\n", category, count)
			totalStock += count
		}
	}

	text += fmt.Sprintf("\nğŸ“Š ì´ ì¬ê³ : %dê°œ", totalStock)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“‹ ìƒì„¸ë³´ê¸°", "admin_stock_detail"),
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", "admin_add_stock"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì¬ê³ ì‚­ì œ", "admin_del_stock"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š ë¶„ì„", "admin_stock_analytics"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ìë©”ë‰´", "admin_menu"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &kb
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ê´€ë¦¬ì ì¬ê³  ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

func createProductManagementKeyboard(productID int, productName string, price float64) tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData(fmt.Sprintf("%s %.2fUSDT", productName, price), fmt.Sprintf("product_detail_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ ìˆ˜ì •", fmt.Sprintf("product_edit_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ ì‚­ì œ", fmt.Sprintf("product_delete_%d", productID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“¦ ì¬ê³ ", fmt.Sprintf("product_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("â• ì¬ê³ ì¶”ê°€", fmt.Sprintf("product_add_stock_%d", productID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ê´€ë¦¬ìë©”ë‰´ë¡œ", "admin_menu"),
		),
	)
}

func showProductListForCategory(uid, chatID int64, messageID int, category string) {
	products, err := getProductsByCategory(category) // DBì—ì„œ ìƒí’ˆ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ í•¨ìˆ˜ ì˜ˆì‹œ
	if err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		return
	}

	text := fmt.Sprintf("ğŸ“‹ %s ìƒí’ˆ ëª©ë¡\n\n", category)
	for i, p := range products {
		text += fmt.Sprintf("%d. %s - %.2f USDT\n", i+1, p.Name, p.Price)
	}

	// ê°œë³„ ìƒí’ˆë³„ ë²„íŠ¼ì„ InlineKeyboardì— ë‹´ê¸°
	var keyboardRows [][]tgbotapi.InlineKeyboardButton
	for _, p := range products {
		kb := createProductManagementKeyboard(int(p.ID), p.Name, p.Price) // pë¡œ ìˆ˜ì •
		for _, row := range kb.InlineKeyboard {
			keyboardRows = append(keyboardRows, row)
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: keyboardRows}
	msg.ParseMode = "HTML"

	if _, err := bot.Send(msg); err != nil {
		log.Printf("ìƒí’ˆ ë¦¬ìŠ¤íŠ¸ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func getProductsByCategory(category string) ([]Product, error) {
	var products []Product
	err := db.Where("category = ?", category).Find(&products).Error
	if err != nil {
		return nil, err
	}
	return products, nil
}

func showAdminStatsMenu(uid, chatID int64, messageID int) {
	// ì¼ì¼ í†µê³„ ì¡°íšŒ
	stats, err := getDailyStatsNew()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("ğŸ“Š ì¼ì¼ í†µê³„ (%s)\n\n", stats.Date)
	text += fmt.Sprintf("ì´ ë§¤ì¶œ: %.4f USDT\n", stats.TotalSales)
	text += fmt.Sprintf("ì´ ì£¼ë¬¸: %dê±´\n", stats.TotalCount)
	text += fmt.Sprintf("ì™„ë£Œ ì£¼ë¬¸: %dê±´\n", stats.SalesCount)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ì£¼ê°„ í†µê³„", CallbackData: ptr("admin_weekly_stats")}},
			{{Text: "ì›”ê°„ í†µê³„", CallbackData: ptr("admin_monthly_stats")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

func showAdminUserListMenu(uid, chatID int64, messageID int) {
	// ìœ ì € ëª©ë¡ ì¡°íšŒ (ìµœê·¼ 10ëª…)
	users, err := getRecentUsers(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ìœ ì € ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ‘¥ ìµœê·¼ ê°€ì… ìœ ì € (10ëª…)\n\n"
	var rows [][]tgbotapi.InlineKeyboardButton

	for i, user := range users {
		nickname := user.Nickname
		if nickname == "" {
			nickname = "(ë‹‰ë„¤ì„ì—†ìŒ)"
		}
		userName := user.UserName
		if userName == "" {
			userName = "ì—†ìŒ"
		}
		text += fmt.Sprintf(
			"%d. <b>%s</b> <code>%d</code> @%s - %s\n",
			i+1, nickname, user.UserID, userName, user.LastSeen.Format("01-02 15:04"),
		)
		// ë²„íŠ¼ì—ë„ ë‹‰ë„¤ì„ í‘œì‹œ
		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s", nickname),
			fmt.Sprintf("admin_user_detail_%d", user.UserID),
		)
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
	}

	// í•˜ë‹¨ ê³ ì • ë²„íŠ¼
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ì „ì²´ ìœ ì €", "admin_all_users"),
	))
	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
	))

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	bot.Request(msg)
}

func getUserByUserID(userID int64) (*User, error) {
	var user User
	result := db.Where("user_id = ?", userID).First(&user)
	if result.Error != nil {
		return nil, result.Error
	}
	return &user, nil
}

func showAdminUserDetailMenu(chatID int64, messageID int, userID int64) {
	user, err := getUserByUserID(userID)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ìœ ì € ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	// ë“±ê¸‰ ì´ëª¨ì§€ë§Œ
	emoji := getGradeEmoji(user.Grade)

	text := fmt.Sprintf(
		"ğŸ‘¤ <b>ìœ ì € ì •ë³´</b>\n\n"+
			"â€¢ <b>ê³ ìœ ë²ˆí˜¸</b>: <code>%d</code>\n"+
			"â€¢ <b>ìœ ì €ë„¤ì„</b>: <b>%s</b>\n"+
			"â€¢ <b>ë“±ê¸‰</b>: %s\n"+
			"â€¢ <b>ìµœê·¼ì ‘ì†</b>: <code>%s</code>",
		user.UserID,
		func() string {
			if user.UserName == "" {
				return "unknown"
			}
			return "@" + user.UserName
		}(),
		emoji, user.LastSeen.Format("2006-01-02 15:04"),
	)

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‰", fmt.Sprintf("admin_set_grade_bronze_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥ˆ", fmt.Sprintf("admin_set_grade_silver_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ¥‡", fmt.Sprintf("admin_set_grade_gold_%d", userID)),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ’", fmt.Sprintf("admin_set_grade_diamond_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ‘‘", fmt.Sprintf("admin_set_grade_vip_%d", userID)),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ëŒì•„ê°€ê¸°", "admin_user_list"),
		),
	)

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ParseMode = "HTML"
	msg.ReplyMarkup = &kb
	bot.Request(msg)
}

func showAdminOrderListMenu(uid, chatID int64, messageID int) {
	// ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ
	orders, err := getRecentOrders(10)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ“‹ ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ (10ê±´)\n\n"
	for i, order := range orders {
		text += fmt.Sprintf("%d. %s - %.4f USDT - %s\n",
			i+1, order.Product, order.Amount, order.Status)
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ì „ì²´ ì£¼ë¬¸", CallbackData: ptr("admin_all_orders")}},
			{{Text: "ë¯¸ì²˜ë¦¬ ì£¼ë¬¸", CallbackData: ptr("admin_pending_orders")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
func getRecentUsers(limit int) ([]User, error) {
	var users []User
	err := db.Order("joined_at desc").Limit(limit).Find(&users).Error
	return users, err
}

func getRecentOrders(limit int) ([]Order, error) {
	var orders []Order
	err := db.Order("timestamp desc").Limit(limit).Find(&orders).Error
	return orders, err
}

func getPendingOrders() ([]Order, error) {
	var orders []Order
	err := db.Where("status = ?", "ì…ê¸ˆëŒ€ê¸°ì¤‘").Find(&orders).Error
	return orders, err
}

func getSumAmountBetweenDatesAndCategory(start, end, categoryLike string) (float64, error) {
	var total sql.NullFloat64
	err := db.Raw(
		"SELECT SUM(amount) FROM orders WHERE timestamp BETWEEN ? AND ? AND product LIKE ?",
		start, end, categoryLike+"%",
	).Scan(&total).Error
	if err != nil {
		return 0, err
	}
	if total.Valid {
		return total.Float64, nil
	}
	return 0, nil // NULLì¸ ê²½ìš° 0 ë°˜í™˜
}

// ì˜ˆ: ì£¼ê°„ ë§¤ì¶œ í†µê³„ í•¨ìˆ˜ ë‚´ì—ì„œ í˜¸ì¶œ ì˜ˆì‹œ
func getWeeklySalesByCategory() (map[string]float64, error) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}
	start := time.Now().AddDate(0, 0, -7).Format("2006-01-02")
	end := time.Now().Format("2006-01-02")

	results := make(map[string]float64)
	for _, cat := range categories {
		sum, err := getSumAmountBetweenDatesAndCategory(start, end, cat)
		if err != nil {
			log.Printf("ì¹´í…Œê³ ë¦¬ %s ë§¤ì¶œ ì¡°íšŒ ì‹¤íŒ¨: %v", cat, err)
			continue
		}
		results[cat] = sum
	}
	return results, nil
}

// ì£¼ê°„/ì›”ê°„ í†µê³„
func getWeeklyStats() (SalesStats, error) {
	weekStart := time.Now().AddDate(0, 0, -7).Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date >= ?", weekStart).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: weekStart, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

func getMonthlyStats() (SalesStats, error) {
	monthStart := time.Now().AddDate(0, -1, 0).Format("2006-01-02")
	var stats SalesStats

	err := db.Where("date >= ?", monthStart).First(&stats).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			stats = SalesStats{Date: monthStart, TotalSales: 0, TotalCount: 0, Count: 0, SalesCount: 0}
			db.Create(&stats)
			return stats, nil
		}
		return stats, err
	}

	return stats, nil
}

// ì¹´ë“œ ì¬ê³  ê´€ë¦¬
func addCardStock(category, name, content string) error {
	card := StockCard{
		Category:  category,
		Name:      name,
		Content:   content,
		Used:      false,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	return db.Create(&card).Error // â˜… ìˆ˜ì •!
}

func deleteCardStock(cardID uint) error {
	return db.Delete(&StockCard{}, cardID).Error
}

func getCardStockByCategory(category string) ([]StockCard, error) {
	var cards []StockCard
	err := db.Where("category = ?", category).Find(&cards).Error
	return cards, err
}

// ì‚¬ìš©ì í™œë™ ë¡œê·¸
func logUserActivity(userID int64, action string) error {
	log := UserActivityLog{
		UserID:     userID,
		LastActive: time.Now(),
	}
	return db.Create(&log).Error
}

// ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
func checkSystemHealth() map[string]interface{} {
	health := make(map[string]interface{})

	// DB ì—°ê²° ìƒíƒœ
	sqlDB, err := db.DB()
	if err != nil {
		health["database"] = "error"
	} else if err = sqlDB.Ping(); err != nil {
		health["database"] = "error"
	} else {
		health["database"] = "ok"
	}

	// ë´‡ ìƒíƒœ
	if bot != nil {
		health["bot"] = "ok"
	} else {
		health["bot"] = "error"
	}

	// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	health["memory_mb"] = float64(m.Alloc) / 1024 / 1024

	// ì—…íƒ€ì„
	health["uptime"] = time.Since(startTime).String()

	return health
}

// í™˜ê²½ ì„¤ì • ê´€ë¦¬
func updateBotSettings(setting string, value string) error {
	// ì„¤ì • ì—…ë°ì´íŠ¸ ë¡œì§
	log.Printf("ì„¤ì • ì—…ë°ì´íŠ¸: %s = %s", setting, value)
	return nil
}

func getBotSettings() map[string]string {
	settings := make(map[string]string)
	settings["webhook_url"] = os.Getenv("WEBHOOK_URL")
	settings["tron_api_key"] = os.Getenv("TRON_API_KEY")
	settings["admin_user_id"] = os.Getenv("ADMIN_USER_ID")
	return settings
}

// ë¡œê·¸ ê´€ë¦¬
func getSystemLogs(limit int) ([]string, error) {
	// ì‹œìŠ¤í…œ ë¡œê·¸ ì¡°íšŒ ë¡œì§
	logs := []string{
		"2025-06-29 21:14:15 [INFO] ë´‡ ì‹œì‘ë¨",
		"2025-06-29 21:14:16 [INFO] DB ì—°ê²° ì„±ê³µ",
		"2025-06-29 21:14:17 [INFO] ì›¹í›… ì„¤ì • ì™„ë£Œ",
	}
	return logs, nil
}

func clearSystemLogs() error {
	// ì‹œìŠ¤í…œ ë¡œê·¸ ì •ë¦¬ ë¡œì§
	log.Println("ì‹œìŠ¤í…œ ë¡œê·¸ ì •ë¦¬ ì™„ë£Œ")
	return nil
}

// ê³ ê¸‰ ê´€ë¦¬ì ê¸°ëŠ¥ë“¤
func showAdvancedAdminMenu(uid, chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageText(chatID, messageID, "ğŸ”§ ê³ ê¸‰ ê´€ë¦¬ì ë©”ë‰´\n\nì‹œìŠ¤í…œ ê´€ë¦¬ ë° ê³ ê¸‰ ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”.")
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ì‹œìŠ¤í…œ ìƒíƒœ", CallbackData: ptr("admin_system_health")}},
			{{Text: "ë¡œê·¸ ê´€ë¦¬", CallbackData: ptr("admin_logs")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ë©”ë‰´
func showSystemHealthMenu(uid, chatID int64, messageID int) {
	health := checkSystemHealth()

	text := "ğŸ” ì‹œìŠ¤í…œ ìƒíƒœ\n\n"
	text += fmt.Sprintf("ë°ì´í„°ë² ì´ìŠ¤: %s\n", health["database"])
	text += fmt.Sprintf("ë´‡ ìƒíƒœ: %s\n", health["bot"])
	text += fmt.Sprintf("ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: %.2f MB\n", health["memory_mb"])
	text += fmt.Sprintf("ì—…íƒ€ì„: %s\n", health["uptime"])

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ìƒˆë¡œê³ ì¹¨", CallbackData: ptr("admin_refresh_health")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ë¡œê·¸ ê´€ë¦¬ ë©”ë‰´
func showLogsMenu(uid, chatID int64, messageID int) {
	logs, err := getSystemLogs(5)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ“‹ ìµœê·¼ ì‹œìŠ¤í…œ ë¡œê·¸ (5ê±´)\n\n"
	for _, log := range logs {
		text += log + "\n"
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ë¡œê·¸ ì •ë¦¬", CallbackData: ptr("admin_clear_logs")}},
			{{Text: "ì „ì²´ ë¡œê·¸", CallbackData: ptr("admin_all_logs")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

// ì¬ê³  ì¡°íšŒ ë° ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ ë‚´ìš© ë°˜í™˜ í•¨ìˆ˜
func getCardStockAndContent(productName string) (int64, string, error) {
	var card StockCard
	count, err := getStockCount(productName)
	if err != nil {
		return 0, "", err
	}
	if count == 0 {
		return 0, "", nil
	}

	// ì¬ê³  ì¤‘ í•˜ë‚˜ì˜ ì¹´ë“œ ë‚´ìš©ì„ ê°€ì ¸ì˜´
	err = db.Where("name = ? AND used = ?", productName, false).First(&card).Error
	if err != nil {
		return count, "", err
	}

	return count, card.Content, nil
}

func processOrderWithValidation(orderID uint, txID string) error {
	var order Order
	if err := db.First(&order, orderID).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}

	if order.Status != "ì…ê¸ˆëŒ€ê¸°ì¤‘" && order.Status != "ê²°ì œì™„ë£Œ" {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: %s", order.Status)
	}

	stock, cardContent, err := getCardStockAndContent(order.Product)
	if err != nil {
		return fmt.Errorf("ì¬ê³  ì¡°íšŒ ì‹¤íŒ¨: %w", err)
	}
	if stock <= 0 {
		order.Status = "ì¬ê³ ì—†ìŒ"
		if err := db.Save(&order).Error; err != nil {
			return fmt.Errorf("ì¬ê³  ë¶€ì¡± ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
		}
		sendTelegram(order.UserID, "âŒ ì£¼ë¬¸í•˜ì‹  ìƒí’ˆì˜ ì¬ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.")
		return fmt.Errorf("ìƒí’ˆ ì¬ê³  ë¶€ì¡±: %s", order.Product)
	}

	err = db.Model(&StockCard{}).
		Where("name = ? AND used = 0", order.Product).
		Limit(1).
		Updates(map[string]interface{}{
			"used":     true,
			"used_by":  order.UserID,
			"order_id": order.ID,
		}).Error
	if err != nil {
		return fmt.Errorf("ì¬ê³  ì¹´ë“œ ì‚¬ìš© ì²˜ë¦¬ ì‹¤íŒ¨: %w", err)
	}

	txIDCopy := txID
	order.CardInfo = cardContent
	order.Status = "ì™„ë£Œ"
	order.TxID = &txIDCopy
	if err := db.Save(&order).Error; err != nil {
		return fmt.Errorf("ì£¼ë¬¸ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: %w", err)
	}

	if err := updateDailyStats(order.Amount); err != nil {
		log.Printf("í†µê³„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: %v", err)
	}

	notifyMsg := fmt.Sprintf(
		"ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤\n\nìƒí’ˆëª…: %s\nìƒí’ˆ ì •ë³´:\n%s\n\n ì˜¤ë¥˜ì‹œ ë¬¸ì˜ì£¼ì„¸ìš”.",
		order.Product, cardContent,
	)
	sendTelegram(order.UserID, notifyMsg)

	return nil
}

func sendOrderCompletionNotification(userID int64, product, cardContent string) {
	text := fmt.Sprintf(
		"ğŸ *ìƒí’ˆ ì§€ê¸‰ ì™„ë£Œ!*\n\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"+
			"ğŸ“¦ **ìƒí’ˆëª…**: %s\n"+
			"ğŸ« **ì¹´ë“œì •ë³´**:\n`%s`\n"+
			"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"+
			"âœ… ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n"+
			"ğŸ™ ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.\n\n"+
			"ğŸ’¡ ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ ê³ ê°ì„¼í„°ë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.",
		product, cardContent,
	)
	sendTelegram(userID, text)
}

// ê³ ê¸‰ í†µê³„ ë° ë¦¬í¬íŠ¸ ê¸°ëŠ¥ë“¤
func generateDetailedReport(startDate, endDate string) (map[string]interface{}, error) {
	report := make(map[string]interface{})

	var result struct {
		TotalSales  float64
		TotalOrders int64
	}

	// ê¸°ê°„ë³„ ì´ ë§¤ì¶œ ë° ì£¼ë¬¸ ìˆ˜
	err := db.Model(&Order{}).
		Where("timestamp BETWEEN ? AND ?", startDate, endDate).
		Select("COALESCE(SUM(amount), 0) as total_sales, COUNT(*) as total_orders").
		Scan(&result).Error
	if err != nil {
		return nil, err
	}

	var completedOrders int64
	err = db.Model(&Order{}).
		Where("timestamp BETWEEN ? AND ? AND status = ?", startDate, endDate, "ì™„ë£Œ").
		Count(&completedOrders).Error
	if err != nil {
		return nil, err
	}

	categorySales := make(map[string]float64)
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "SWAP", "ACCOUNT"}

	for _, category := range categories {
		var sales sql.NullFloat64
		err := db.Model(&Order{}).
			Where("timestamp BETWEEN ? AND ? AND product LIKE ?", startDate, endDate, category+"%").
			Select("SUM(amount)").
			Scan(&sales).Error
		if err != nil {
			return nil, err
		}
		if sales.Valid {
			categorySales[category] = sales.Float64
		} else {
			categorySales[category] = 0
		}
	}

	var newUsers int64
	err = db.Model(&User{}).
		Where("last_seen BETWEEN ? AND ?", startDate, endDate).
		Count(&newUsers).Error
	if err != nil {
		return nil, err
	}

	completionRate := 0.0
	if result.TotalOrders > 0 {
		completionRate = float64(completedOrders) / float64(result.TotalOrders) * 100
	}

	report["period"] = fmt.Sprintf("%s ~ %s", startDate, endDate)
	report["total_sales"] = result.TotalSales
	report["total_orders"] = result.TotalOrders
	report["completed_orders"] = completedOrders
	report["completion_rate"] = completionRate
	report["category_sales"] = categorySales
	report["new_users"] = newUsers

	return report, nil
}

func showDetailedReportMenu(uid, chatID int64, messageID int) {
	endDate := time.Now().Format("2006-01-02")
	startDate := time.Now().AddDate(0, 0, -7).Format("2006-01-02")

	report, err := generateDetailedReport(startDate, endDate)
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ë¦¬í¬íŠ¸ ìƒì„± ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := fmt.Sprintf("ğŸ“Š ìƒì„¸ ë¦¬í¬íŠ¸ (%s)\n\n", report["period"])
	text += fmt.Sprintf("ì´ ë§¤ì¶œ: %.4f USDT\n", report["total_sales"])
	text += fmt.Sprintf("ì´ ì£¼ë¬¸: %dê±´\n", report["total_orders"])
	text += fmt.Sprintf("ì™„ë£Œ ì£¼ë¬¸: %dê±´\n", report["completed_orders"])
	text += fmt.Sprintf("ì™„ë£Œìœ¨: %.1f%%\n", report["completion_rate"])
	text += fmt.Sprintf("ì‹ ê·œ ìœ ì €: %dëª…\n", report["new_users"])

	text += "\nğŸ“ˆ ì¹´í…Œê³ ë¦¬ë³„ ë§¤ì¶œ:\n"
	categorySales, ok := report["category_sales"].(map[string]float64)
	if ok {
		for category, sales := range categorySales {
			if sales > 0 {
				text += fmt.Sprintf("%s: %.4f USDT\n", category, sales)
			}
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{{Text: "ì›”ê°„ ë¦¬í¬íŠ¸", CallbackData: ptr("admin_monthly_report")}},
			{{Text: "ì—°ê°„ ë¦¬í¬íŠ¸", CallbackData: ptr("admin_yearly_report")}},
			{{Text: "ğŸ”™", CallbackData: ptr("admin_menu")}},
		},
	}
	bot.Request(msg)
}

func validateAdminAccess(userID int64) bool {
	adminUserIDStr := os.Getenv("ADMIN_USER_ID")
	if adminUserIDStr == "" {
		return false
	}

	adminUserID, err := strconv.ParseInt(adminUserIDStr, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID ë³€í™˜ ì‹¤íŒ¨: %v", err)
		return false
	}

	return userID == adminUserID
}

func logAdminAction(userID int64, action string) {
	log.Printf("[ADMIN] User %d performed action: %s", userID, action)
}

// ìƒí’ˆ ì½”ë“œ ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜
func validateProductCode(productCode string) error {
	validProducts := getAllValidProductCodes()
	for _, valid := range validProducts {
		if productCode == valid {
			return nil
		}
	}
	return fmt.Errorf("ìœ íš¨í•˜ì§€ ì•Šì€ ìƒí’ˆ ì½”ë“œ: %s", productCode)
}

func getAllValidProductCodes() []string {
	codes := []string{}
	for _, products := range cardCategories {
		for _, prod := range products {
			codes = append(codes, prod.Code)
		}
	}
	return codes
}

// ì•Œë¦¼ ë° ëª¨ë‹ˆí„°ë§ ê¸°ëŠ¥ë“¤
func sendSystemAlert(message string) {
	adminUserID := os.Getenv("ADMIN_USER_ID")
	if adminUserID == "" {
		return
	}

	adminID, err := strconv.ParseInt(adminUserID, 10, 64)
	if err != nil {
		log.Printf("ADMIN_USER_ID ë³€í™˜ ì‹¤íŒ¨: %v", err)
		return
	}

	if err := sendTelegram(adminID, "ğŸš¨ ì‹œìŠ¤í…œ ì•Œë¦¼: "+message); err != nil {
		log.Printf("ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)
	}
}

func monitorSystemHealth() {
	ticker := time.NewTicker(5 * time.Minute)
	go func() {
		for range ticker.C {
			health := checkSystemHealth()

			// ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ì²´í¬
			if health["database"] != "ok" {
				sendSystemAlert("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì˜¤ë¥˜")
			}

			// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬
			memoryMB := health["memory_mb"].(float64)
			if memoryMB > 500 {
				sendSystemAlert(fmt.Sprintf("ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ: %.2f MB", memoryMB))
			}
		}
	}()
}

// ê³ ê¸‰ ì‚¬ìš©ì ê´€ë¦¬ ê¸°ëŠ¥ë“¤
func getUserDetailedInfo(userID int64) (map[string]interface{}, error) {
	info := make(map[string]interface{})

	// ì‚¬ìš©ì ê¸°ë³¸ ì •ë³´
	var user User
	err := db.Where("user_id = ?", userID).First(&user).Error
	if err != nil {
		return nil, err
	}

	// ì£¼ë¬¸ ë‚´ì—­
	orders, err := getUserOrders(userID)
	if err != nil {
		return nil, err
	}

	// ì”ì•¡ ì •ë³´
	balance, err := getUserBalance(userID)
	if err != nil {
		return nil, err
	}

	// ì‚¬ìš©ëœ ì¹´ë“œ
	cards, err := getUsedCards(userID)
	if err != nil {
		return nil, err
	}

	info["user"] = user
	info["orders"] = orders
	info["balance"] = balance
	info["used_cards"] = cards
	info["total_spent"] = calculateTotalSpent(orders)
	info["order_count"] = len(orders)

	return info, nil
}

func calculateTotalSpent(orders []Order) float64 {
	total := 0.0
	for _, order := range orders {
		if order.Status == "ì™„ë£Œ" {
			total += order.Amount
		}
	}
	return total
}

// ê³ ê¸‰ ì¬ê³  ê´€ë¦¬ ê¸°ëŠ¥ë“¤
func getStockAnalytics() (map[string]interface{}, error) {
	analytics := make(map[string]interface{})

	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}

	for _, category := range categories {
		// ì´ ì¬ê³ 
		var totalStock int64
		db.Model(&StockCard{}).Where("category = ?", category).Count(&totalStock)

		// ì‚¬ìš©ëœ ì¬ê³ 
		var usedStock int64
		db.Model(&StockCard{}).Where("category = ? AND used = ?", category, true).Count(&usedStock)

		// ì‚¬ìš© ê°€ëŠ¥í•œ ì¬ê³ 
		availableStock := totalStock - usedStock

		// ì‚¬ìš©ë¥ 
		usageRate := 0.0
		if totalStock > 0 {
			usageRate = float64(usedStock) / float64(totalStock) * 100
		}

		analytics[category] = map[string]interface{}{
			"total":      totalStock,
			"used":       usedStock,
			"available":  availableStock,
			"usage_rate": usageRate,
		}
	}

	return analytics, nil
}

func showStockAnalyticsMenu(uid, chatID int64, messageID int) {
	analytics, err := getStockAnalytics()
	if err != nil {
		msg := tgbotapi.NewEditMessageText(chatID, messageID, "âŒ ì¬ê³  ë¶„ì„ ì‹¤íŒ¨")
		bot.Request(msg)
		return
	}

	text := "ğŸ“Š ì¬ê³  ë¶„ì„\n\n"

	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "ACCOUNT"}
	for _, category := range categories {
		if data, ok := analytics[category].(map[string]interface{}); ok {
			text += fmt.Sprintf("%s:\n", category)
			text += fmt.Sprintf("  ì´ ì¬ê³ : %dê°œ\n", int(data["total"].(int64)))
			text += fmt.Sprintf("  ì‚¬ìš©ë¨: %dê°œ\n", int(data["used"].(int64)))
			text += fmt.Sprintf("  ì‚¬ìš©ê°€ëŠ¥: %dê°œ\n", int(data["available"].(int64)))
			text += fmt.Sprintf("  ì‚¬ìš©ë¥ : %.1f%%\n\n", data["usage_rate"].(float64))
		}
	}

	msg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	msg.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{
		InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
			{
				tgbotapi.NewInlineKeyboardButtonData("ì¬ê³  ì¶”ê°€", "admin_add_stock"),
				tgbotapi.NewInlineKeyboardButtonData("ì¬ê³  ì •ë¦¬", "admin_cleanup_stock"),
			},
			{
				tgbotapi.NewInlineKeyboardButtonData("ğŸ”™", "admin_menu"),
			},
		},
	}
	bot.Request(msg)
}

// ì¬ê³  ì¶”ê°€ ëª…ë ¹ì–´ ì²˜ë¦¬
func handleAddStockCommand(msg *tgbotapi.Message) {
	uid := int64(msg.From.ID)

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤.")
		return
	}

	text := `ğŸ“¦ ì¬ê³  ì¶”ê°€

ì¬ê³ ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”:

ğŸ“ í˜•ì‹: ì¹´í…Œê³ ë¦¬:ìƒí’ˆëª…:ë‚´ìš©

â€¢ CARD:HKì¹´ë“œ:1234-5678-9012-3456
â€¢ CARD:êµ­ì™¸ê²°ì œ:9876-5432-1098-7654
â€¢ MEMBERSHIP:ë„·í”Œë¦­ìŠ¤:user@email.com:pass123

ì§€ì› ì¹´í…Œê³ ë¦¬:
â€¢ CARD (ì¹´ë“œ)
â€¢ MEMBERSHIP (ë©¤ë²„ì‹­)
â€¢ ESIM (ì´ì‹¬)
â€¢ VPS (ê°€ìƒì„œë²„)
â€¢ ACCOUNT (ê³„ì •)

ì‚¬ì§„ê³¼ í•¨ê»˜ ë³´ë‚´ë©´ ìë™ìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤! ğŸ“¸`

	sendTelegram(uid, text)
}

// ê´€ë¦¬ì ì¬ê³  ìƒì„¸ë³´ê¸°
func showAdminStockDetail(uid, chatID int64, messageID int, productID int) {
	var product Product
	if err := db.First(&product, productID).Error; err != nil {
		sendTelegram(uid, "âŒ ìƒí’ˆ ìƒì„¸ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	var stocks []StockCard
	if err := db.Where("name = ?", product.Name).Find(&stocks).Error; err != nil {
		sendTelegram(uid, "âŒ ì¬ê³  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
		return
	}

	text := fmt.Sprintf(
		"ğŸ“‹ <b>ìƒí’ˆ ìƒì„¸</b>\n\n"+
			"â€¢ ì´ë¦„: %s\n"+
			"â€¢ ê°€ê²©: %.2f USDT\n"+
			"â€¢ ì¬ê³  ìˆ˜ëŸ‰: %d\n\n"+
			"----- ì¬ê³  ëª©ë¡ -----\n",
		product.Name, product.Price, len(stocks),
	)

	for i, stock := range stocks {
		usedStr := "ì‚¬ìš© ê°€ëŠ¥"
		if stock.Used {
			usedStr = "ì‚¬ìš©ë¨"
		}
		text += fmt.Sprintf("%d. %s (%s)\n", i+1, stock.Content, usedStr)
		if i >= 20 { // ë„ˆë¬´ ê¸¸ë©´ 20ê°œê¹Œì§€ë§Œ í‘œì‹œ
			text += "...\n(ë” ë§ì€ ì¬ê³ ê°€ ìˆìŠµë‹ˆë‹¤.)"
			break
		}
	}

	editMsg := tgbotapi.NewEditMessageText(chatID, messageID, text)
	editMsg.ParseMode = "HTML"
	if _, err := bot.Send(editMsg); err != nil {
		log.Printf("showAdminStockDetail ë©”ì‹œì§€ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

// ê´€ë¦¬ì ì¬ê³  ì‚­ì œ ë©”ë‰´
func showAdminStockDeleteMenu(uid, chatID int64, msgID int, productID int) {
	categories := []string{"MEMBERSHIP", "ESIM", "CARD", "VPS", "ACCOUNT"}

	text := "ğŸ—‘ï¸ ì¬ê³  ì‚­ì œ\n\nì‚­ì œí•  ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n\n"

	var rows [][]tgbotapi.InlineKeyboardButton
	var currentRow []tgbotapi.InlineKeyboardButton
	btnCount := 0

	for _, category := range categories {
		stockCount, err := getCardStock(category)
		if err != nil {
			continue
		}

		btn := tgbotapi.NewInlineKeyboardButtonData(
			fmt.Sprintf("%s (%dê°œ)", category, stockCount),
			fmt.Sprintf("del_stock_%s", category),
		)
		currentRow = append(currentRow, btn)
		btnCount++

		if btnCount%2 == 0 {
			rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
			currentRow = []tgbotapi.InlineKeyboardButton{}
		}
	}

	if len(currentRow) > 0 {
		rows = append(rows, tgbotapi.NewInlineKeyboardRow(currentRow...))
	}

	rows = append(rows, tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¬ê³ ë©”ë‰´", "admin_inventory"),
	))

	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: rows}
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}
}

// ì¹´í…Œê³ ë¦¬ë³„ ì¬ê³  ì‚­ì œ ì²˜ë¦¬
func handleDeleteStockCategory(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "del_stock_")

	// ì‚­ì œ ì „ í™•ì¸ ë©”ì‹œì§€
	stockCount, err := getCardStock(category)
	if err != nil {
		sendTelegram(uid, "âŒ ì¬ê³  ì¡°íšŒ ì‹¤íŒ¨")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì¡°íšŒ ì‹¤íŒ¨"))
		return
	}

	text := fmt.Sprintf("âš ï¸ ì •ë§ë¡œ %s ì¹´í…Œê³ ë¦¬ì˜ ëª¨ë“  ì¬ê³ (%dê°œ)ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!", category, stockCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("âœ… ì‚­ì œ í™•ì¸", fmt.Sprintf("confirm_del_%s", category)),
			tgbotapi.NewInlineKeyboardButtonData("âŒ ì·¨ì†Œ", "admin_del_stock"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì‚­ì œ í™•ì¸ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ í™•ì¸"))
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ì¬ê³  ì‚­ì œ í™•ì¸ ì²˜ë¦¬
func handleConfirmDeleteStock(cb *tgbotapi.CallbackQuery) {
	uid := int64(cb.From.ID)
	chatID := cb.Message.Chat.ID
	messageID := cb.Message.MessageID

	// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
	if !isAdmin(uid) {
		sendTelegram(uid, "âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ê¶Œí•œ ì—†ìŒ"))
		return
	}

	category := strings.TrimPrefix(cb.Data, "confirm_del_")

	// ì‹¤ì œ ì‚­ì œ ì‹¤í–‰
	var deletedCount int64
	result := db.Where("category = ?", category).Delete(&StockCard{})
	if result.Error != nil {
		log.Printf("ì¬ê³  ì‚­ì œ ì‹¤íŒ¨: %v", result.Error)
		sendTelegram(uid, "âŒ ì¬ê³  ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
		bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ ì‹¤íŒ¨"))
		return
	}

	deletedCount = result.RowsAffected

	// ì„±ê³µ ë©”ì‹œì§€
	text := fmt.Sprintf("âœ… %s ì¹´í…Œê³ ë¦¬ì˜ ì¬ê³  %dê°œê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.", category, deletedCount)

	markup := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ”™ ì¬ê³ ë©”ë‰´", "admin_inventory"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &markup
	edit.ParseMode = "HTML"

	if _, err := bot.Send(edit); err != nil {
		log.Printf("ì‚­ì œ ì™„ë£Œ ë©”ë‰´ ìˆ˜ì • ì‹¤íŒ¨: %v", err)
	}

	bot.Request(tgbotapi.NewCallback(cb.ID, "ì‚­ì œ ì™„ë£Œ"))
}
